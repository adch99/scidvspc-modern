Index: Makefile.conf
===================================================================
--- Makefile.conf	(revision 2842)
+++ Makefile.conf	(working copy)
@@ -41,8 +41,6 @@
 TCL_LIBRARY = @TCL_LIBRARY@
 TK_LIBRARY  = @TK_LIBRARY@
 
-CQL_INCLUDE = -Isrc/cql -Isrc
-
 ### Nalimov tablebases
 # TB =                   for no tablebase support
 # TB = -DSCID_USE_TB     for tablebase support
@@ -127,94 +125,6 @@
       src/universalchardet/nsSJISProber.o src/universalchardet/nsUniversalDetector.o \
       src/universalchardet/nsUTF8Prober.o
 
-# Integrated CQL objects.
-CQLOBJS_I=  \
-  src/cql/i_countsquaresnode.o src/cql/i_cqlassert.o \
-  src/cql/i_cqlexit.o src/cql/i_cqlglobals.o src/cql/i_linearize.o \
-  src/cql/i_deleteable.o src/cql/i_repeatconstituent.o src/cql/i_sequencenest.o \
-  src/cql/i_assignnode.o src/cql/i_attacknode.o src/cql/i_beginvariationnode.o \
-  src/cql/i_betweennode.o src/cql/i_chesstypes.o src/cql/i_clone.o \
-  src/cql/i_colortransform.o src/cql/i_commentbase.o src/cql/i_composetransform.o \
-  src/cql/i_cqlinitialize.o \
-  src/cql/i_cqlnodematch.o src/cql/i_cqlnode.o \
-  src/cql/i_dihedraltransform.o src/cql/i_directionmatch.o src/cql/i_direction.o \
-  src/cql/i_directionparameter.o src/cql/i_echodistancespec.o src/cql/i_echolcaspec.o \
-  src/cql/i_echolongestsubstringspec.o src/cql/i_echomatchinfo.o src/cql/i_echonode.o \
-  src/cql/i_echoparse.o src/cql/i_echosidetomovespec.o src/cql/i_echospec.o \
-  src/cql/i_echosquarespec.o src/cql/i_echosquarespec-transform.o src/cql/i_echotransformspec.o \
-  src/cql/i_elonode.o src/cql/i_eventnode.o src/cql/i_existsnode.o \
-  src/cql/i_extensionnode.o src/cql/i_filename.o src/cql/i_forallnode.o \
-  src/cql/i_futurenode.o src/cql/i_futurestarnode.o src/cql/i_gamesortinfo.o \
-  src/cql/i_holderconstituent.o src/cql/i_keywords.o src/cql/i_lexer.o \
-  src/cql/i_longestcommonsubstring.o src/cql/i_markboardmap.o src/cql/i_markboard.o \
-  src/cql/i_markboardstatic.o src/cql/i_matchcommentnode.o src/cql/i_matchcountnode.o \
-  src/cql/i_match.o src/cql/i_movebase.o src/cql/i_movenumbernode.o \
-  src/cql/i_nodematch.o src/cql/i_node.o src/cql/i_nodetransform.o \
-  src/cql/i_notnode.o src/cql/i_numericvariable.o src/cql/i_onnode.o \
-  src/cql/i_optionalconstituent.o src/cql/i_origChanges.o src/cql/i_originnode.o \
-  src/cql/i_ornode.o src/cql/i_parser.o \
-  src/cql/i_pastnode.o src/cql/i_paststarnode.o src/cql/i_pieceidnode.o \
-  src/cql/i_piecelocmatch.o src/cql/i_pieceloc.o src/cql/i_piecelocparse.o \
-  src/cql/i_piover4transform.o src/cql/i_playernode.o src/cql/i_plusconstituent.o \
-  src/cql/i_positionnode.o src/cql/i_powerdifferencenode.o src/cql/i_powernode.o \
-  src/cql/i_raynode.o src/cql/i_seqconstituent.o src/cql/i_seqret.o \
-  src/cql/i_sequencebase.o src/cql/i_sequencematch.o src/cql/i_setbase.o \
-  src/cql/i_shifttransform.o src/cql/i_sitenode.o src/cql/i_sortvalue.o \
-  src/cql/i_squaremask.o src/cql/i_squarevariable.o src/cql/i_starconstituent.o \
-  src/cql/i_tagvariable.o src/cql/i_token.o src/cql/i_tokenstream.o \
-  src/cql/i_transform_members.o src/cql/i_transformnode.o \
-  src/cql/i_transform.o src/cql/i_transform-parse.o \
-  src/cql/i_util.o src/cql/i_variable.o src/cql/i_variations.o \
-  src/cql/i_vectorconstituent.o src/cql/i_vectornode.o src/cql/i_version.o \
-  src/cql/i_yearnode.o
-
-# Standalone CQL objects.
-CQLOBJS_S= src/cql/s_cql.o \
-  src/cql/s_countsquaresnode.o src/cql/s_cqlassert.o \
-  src/cql/s_cqlexit.o src/cql/s_cqlglobals.o src/cql/s_linearize.o \
-  src/cql/s_deleteable.o src/cql/s_repeatconstituent.o src/cql/s_sequencenest.o \
-  src/cql/s_assignnode.o src/cql/s_attacknode.o src/cql/s_beginvariationnode.o \
-  src/cql/s_betweennode.o src/cql/s_chesstypes.o src/cql/s_clone.o \
-  src/cql/s_colortransform.o src/cql/s_commentbase.o src/cql/s_composetransform.o \
-  src/cql/s_cqlinitialize.o \
-  src/cql/s_cqlnodematch.o src/cql/s_cqlnode.o \
-  src/cql/s_dihedraltransform.o src/cql/s_directionmatch.o src/cql/s_direction.o \
-  src/cql/s_directionparameter.o src/cql/s_echodistancespec.o src/cql/s_echolcaspec.o \
-  src/cql/s_echolongestsubstringspec.o src/cql/s_echomatchinfo.o src/cql/s_echonode.o \
-  src/cql/s_echoparse.o src/cql/s_echosidetomovespec.o src/cql/s_echospec.o \
-  src/cql/s_echosquarespec.o src/cql/s_echosquarespec-transform.o src/cql/s_echotransformspec.o \
-  src/cql/s_elonode.o src/cql/s_eventnode.o src/cql/s_existsnode.o \
-  src/cql/s_extensionnode.o src/cql/s_filename.o src/cql/s_forallnode.o \
-  src/cql/s_futurenode.o src/cql/s_futurestarnode.o src/cql/s_gamesortinfo.o \
-  src/cql/s_holderconstituent.o src/cql/s_keywords.o src/cql/s_lexer.o \
-  src/cql/s_longestcommonsubstring.o src/cql/s_markboardmap.o src/cql/s_markboard.o \
-  src/cql/s_markboardstatic.o src/cql/s_matchcommentnode.o src/cql/s_matchcountnode.o \
-  src/cql/s_match.o src/cql/s_movebase.o src/cql/s_movenumbernode.o \
-  src/cql/s_nodematch.o src/cql/s_node.o src/cql/s_nodetransform.o \
-  src/cql/s_notnode.o src/cql/s_numericvariable.o src/cql/s_onnode.o \
-  src/cql/s_optionalconstituent.o src/cql/s_origChanges.o src/cql/s_originnode.o \
-  src/cql/s_ornode.o src/cql/s_parser.o \
-  src/cql/s_pastnode.o src/cql/s_paststarnode.o src/cql/s_pieceidnode.o \
-  src/cql/s_piecelocmatch.o src/cql/s_pieceloc.o src/cql/s_piecelocparse.o \
-  src/cql/s_piover4transform.o src/cql/s_playernode.o src/cql/s_plusconstituent.o \
-  src/cql/s_positionnode.o src/cql/s_powerdifferencenode.o src/cql/s_powernode.o \
-  src/cql/s_raynode.o src/cql/s_seqconstituent.o src/cql/s_seqret.o \
-  src/cql/s_sequencebase.o src/cql/s_sequencematch.o src/cql/s_setbase.o \
-  src/cql/s_shifttransform.o src/cql/s_sitenode.o src/cql/s_sortvalue.o \
-  src/cql/s_squaremask.o src/cql/s_squarevariable.o src/cql/s_starconstituent.o \
-  src/cql/s_tagvariable.o src/cql/s_token.o src/cql/s_tokenstream.o \
-  src/cql/s_transform_members.o src/cql/s_transformnode.o \
-  src/cql/s_transform.o src/cql/s_transform-parse.o \
-  src/cql/s_util.o src/cql/s_variable.o src/cql/s_variations.o \
-  src/cql/s_vectorconstituent.o src/cql/s_vectornode.o src/cql/s_version.o \
-  src/cql/s_yearnode.o \
-  src/bytebuf.o src/crosstab.o src/date.o src/dstring.o \
-  src/filter.o src/game.o src/gfile.o src/index.o src/matsig.o \
-  src/mfile.o src/misc.o src/movelist.o src/myassert.o src/namebase.o \
-  src/optable.o src/pgnparse.o src/pbook.o src/position.o src/probe.o \
-  src/spellchk.o src/stored.o src/stralloc.o src/textbuf.o src/tree.o
-
-
 ### ZLIBOBJS: object files in the zlib compression library.
 
 ZLIBOBJS= src/zlib/adler32.o src/zlib/compress.o src/zlib/crc32.o \
@@ -382,7 +292,7 @@
 	fi
 
 clean:
-	rm -f game.* tkscid.so tkscid.dll position.* src/*.o src/universalchardet/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o src/cql/*.o $(EXECS) scql scid $(SCRIPTS)
+	rm -f game.* tkscid.so tkscid.dll position.* src/*.o src/universalchardet/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o $(EXECS) scid $(SCRIPTS)
 	cd engines/phalanx/ && make clean && cd ../../
 	cd engines/toga/src/ && make clean && cd ../../../
 	cd src/tkdnd/ && make clean && cd ../..
@@ -478,21 +388,18 @@
 scidt: src/scidt.o $(OBJS) $(CHARSETCONVOBJS)
 	$(LINK) $(LDFLAGS) -o scidt src/scidt.o $(OBJS) $(CHARSETCONVOBJS) $(ZLIB) $(TCL_LIBRARY)
 
-tkscid: src/tkscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) \
+tkscid: src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) \
         src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o \
         src/probe.o src/optable.o src/engine.o src/recog.o src/tkdnd/TkDND_XDND.o src/tk_selection.o
-	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o \
+	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o \
         src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o \
         src/engine.o src/recog.o src/tkdnd/TkDND_XDND.o src/tk_selection.o $(ZLIB) $(TK_LIBRARY)
 
-tcscid: src/tcscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
+tcscid: src/tcscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
         src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o
-	$(LINK) $(LDFLAGS) -o tcscid src/tcscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o \
+	$(LINK) $(LDFLAGS) -o tcscid src/tcscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o \
         src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TCL_LIBRARY)
 
-scql: $(CQLOBJS_S) $(CHARSETCONVOBJS)
-	$(LINK) $(LDFLAGS) -o scql $(CQLOBJS_S) $(CHARSETCONVOBJS) $(ZLIB) $(TCL_LIBRARY)
-
 # eco2epd is now optional extra program NOT compiled by default, since
 # scid now reads the .eco file format directly.
 
@@ -502,10 +409,10 @@
 ### Rules to create .o files from .cpp files:
 
 src/tcscid.o: src/tkscid.cpp
-	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++11 $(TCL_INCLUDE) -DTCL_ONLY -o src/tcscid.o -c src/tkscid.cpp
+	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++0x $(TCL_INCLUDE) -DTCL_ONLY -o src/tcscid.o -c src/tkscid.cpp
 
 src/tkscid.o: src/tkscid.cpp
-	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++11 $(TCL_INCLUDE) -o src/tkscid.o -c src/tkscid.cpp
+	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++0x $(TCL_INCLUDE) -o src/tkscid.o -c src/tkscid.cpp
 
 ### The endgame tablebase code in the egtb/ subdirectory (not written by me)
 
@@ -517,13 +424,6 @@
 %.o: %.cpp
 	$(BASH_ENV) $(CXX) $(CXXFLAGS) $(TCL_INCLUDE) -o $@ -c $<
 
-src/cql/s_%.o: src/cql/%.cpp
-	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++11 -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DSTANDALONE $(CQL_INCLUDE) $(TCL_INCLUDE) -o $@ -c $<
-
-src/cql/i_%.o: src/cql/%.cpp
-	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++11 -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DINTEGRATED $(CQL_INCLUDE) $(TCL_INCLUDE) -o $@ -c $<
-
-
 ### Rule for compiling zlib source files:
 
 src/zlib/%.o: src/zlib/%.c
Index: Makefile.conf.darwin
===================================================================
--- Makefile.conf.darwin	(revision 2842)
+++ Makefile.conf.darwin	(working copy)
@@ -40,8 +40,6 @@
 TCL_LIBRARY = @TCL_LIBRARY@
 TK_LIBRARY  = @TK_LIBRARY@
 
-CQL_INCLUDE = -Isrc/cql -Isrc
-
 ### Nalimov tablebases
 # TB =                   for no tablebase support
 # TB = -DSCID_USE_TB     for tablebase support
@@ -126,93 +124,6 @@
       src/universalchardet/nsSJISProber.o src/universalchardet/nsUniversalDetector.o \
       src/universalchardet/nsUTF8Prober.o
 
-# Integrated CQL objects.
-CQLOBJS_I=  \
-  src/cql/i_countsquaresnode.o src/cql/i_cqlassert.o \
-  src/cql/i_cqlexit.o src/cql/i_cqlglobals.o src/cql/i_linearize.o \
-  src/cql/i_deleteable.o src/cql/i_repeatconstituent.o src/cql/i_sequencenest.o \
-  src/cql/i_assignnode.o src/cql/i_attacknode.o src/cql/i_beginvariationnode.o \
-  src/cql/i_betweennode.o src/cql/i_chesstypes.o src/cql/i_clone.o \
-  src/cql/i_colortransform.o src/cql/i_commentbase.o src/cql/i_composetransform.o \
-  src/cql/i_cqlinitialize.o \
-  src/cql/i_cqlnodematch.o src/cql/i_cqlnode.o \
-  src/cql/i_dihedraltransform.o src/cql/i_directionmatch.o src/cql/i_direction.o \
-  src/cql/i_directionparameter.o src/cql/i_echodistancespec.o src/cql/i_echolcaspec.o \
-  src/cql/i_echolongestsubstringspec.o src/cql/i_echomatchinfo.o src/cql/i_echonode.o \
-  src/cql/i_echoparse.o src/cql/i_echosidetomovespec.o src/cql/i_echospec.o \
-  src/cql/i_echosquarespec.o src/cql/i_echosquarespec-transform.o src/cql/i_echotransformspec.o \
-  src/cql/i_elonode.o src/cql/i_eventnode.o src/cql/i_existsnode.o \
-  src/cql/i_extensionnode.o src/cql/i_filename.o src/cql/i_forallnode.o \
-  src/cql/i_futurenode.o src/cql/i_futurestarnode.o src/cql/i_gamesortinfo.o \
-  src/cql/i_holderconstituent.o src/cql/i_keywords.o src/cql/i_lexer.o \
-  src/cql/i_longestcommonsubstring.o src/cql/i_markboardmap.o src/cql/i_markboard.o \
-  src/cql/i_markboardstatic.o src/cql/i_matchcommentnode.o src/cql/i_matchcountnode.o \
-  src/cql/i_match.o src/cql/i_movebase.o src/cql/i_movenumbernode.o \
-  src/cql/i_nodematch.o src/cql/i_node.o src/cql/i_nodetransform.o \
-  src/cql/i_notnode.o src/cql/i_numericvariable.o src/cql/i_onnode.o \
-  src/cql/i_optionalconstituent.o src/cql/i_origChanges.o src/cql/i_originnode.o \
-  src/cql/i_ornode.o src/cql/i_parser.o \
-  src/cql/i_pastnode.o src/cql/i_paststarnode.o src/cql/i_pieceidnode.o \
-  src/cql/i_piecelocmatch.o src/cql/i_pieceloc.o src/cql/i_piecelocparse.o \
-  src/cql/i_piover4transform.o src/cql/i_playernode.o src/cql/i_plusconstituent.o \
-  src/cql/i_positionnode.o src/cql/i_powerdifferencenode.o src/cql/i_powernode.o \
-  src/cql/i_raynode.o src/cql/i_seqconstituent.o src/cql/i_seqret.o \
-  src/cql/i_sequencebase.o src/cql/i_sequencematch.o src/cql/i_setbase.o \
-  src/cql/i_shifttransform.o src/cql/i_sitenode.o src/cql/i_sortvalue.o \
-  src/cql/i_squaremask.o src/cql/i_squarevariable.o src/cql/i_starconstituent.o \
-  src/cql/i_tagvariable.o src/cql/i_token.o src/cql/i_tokenstream.o \
-  src/cql/i_transform_members.o src/cql/i_transformnode.o \
-  src/cql/i_transform.o src/cql/i_transform-parse.o \
-  src/cql/i_util.o src/cql/i_variable.o src/cql/i_variations.o \
-  src/cql/i_vectorconstituent.o src/cql/i_vectornode.o src/cql/i_version.o \
-  src/cql/i_yearnode.o
-
-# Standalone CQL objects.
-CQLOBJS_S= src/cql/s_cql.o \
-  src/cql/s_countsquaresnode.o src/cql/s_cqlassert.o \
-  src/cql/s_cqlexit.o src/cql/s_cqlglobals.o src/cql/s_linearize.o \
-  src/cql/s_deleteable.o src/cql/s_repeatconstituent.o src/cql/s_sequencenest.o \
-  src/cql/s_assignnode.o src/cql/s_attacknode.o src/cql/s_beginvariationnode.o \
-  src/cql/s_betweennode.o src/cql/s_chesstypes.o src/cql/s_clone.o \
-  src/cql/s_colortransform.o src/cql/s_commentbase.o src/cql/s_composetransform.o \
-  src/cql/s_cqlinitialize.o \
-  src/cql/s_cqlnodematch.o src/cql/s_cqlnode.o \
-  src/cql/s_dihedraltransform.o src/cql/s_directionmatch.o src/cql/s_direction.o \
-  src/cql/s_directionparameter.o src/cql/s_echodistancespec.o src/cql/s_echolcaspec.o \
-  src/cql/s_echolongestsubstringspec.o src/cql/s_echomatchinfo.o src/cql/s_echonode.o \
-  src/cql/s_echoparse.o src/cql/s_echosidetomovespec.o src/cql/s_echospec.o \
-  src/cql/s_echosquarespec.o src/cql/s_echosquarespec-transform.o src/cql/s_echotransformspec.o \
-  src/cql/s_elonode.o src/cql/s_eventnode.o src/cql/s_existsnode.o \
-  src/cql/s_extensionnode.o src/cql/s_filename.o src/cql/s_forallnode.o \
-  src/cql/s_futurenode.o src/cql/s_futurestarnode.o src/cql/s_gamesortinfo.o \
-  src/cql/s_holderconstituent.o src/cql/s_keywords.o src/cql/s_lexer.o \
-  src/cql/s_longestcommonsubstring.o src/cql/s_markboardmap.o src/cql/s_markboard.o \
-  src/cql/s_markboardstatic.o src/cql/s_matchcommentnode.o src/cql/s_matchcountnode.o \
-  src/cql/s_match.o src/cql/s_movebase.o src/cql/s_movenumbernode.o \
-  src/cql/s_nodematch.o src/cql/s_node.o src/cql/s_nodetransform.o \
-  src/cql/s_notnode.o src/cql/s_numericvariable.o src/cql/s_onnode.o \
-  src/cql/s_optionalconstituent.o src/cql/s_origChanges.o src/cql/s_originnode.o \
-  src/cql/s_ornode.o src/cql/s_parser.o \
-  src/cql/s_pastnode.o src/cql/s_paststarnode.o src/cql/s_pieceidnode.o \
-  src/cql/s_piecelocmatch.o src/cql/s_pieceloc.o src/cql/s_piecelocparse.o \
-  src/cql/s_piover4transform.o src/cql/s_playernode.o src/cql/s_plusconstituent.o \
-  src/cql/s_positionnode.o src/cql/s_powerdifferencenode.o src/cql/s_powernode.o \
-  src/cql/s_raynode.o src/cql/s_seqconstituent.o src/cql/s_seqret.o \
-  src/cql/s_sequencebase.o src/cql/s_sequencematch.o src/cql/s_setbase.o \
-  src/cql/s_shifttransform.o src/cql/s_sitenode.o src/cql/s_sortvalue.o \
-  src/cql/s_squaremask.o src/cql/s_squarevariable.o src/cql/s_starconstituent.o \
-  src/cql/s_tagvariable.o src/cql/s_token.o src/cql/s_tokenstream.o \
-  src/cql/s_transform_members.o src/cql/s_transformnode.o \
-  src/cql/s_transform.o src/cql/s_transform-parse.o \
-  src/cql/s_util.o src/cql/s_variable.o src/cql/s_variations.o \
-  src/cql/s_vectorconstituent.o src/cql/s_vectornode.o src/cql/s_version.o \
-  src/cql/s_yearnode.o \
-  src/bytebuf.o src/crosstab.o src/date.o src/dstring.o \
-  src/filter.o src/game.o src/gfile.o src/index.o src/matsig.o \
-  src/mfile.o src/misc.o src/movelist.o src/myassert.o src/namebase.o \
-  src/optable.o src/pgnparse.o src/pbook.o src/position.o src/probe.o \
-  src/spellchk.o src/stored.o src/stralloc.o src/textbuf.o src/tree.o
-
 ### ZLIBOBJS: object files in the zlib compression library.
 
 ZLIBOBJS= src/zlib/adler32.o src/zlib/compress.o src/zlib/crc32.o \
@@ -341,7 +252,7 @@
 	# They all exist in the one directory, and don't want to trash it by accident
 
 clean:
-	rm -f game.* tkscid.so position.* src/*.o src/universalchardet/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o src/cql/*.o $(EXECS) scid $(SCRIPTS)
+	rm -f game.* tkscid.so position.* src/*.o src/universalchardet/*.o src/zlib/*.o src/zlib/*.a src/polyglot/*.o $(EXECS) scid $(SCRIPTS)
 	cd engines/phalanx/ && make clean && cd ../../
 	cd engines/toga/src/ && make clean && cd ../../../
 
@@ -506,17 +417,14 @@
 scidt: src/scidt.o $(OBJS) $(CHARSETCONVOBJS)
 	$(LINK) $(LDFLAGS) -o scidt src/scidt.o $(OBJS) $(CHARSETCONVOBJS) $(ZLIB) $(TCL_LIBRARY)
 
-tkscid: src/tkscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
+tkscid: src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
           src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o
-	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TK_LIBRARY)
+	$(LINK) $(LDFLAGS) -o tkscid src/tkscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TK_LIBRARY)
 
-tcscid: src/tcscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
-          src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o
-	$(LINK) $(LDFLAGS) -o tcscid src/tcscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TCL_LIBRARY)
+tcscid: src/tcscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o \
+	src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o
+	$(LINK) $(LDFLAGS) -o tcscid src/tcscid.o $(OBJS) $(CHARSETCONVOBJS) src/tree.o src/filter.o src/pbook.o src/crosstab.o src/spellchk.o src/probe.o src/optable.o src/engine.o src/recog.o $(ZLIB) $(TCL_LIBRARY)
 
-scql: $(CQLOBJS_S) $(CHARSETCONVOBJS)
-	$(LINK) $(LDFLAGS) -o scql $(CQLOBJS_S) $(CHARSETCONVOBJS) $(ZLIB) $(TCL_LIBRARY)
-
 # eco2epd is now optional extra program NOT compiled by default, since
 # scid now reads the .eco file format directly.
 eco2epd: src/eco2epd.o $(OBJS) src/pbook.o $(CHARSETCONVOBJS)
@@ -540,13 +448,6 @@
 %.o: %.cpp
 	$(BASH_ENV) $(CXX) $(CXXFLAGS) $(TCL_INCLUDE) -o $@ -c $<
 
-src/cql/s_%.o: src/cql/%.cpp
-	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++11 -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DSTANDALONE $(CQL_INCLUDE) $(TCL_INCLUDE) -o $@ -c $<
-
-src/cql/i_%.o: src/cql/%.cpp
-	$(BASH_ENV) $(CXX) $(CXXFLAGS) -std=c++11 -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DINTEGRATED $(CQL_INCLUDE) $(TCL_INCLUDE) -o $@ -c $<
-
-
 ### Rule for compiling zlib source files:
 
 src/zlib/%.o: src/zlib/%.c
Index: Makefile.mingw
===================================================================
--- Makefile.mingw	(revision 2842)
+++ Makefile.mingw	(working copy)
@@ -54,7 +54,6 @@
 RCFLAGS+= --target=pe-i386
 endif
 
-CQL_INCLUDE = -Isrc\cql -Isrc -I$(TCL_DIR)\include
 
 ### EXECS: all the evecutable programs compiled from C++ files.
 EXECS= pgnscid.exe scidt.exe scid.exe tcscid.exe scmerge.exe eco2epd.exe scidlet.exe
@@ -102,94 +101,6 @@
       src\universalchardet\nsSJISProber.o src\universalchardet\nsUniversalDetector.o \
       src\universalchardet\nsUTF8Prober.o
 
-# Integrated CQL objects.
-CQLOBJS_I=  \
-	src\cql\i_countsquaresnode.o src\cql\i_cqlassert.o \
-	src\cql\i_cqlexit.o src\cql\i_cqlglobals.o src\cql\i_linearize.o \
-	src\cql\i_deleteable.o src\cql\i_repeatconstituent.o src\cql\i_sequencenest.o \
-	src\cql\i_assignnode.o src\cql\i_attacknode.o src\cql\i_beginvariationnode.o \
-	src\cql\i_betweennode.o src\cql\i_chesstypes.o src\cql\i_clone.o \
-	src\cql\i_colortransform.o src\cql\i_commentbase.o src\cql\i_composetransform.o \
-	src\cql\i_cqlinitialize.o \
-	src\cql\i_cqlnodematch.o src\cql\i_cqlnode.o \
-	src\cql\i_dihedraltransform.o src\cql\i_directionmatch.o src\cql\i_direction.o \
-	src\cql\i_directionparameter.o src\cql\i_echodistancespec.o src\cql\i_echolcaspec.o \
-	src\cql\i_echolongestsubstringspec.o src\cql\i_echomatchinfo.o src\cql\i_echonode.o \
-	src\cql\i_echoparse.o src\cql\i_echosidetomovespec.o src\cql\i_echospec.o \
-	src\cql\i_echosquarespec.o src\cql\i_echosquarespec-transform.o src\cql\i_echotransformspec.o \
-	src\cql\i_elonode.o src\cql\i_eventnode.o src\cql\i_existsnode.o \
-	src\cql\i_extensionnode.o src\cql\i_filename.o src\cql\i_forallnode.o \
-	src\cql\i_futurenode.o src\cql\i_futurestarnode.o src\cql\i_gamesortinfo.o \
-	src\cql\i_holderconstituent.o src\cql\i_keywords.o src\cql\i_lexer.o \
-	src\cql\i_longestcommonsubstring.o src\cql\i_markboardmap.o src\cql\i_markboard.o \
-	src\cql\i_markboardstatic.o src\cql\i_matchcommentnode.o src\cql\i_matchcountnode.o \
-	src\cql\i_match.o src\cql\i_movebase.o src\cql\i_movenumbernode.o \
-	src\cql\i_nodematch.o src\cql\i_node.o src\cql\i_nodetransform.o \
-	src\cql\i_notnode.o src\cql\i_numericvariable.o src\cql\i_onnode.o \
-	src\cql\i_optionalconstituent.o src\cql\i_origChanges.o src\cql\i_originnode.o \
-	src\cql\i_ornode.o src\cql\i_parser.o \
-	src\cql\i_pastnode.o src\cql\i_paststarnode.o src\cql\i_pieceidnode.o \
-	src\cql\i_piecelocmatch.o src\cql\i_pieceloc.o src\cql\i_piecelocparse.o \
-	src\cql\i_piover4transform.o src\cql\i_playernode.o src\cql\i_plusconstituent.o \
-	src\cql\i_positionnode.o src\cql\i_powerdifferencenode.o src\cql\i_powernode.o \
-	src\cql\i_raynode.o src\cql\i_seqconstituent.o src\cql\i_seqret.o \
-	src\cql\i_sequencebase.o src\cql\i_sequencematch.o src\cql\i_setbase.o \
-	src\cql\i_shifttransform.o src\cql\i_sitenode.o src\cql\i_sortvalue.o \
-	src\cql\i_squaremask.o src\cql\i_squarevariable.o src\cql\i_starconstituent.o \
-	src\cql\i_tagvariable.o src\cql\i_token.o src\cql\i_tokenstream.o \
-	src\cql\i_transform_members.o src\cql\i_transformnode.o \
-	src\cql\i_transform.o src\cql\i_transform-parse.o \
-	src\cql\i_util.o src\cql\i_variable.o src\cql\i_variations.o \
-	src\cql\i_vectorconstituent.o src\cql\i_vectornode.o src\cql\i_version.o \
-	src\cql\i_yearnode.o
-
-# Standalone CQL objects.
-CQLOBJS_S= src\cql\s_cql.o \
-	src\cql\s_countsquaresnode.o src\cql\s_cqlassert.o \
-	src\cql\s_cqlexit.o src\cql\s_cqlglobals.o src\cql\s_linearize.o \
-	src\cql\s_deleteable.o src\cql\s_repeatconstituent.o src\cql\s_sequencenest.o \
-	src\cql\s_assignnode.o src\cql\s_attacknode.o src\cql\s_beginvariationnode.o \
-	src\cql\s_betweennode.o src\cql\s_chesstypes.o src\cql\s_clone.o \
-	src\cql\s_colortransform.o src\cql\s_commentbase.o src\cql\s_composetransform.o \
-	src\cql\s_cqlinitialize.o \
-	src\cql\s_cqlnodematch.o src\cql\s_cqlnode.o \
-	src\cql\s_dihedraltransform.o src\cql\s_directionmatch.o src\cql\s_direction.o \
-	src\cql\s_directionparameter.o src\cql\s_echodistancespec.o src\cql\s_echolcaspec.o \
-	src\cql\s_echolongestsubstringspec.o src\cql\s_echomatchinfo.o src\cql\s_echonode.o \
-	src\cql\s_echoparse.o src\cql\s_echosidetomovespec.o src\cql\s_echospec.o \
-	src\cql\s_echosquarespec.o src\cql\s_echosquarespec-transform.o src\cql\s_echotransformspec.o \
-	src\cql\s_elonode.o src\cql\s_eventnode.o src\cql\s_existsnode.o \
-	src\cql\s_extensionnode.o src\cql\s_filename.o src\cql\s_forallnode.o \
-	src\cql\s_futurenode.o src\cql\s_futurestarnode.o src\cql\s_gamesortinfo.o \
-	src\cql\s_holderconstituent.o src\cql\s_keywords.o src\cql\s_lexer.o \
-	src\cql\s_longestcommonsubstring.o src\cql\s_markboardmap.o src\cql\s_markboard.o \
-	src\cql\s_markboardstatic.o src\cql\s_matchcommentnode.o src\cql\s_matchcountnode.o \
-	src\cql\s_match.o src\cql\s_movebase.o src\cql\s_movenumbernode.o \
-	src\cql\s_nodematch.o src\cql\s_node.o src\cql\s_nodetransform.o \
-	src\cql\s_notnode.o src\cql\s_numericvariable.o src\cql\s_onnode.o \
-	src\cql\s_optionalconstituent.o src\cql\s_origChanges.o src\cql\s_originnode.o \
-	src\cql\s_ornode.o src\cql\s_parser.o \
-	src\cql\s_pastnode.o src\cql\s_paststarnode.o src\cql\s_pieceidnode.o \
-	src\cql\s_piecelocmatch.o src\cql\s_pieceloc.o src\cql\s_piecelocparse.o \
-	src\cql\s_piover4transform.o src\cql\s_playernode.o src\cql\s_plusconstituent.o \
-	src\cql\s_positionnode.o src\cql\s_powerdifferencenode.o src\cql\s_powernode.o \
-	src\cql\s_raynode.o src\cql\s_seqconstituent.o src\cql\s_seqret.o \
-	src\cql\s_sequencebase.o src\cql\s_sequencematch.o src\cql\s_setbase.o \
-	src\cql\s_shifttransform.o src\cql\s_sitenode.o src\cql\s_sortvalue.o \
-	src\cql\s_squaremask.o src\cql\s_squarevariable.o src\cql\s_starconstituent.o \
-	src\cql\s_tagvariable.o src\cql\s_token.o src\cql\s_tokenstream.o \
-	src\cql\s_transform_members.o src\cql\s_transformnode.o \
-	src\cql\s_transform.o src\cql\s_transform-parse.o \
-	src\cql\s_util.o src\cql\s_variable.o src\cql\s_variations.o \
-	src\cql\s_vectorconstituent.o src\cql\s_vectornode.o src\cql\s_version.o \
-	src\cql\s_yearnode.o \
-	src\bytebuf.o src\crosstab.o src\date.o src\dstring.o \
-	src\filter.o src\game.o src\gfile.o src\index.o src\matsig.o \
-	src\mfile.o src\misc.o src\movelist.o src\myassert.o src\namebase.o \
-	src\optable.o src\pgnparse.o src\pbook.o src\position.o src\probe.o \
-	src\spellchk.o src\stored.o src\stralloc.o src\textbuf.o src\tree.o
-
-
 ### ZLIBOBJS: object files in the zlib compression library.
 
 ZLIBOBJS= src\zlib\adler32.o src\zlib\compress.o src\zlib\crc32.o \
@@ -260,17 +171,14 @@
 	$(LINK) $(LDFLAGS) -o scidlet.exe src\scidlet.o src\engine.o src\recog.o \
           src\misc.o src\position.o src\movelist.o src\dstring.o src\myassert.o
 
-scid.exe: src\scid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res
-	$(LINK) $(LDFLAGS) -o scid.exe src\scid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res \
+scid.exe: src\scid.o $(OBJS) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res
+	$(LINK) $(LDFLAGS) -o scid.exe src\scid.o $(OBJS) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res \
 	    -mwindows -lole32 -luuid -L$(TCL_DIR)\lib -ltk$(TCL_VERSION) -ltcl$(TCL_VERSION)
 
-tcscid.exe: src\tcscid.o $(OBJS) $(CQLOBJS_I) $(SCID_XOBJS) $(CHARSETCONVOBJS)
-	$(LINK) $(LDFLAGS) -o tcscid.exe src\tcscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) $(SCID_XOBJS) \
+tcscid.exe: src\tcscid.o $(OBJS) $(SCID_XOBJS) $(CHARSETCONVOBJS)
+	$(LINK) $(LDFLAGS) -o tcscid.exe src\tcscid.o $(OBJS) $(CHARSETCONVOBJS) $(SCID_XOBJS) \
 	    -ltcl$(TCL_VERSION) -L$(TCL_DIR)\lib -ltcl$(TCL_VERSION)
 
-scql.exe: $(CQLOBJS_S) $(CHARSETCONVOBJS) $(ZLIBOBJS)
-	$(LINK) $(LDFLAGS) -o scql.exe $(CQLOBJS_S) $(CHARSETCONVOBJS) $(ZLIBOBJS) -L$(TCL_DIR)\lib -ltcl$(TCL_VERSION)
-
 eco2epd.exe: src\eco2epd.o src\pbook.o $(OBJS) $(CHARSETCONVOBJS)
 	$(LINK) $(LDFLAGS) -o eco2epd.exe src\eco2epd.o src\pbook.o $(OBJS) $(CHARSETCONVOBJS) -L$(TCL_DIR)\lib -ltcl$(TCL_VERSION)
 
@@ -278,7 +186,7 @@
 	$(RC) $(RCFLAGS) -o scid.res scid.rc
 
 clean:
-	-@del /q src\*.o src\zlib\*.o src\polyglot\*.o src\universalchardet\*.o src\cql\*.o $(EXECS) scid.gui scid.res
+	-@del /q src\*.o src\zlib\*.o src\polyglot\*.o src\universalchardet\*.o $(EXECS) scid.gui scid.res
 
 strip:
 	$(STRIP) $(EXECS)
@@ -285,15 +193,15 @@
 
 
 src\tcscid.o: src\tkscid.cpp
-	$(CXX) $(CXXFLAGS) -std=c++11 -I$(TCL_DIR)\include -DTCL_ONLY -c src\tkscid.cpp \
+	$(CXX) $(CXXFLAGS) -std=c++0x -I$(TCL_DIR)\include -DTCL_ONLY -c src\tkscid.cpp \
 	  -o src\tcscid.o
 
 src\tkscid.o: src\tkscid.cpp
-	$(CXX) $(CXXFLAGS) -std=c++11 -I$(TCL_DIR)\include -c src\tkscid.cpp \
+	$(CXX) $(CXXFLAGS) -std=c++0x -I$(TCL_DIR)\include -c src\tkscid.cpp \
 	  -o src\tkscid.o
 
 src\scid.o: src\tkscid.cpp
-	$(CXX) $(CXXFLAGS) -std=c++11 -I$(TCL_DIR)\include -DSOURCE_TCL_FILE="\"scid.gui\"" \
+	$(CXX) $(CXXFLAGS) -std=c++0x -I$(TCL_DIR)\include -DSOURCE_TCL_FILE="\"scid.gui\"" \
 	  -c src\tkscid.cpp -o src\scid.o
 
 src\probe.o: src\probe.cpp src\egtb\tbindex.cpp src\egtb\tbdecode.c
@@ -307,9 +215,3 @@
 
 src\TkDND_OleDND.o: src\tkdnd\win\TkDND_OleDND.cpp
 	$(CXX) $(CXXFLAGS) -I$(TCL_DIR)\include -Isrc\tkdnd\win -c $< -o $@
-
-src\cql\s_%.o: src\cql\%.cpp
-	$(CXX) $(CXXFLAGS) -std=c++11 -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DSTANDALONE $(CQL_INCLUDE) -o $@ -c $<
-
-src\cql\i_%.o: src\cql\%.cpp
-	$(CXX) $(CXXFLAGS) -std=c++11 -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DINTEGRATED $(CQL_INCLUDE) -o $@ -c $<
Index: Makefile.mingwx
===================================================================
--- Makefile.mingwx	(revision 2842)
+++ Makefile.mingwx	(working copy)
@@ -71,8 +71,6 @@
 RCFLAGS+= --target=pe-i386
 endif
 
-CQL_INCLUDE = -Isrc/cql -Isrc -I$(TCL_DIR)/include
-
 ### EXECS: all the evecutable programs compiled from C++ files.
 EXECS= pgnscid.exe scidt.exe scid.exe tcscid.exe scmerge.exe eco2epd.exe scidlet.exe
 
@@ -119,94 +117,6 @@
       src/universalchardet/nsSJISProber.o src/universalchardet/nsUniversalDetector.o \
       src/universalchardet/nsUTF8Prober.o
 
-# Integrated CQL objects.
-CQLOBJS_I=  \
-	src/cql/i_countsquaresnode.o src/cql/i_cqlassert.o \
-	src/cql/i_cqlexit.o src/cql/i_cqlglobals.o src/cql/i_linearize.o \
-	src/cql/i_deleteable.o src/cql/i_repeatconstituent.o src/cql/i_sequencenest.o \
-	src/cql/i_assignnode.o src/cql/i_attacknode.o src/cql/i_beginvariationnode.o \
-	src/cql/i_betweennode.o src/cql/i_chesstypes.o src/cql/i_clone.o \
-	src/cql/i_colortransform.o src/cql/i_commentbase.o src/cql/i_composetransform.o \
-	src/cql/i_cqlinitialize.o \
-	src/cql/i_cqlnodematch.o src/cql/i_cqlnode.o \
-	src/cql/i_dihedraltransform.o src/cql/i_directionmatch.o src/cql/i_direction.o \
-	src/cql/i_directionparameter.o src/cql/i_echodistancespec.o src/cql/i_echolcaspec.o \
-	src/cql/i_echolongestsubstringspec.o src/cql/i_echomatchinfo.o src/cql/i_echonode.o \
-	src/cql/i_echoparse.o src/cql/i_echosidetomovespec.o src/cql/i_echospec.o \
-	src/cql/i_echosquarespec.o src/cql/i_echosquarespec-transform.o src/cql/i_echotransformspec.o \
-	src/cql/i_elonode.o src/cql/i_eventnode.o src/cql/i_existsnode.o \
-	src/cql/i_extensionnode.o src/cql/i_filename.o src/cql/i_forallnode.o \
-	src/cql/i_futurenode.o src/cql/i_futurestarnode.o src/cql/i_gamesortinfo.o \
-	src/cql/i_holderconstituent.o src/cql/i_keywords.o src/cql/i_lexer.o \
-	src/cql/i_longestcommonsubstring.o src/cql/i_markboardmap.o src/cql/i_markboard.o \
-	src/cql/i_markboardstatic.o src/cql/i_matchcommentnode.o src/cql/i_matchcountnode.o \
-	src/cql/i_match.o src/cql/i_movebase.o src/cql/i_movenumbernode.o \
-	src/cql/i_nodematch.o src/cql/i_node.o src/cql/i_nodetransform.o \
-	src/cql/i_notnode.o src/cql/i_numericvariable.o src/cql/i_onnode.o \
-	src/cql/i_optionalconstituent.o src/cql/i_origChanges.o src/cql/i_originnode.o \
-	src/cql/i_ornode.o src/cql/i_parser.o \
-	src/cql/i_pastnode.o src/cql/i_paststarnode.o src/cql/i_pieceidnode.o \
-	src/cql/i_piecelocmatch.o src/cql/i_pieceloc.o src/cql/i_piecelocparse.o \
-	src/cql/i_piover4transform.o src/cql/i_playernode.o src/cql/i_plusconstituent.o \
-	src/cql/i_positionnode.o src/cql/i_powerdifferencenode.o src/cql/i_powernode.o \
-	src/cql/i_raynode.o src/cql/i_seqconstituent.o src/cql/i_seqret.o \
-	src/cql/i_sequencebase.o src/cql/i_sequencematch.o src/cql/i_setbase.o \
-	src/cql/i_shifttransform.o src/cql/i_sitenode.o src/cql/i_sortvalue.o \
-	src/cql/i_squaremask.o src/cql/i_squarevariable.o src/cql/i_starconstituent.o \
-	src/cql/i_tagvariable.o src/cql/i_token.o src/cql/i_tokenstream.o \
-	src/cql/i_transform_members.o src/cql/i_transformnode.o \
-	src/cql/i_transform.o src/cql/i_transform-parse.o \
-	src/cql/i_util.o src/cql/i_variable.o src/cql/i_variations.o \
-	src/cql/i_vectorconstituent.o src/cql/i_vectornode.o src/cql/i_version.o \
-	src/cql/i_yearnode.o
-
-# Standalone CQL objects.
-CQLOBJS_S= src/cql/s_cql.o \
-	src/cql/s_countsquaresnode.o src/cql/s_cqlassert.o \
-	src/cql/s_cqlexit.o src/cql/s_cqlglobals.o src/cql/s_linearize.o \
-	src/cql/s_deleteable.o src/cql/s_repeatconstituent.o src/cql/s_sequencenest.o \
-	src/cql/s_assignnode.o src/cql/s_attacknode.o src/cql/s_beginvariationnode.o \
-	src/cql/s_betweennode.o src/cql/s_chesstypes.o src/cql/s_clone.o \
-	src/cql/s_colortransform.o src/cql/s_commentbase.o src/cql/s_composetransform.o \
-	src/cql/s_cqlinitialize.o \
-	src/cql/s_cqlnodematch.o src/cql/s_cqlnode.o \
-	src/cql/s_dihedraltransform.o src/cql/s_directionmatch.o src/cql/s_direction.o \
-	src/cql/s_directionparameter.o src/cql/s_echodistancespec.o src/cql/s_echolcaspec.o \
-	src/cql/s_echolongestsubstringspec.o src/cql/s_echomatchinfo.o src/cql/s_echonode.o \
-	src/cql/s_echoparse.o src/cql/s_echosidetomovespec.o src/cql/s_echospec.o \
-	src/cql/s_echosquarespec.o src/cql/s_echosquarespec-transform.o src/cql/s_echotransformspec.o \
-	src/cql/s_elonode.o src/cql/s_eventnode.o src/cql/s_existsnode.o \
-	src/cql/s_extensionnode.o src/cql/s_filename.o src/cql/s_forallnode.o \
-	src/cql/s_futurenode.o src/cql/s_futurestarnode.o src/cql/s_gamesortinfo.o \
-	src/cql/s_holderconstituent.o src/cql/s_keywords.o src/cql/s_lexer.o \
-	src/cql/s_longestcommonsubstring.o src/cql/s_markboardmap.o src/cql/s_markboard.o \
-	src/cql/s_markboardstatic.o src/cql/s_matchcommentnode.o src/cql/s_matchcountnode.o \
-	src/cql/s_match.o src/cql/s_movebase.o src/cql/s_movenumbernode.o \
-	src/cql/s_nodematch.o src/cql/s_node.o src/cql/s_nodetransform.o \
-	src/cql/s_notnode.o src/cql/s_numericvariable.o src/cql/s_onnode.o \
-	src/cql/s_optionalconstituent.o src/cql/s_origChanges.o src/cql/s_originnode.o \
-	src/cql/s_ornode.o src/cql/s_parser.o \
-	src/cql/s_pastnode.o src/cql/s_paststarnode.o src/cql/s_pieceidnode.o \
-	src/cql/s_piecelocmatch.o src/cql/s_pieceloc.o src/cql/s_piecelocparse.o \
-	src/cql/s_piover4transform.o src/cql/s_playernode.o src/cql/s_plusconstituent.o \
-	src/cql/s_positionnode.o src/cql/s_powerdifferencenode.o src/cql/s_powernode.o \
-	src/cql/s_raynode.o src/cql/s_seqconstituent.o src/cql/s_seqret.o \
-	src/cql/s_sequencebase.o src/cql/s_sequencematch.o src/cql/s_setbase.o \
-	src/cql/s_shifttransform.o src/cql/s_sitenode.o src/cql/s_sortvalue.o \
-	src/cql/s_squaremask.o src/cql/s_squarevariable.o src/cql/s_starconstituent.o \
-	src/cql/s_tagvariable.o src/cql/s_token.o src/cql/s_tokenstream.o \
-	src/cql/s_transform_members.o src/cql/s_transformnode.o \
-	src/cql/s_transform.o src/cql/s_transform-parse.o \
-	src/cql/s_util.o src/cql/s_variable.o src/cql/s_variations.o \
-	src/cql/s_vectorconstituent.o src/cql/s_vectornode.o src/cql/s_version.o \
-	src/cql/s_yearnode.o \
-	src/bytebuf.o src/crosstab.o src/date.o src/dstring.o \
-	src/filter.o src/game.o src/gfile.o src/index.o src/matsig.o \
-	src/mfile.o src/misc.o src/movelist.o src/myassert.o src/namebase.o \
-	src/optable.o src/pgnparse.o src/pbook.o src/position.o src/probe.o \
-	src/spellchk.o src/stored.o src/stralloc.o src/textbuf.o src/tree.o
-
-
 ### ZLIBOBJS: object files in the zlib compression library.
 
 ZLIBOBJS= src/zlib/adler32.o src/zlib/compress.o src/zlib/crc32.o \
@@ -278,17 +188,14 @@
 	$(LINK) $(LDFLAGS) -o scidlet.exe src/scidlet.o src/engine.o src/recog.o \
           src/misc.o src/position.o src/movelist.o src/dstring.o src/myassert.o
 
-scid.exe: src/scid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res
-	$(LINK) $(LDFLAGS) -o scid.exe src/scid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res \
+scid.exe: src/scid.o $(OBJS) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res
+	$(LINK) $(LDFLAGS) -o scid.exe src/scid.o $(OBJS) $(CHARSETCONVOBJS) $(SCID_XOBJS) $(SCID_TK_OBJS) scid.res \
 	    -mwindows -lole32 -luuid -L$(TCL_DIR)/lib -ltk$(TCL_VERSION) -ltcl$(TCL_VERSION)
 
-tcscid.exe: src/tcscid.o $(OBJS) $(CQLOBJS_I) $(SCID_XOBJS) $(CHARSETCONVOBJS)
-	$(LINK) $(LDFLAGS) -o tcscid.exe src/tcscid.o $(OBJS) $(CQLOBJS_I) $(CHARSETCONVOBJS) $(SCID_XOBJS) \
+tcscid.exe: src/tcscid.o $(OBJS) $(SCID_XOBJS) $(CHARSETCONVOBJS)
+	$(LINK) $(LDFLAGS) -o tcscid.exe src/tcscid.o $(OBJS) $(CHARSETCONVOBJS) $(SCID_XOBJS) \
 	    -ltcl$(TCL_VERSION) -L$(TCL_DIR)/lib -ltcl$(TCL_VERSION)
 
-scql.exe: $(CQLOBJS_S) $(CHARSETCONVOBJS) $(ZLIBOBJS)
-	$(LINK) $(LDFLAGS) -o scql.exe $(CQLOBJS_S) $(CHARSETCONVOBJS) $(ZLIBOBJS) -L$(TCL_DIR)/lib -ltcl$(TCL_VERSION)
-
 eco2epd.exe: src/eco2epd.o src/pbook.o $(OBJS) $(CHARSETCONVOBJS)
 	$(LINK) $(LDFLAGS) -o eco2epd.exe src/eco2epd.o src/pbook.o $(OBJS) $(CHARSETCONVOBJS) -L$(TCL_DIR)/lib -ltcl$(TCL_VERSION)
 
@@ -296,7 +203,7 @@
 	$(RC) $(RCFLAGS) -o scid.res scid.rc
 
 clean:
-	rm -f src/*.o src/zlib/*.o src/polyglot/*.o src/universalchardet/*.o src/cql/*.o $(EXECS) scid.gui scid.res
+	rm -f src/*.o src/zlib/*.o src/polyglot/*.o src/universalchardet/*.o $(EXECS) scid.gui scid.res
 
 strip:
 	$(STRIP) $(EXECS)
@@ -325,9 +232,3 @@
 
 src/TkDND_OleDND.o: src/tkdnd/win/TkDND_OleDND.cpp
 	$(CXX) $(CXXFLAGS) -I$(TCL_DIR)/include -Isrc/tkdnd/win -c $< -o $@
-
-src/cql/s_%.o: src/cql/%.cpp
-	$(CXX) $(CXXFLAGS) -std=c++0x -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DSTANDALONE $(CQL_INCLUDE) -o $@ -c $<
-
-src/cql/i_%.o: src/cql/%.cpp
-	$(CXX) $(CXXFLAGS) -std=c++0x -Wall -Wno-write-strings -Wno-char-subscripts  -Wno-parentheses -Wno-sign-compare -fdiagnostics-show-option -DINTEGRATED $(CQL_INCLUDE) -o $@ -c $<
Index: src/cql/COPYING
===================================================================
--- src/cql/COPYING	(revision 2842)
+++ src/cql/COPYING	(working copy)
@@ -1,19 +1 @@
 
-All source files in this directory are Copyright Lewis Stiller and Gady
-Costeff and except as specified all rights are reserved.  
-
-The source files are distributed under an implicit GNU License.
-
-Quoting Lewis Stiller from an e-mail exchange dated 10/01/2017: "CQL is
-covered under the GPL because it links to Shane Hudson's parser, which
-is GPL. So you're welcome to use CQL in a GPL application. If you want a
-less restrictive license for that parts of CQL not including his parser,
-I'd be happy to grant that too."
-
-Minor modifications were made to a few of the source files in the porting
-process, and may be attributed to Lionel Hampton, who makes no claim of
-Copyright to anything in this directory.
-
-A copy of the GPL may be found in the file COPYING in the root of the
-source tree.
-
Index: src/cql/PORT
===================================================================
--- src/cql/PORT	(revision 2842)
+++ src/cql/PORT	(working copy)
@@ -1,100 +1 @@
-#!/usr/bin/fmt
 
-The port of the CQL source code to the Scidvspc chess database application as a fully integrated search engine was undertaken by Lionel Hampton.  This file outlines the porting process, issues encountered along the way, and guidelines for subsequent porting efforts of future releases of the CQL source distribution.
-
-
-The original standalone CQL executable utilized a subset of a very dated revision of the Scid source tree, primarily for parsing PGN files.  Because that parser naturally filled in Scid-native data structure as the games were parsed, the CQL engine also happily utilizes those same Scid-native data structures.  That convenience, alone, renders the port nearly trivial.
-
-The first task in the port involved transitioning the CQL source base away from that ancient Scid code base to the more current v4.18 revision of the Scidvspc source repository, in order to build a functional standalone cql executable off the same source as would eventually be utilized by the ported integrated CQL engine.  That primarily involved minor tweaks/additions to some Scid header files and the addition of a couple of accessor attributes for data elements which had been moved from private to public space by C&S.  It also required the creation and initialization of an integrated Tcl interpreter due to the fact that the current PGN parser now pulls in the CHARSETCONV objects which in turn require a number of references out of the Tcl library.
-
-The standalone cql executable resulting from the clean build was then tested and verified by comparing the query results from that exec -- against a 100K game PGN DB -- with the respective results produced by the original cql executable, utilizing the many CQL examples authored by Costeff & Stiller (found in the examples sub-directory).
-
-Having a fully functional base built aganst the native headers and objects, the next step was to integrate the CQL engine into the Scid executable.  Since the CQL base already interfaced with the Scid Game:: and Position:: infrastructure, very little bridging work was required.  Rather than searching against the game stream generated by the parser, the search is conducted against the active scid database game list filter.
-
-Following are the non-trivial aspects of the integration effort:
-
--- Convert the CQL lexical analyzer to work off an internal buffer rather that a file.  That work can be found in lexer.cpp.
-
--- Create a new search menu item and search window for feeding the CQL engine the necessary CQL syntax.  The search window rendered and managed by proc ::search::cql{} is modelled after proc ::search::moves{}.
-
--- Create a new Tcl command serving as an interface to the CQL engine, iterating through the game filter and invoking the CQL engine on a per/game basis.  The sc_search_cql() command is modelled after the sc_search_moves() command, and interfaces with the CQL engine through a surrogate function found in parser.cpp, which simply determines whether or not a given game matches the CQL filter-set supplied by the UI.
-
--- Rework the native CQL exception handling scheme, since any exception occuring in processing the games would result in the standalone application simply printing an error message and bailing out.  The ported/integrated engine relays error and diagnostic messages via a couple of global vars and performs a longjump() out of the nest of stack frames.  The use of the C++ std::setjmp()/std::longjmp() duo should be inconsequential since virtually all allocations occur on the heap rather than the stack.
-
--- Replace altered games in the database.  Fortunately, this was a one-liner wrt the CQL code. Significantly more than that in sc_search_cql(). Altered games include those which have had their position match marks stripped in accordance with a user-controlled radio switch.
-
--- Resolve memory leaks:
-  ** The CQL engine was not originally intended to be a long-lived entity.  Objects allocated on the heap were never deleted in the original code.  That has generously been corrected by Stiller and Costeff in their upstream project.
-  ** The CQL code which allocates position marks (as game move comments) does so through Game::SetMoveComment(), which utilizes the StrAlloc infrastructure.  This memory is released by what passes for Game object destruction.
-
-
-Stiller notes on heap cleanup implementation:
-
----Freeing memory---
-To free memory in CQL, there is an abstract base class Deleteable (in
-deleteable.h and deleteable.cpp) which has an no argument constructor and a
-virtual destructor. Deleteable keeps track of all its instances in a
-set<Deleteable*>. The constructor adds "this" to that set. The destructor
-just verifies that "this" is part of the instance pool and that the
-destructor was called during the cleanup phase. The cleanup phase just
-deletes all instances in the instance pool, and the deletes the instance
-pool itself.
-
-To make a CQL class able to be free, make it inherit from Deleteable. See
-e.g. "node.h" where the base class of all the nodes, "class Node", just
-inherits from Deleteable. This makes all subclasses of Node deleteable.
-(Note that CqlNode is the root of the parse tree, but the root of the
-inheritance hierarchy is Node).
-
-Now to delete all instances of the class (and of all other classes that
-inherit from Deleteable), just call Deleteable::deleteable_cleanup();
-
-The main restriction here is that no instance of Deleteable should be
-deleted other than through the Deleteable::deleteable_cleanup() interface.
-In particular, no such instance can be stack allocated.
-
-This limitation means a few classes are not Deleteable, like Transform.
-This should not cause much garbage.
-
-Character strings are not freed. This will cause a memory leak roughly
-equal to the total number of characters in all the CQL files parsed during
-the current invocation. I did not see this as a significant limitation
-because CQL files are typically short, but if a user does decided to run
-Cql on ten million different CQL files in the same process, there might be
-a problem.
-
-To free character string is straightforward. Virtually all character
-strings are allocated in util::copy and this method can just keep track of
-its allocations. Alternatively, and more cleanly, std::string should be
-used rather than char* . I did change GameSortInfo , a value object used to
-sort the output pgn strings corresponding to a game with a key, from using
-char* to std:string . But this does not affect you I believe.
-
-Note that all Deleteable objects are actually created before the matching
-of the CqlNode against the pgn file is begun. They are created by the CQL
-parser/lexer .
-
-The main thing to remember is that cql_initialize() must be called before a
-new CQL file is read.
-
-Structurally, to faciliate this, I removed most of the static local
-variables in methods. I put the globals, including some cache variables
-that used to be static variables, in cqlglobals.h and cqlglobals.cpp .
-
-
-UPGRADES:
-
-Because the common CQL ancestor for the CQL and ScidvsPC projects is not in the ScidvsPC SVN repository, CQL upgrades (merges) are accomplished out-of-tree.  Merges take place in a Git context with Git's “reuse recorded resolution” feature enabled, which "allows you to ask Git to remember how you’ve resolved a hunk conflict so that the next time it sees the same conflict, Git can automatically resolve it for you."  That feature saves a significant amount of work on merges subsequent to the first.
-
-The current build and version can be found in version.cpp.
-
-The common ancestor is:  CqlBuild="8.51" CqlVersion="5.1".
-
-
-TESTING:
-
-The CQL source distribution includes a set of scripts in the examples directory which can be used for testing the correctness of the port.  There is a bash script in the src/cql/scripts directory of the ScidvsPC tree which can be tweaked to assist in side-by-side comparisons of the search results given by the original cql command line executable vs. the ported scql command line executable.  The ported scql can be built from the root Makefile: make scql.
-
-In testing the integrated engine, the only exceptions encountered have been triggered by either mal-formed syntax or by null moves in the game record. Since Stiller and Costeff have recently implemented the handling of null moves in the CQL engine, it has proved difficult to trigger exceptions in the match phase of the search.  We have therefore resorted to forcing a contrived exception in the null move handling section of the engine for testing purposes.  To enable this contrived exception, grep the CQL source for 'NULL MOVE CONTRIVED EXCEPTION', uncomment the forced failed assert and rebuild tkscid.  Then conduct a query on a game with a null move to trigger the exception.
-
-
Index: src/cql/README
===================================================================
--- src/cql/README	(revision 2842)
+++ src/cql/README	(working copy)
@@ -1,37 +1 @@
 
-This directory contains the ported source for the integrated CQL search
-engine, as incorporated into the Scidvspc chess database application.
-In addition to the integrated engine, a ported stand-alone executable
-may be built from the same source.
-
-To make the standalone scql executable, which compiles against native
-headers and links with native objects, from the root of the source tree:
-    make scql
-
-For licensing details see the file COPYING in this directory.
-
-For documentaion of the porting process see the file PORT.
-
-Many thanks go to Stiller and Costeff for their innovative work on CQL.
-It was a landmark development in the world of chess and is a highly
-appreciated feature addition to the Scidvspc.
-
-========================= From the original README:
-
-Version information is in the file version.cpp, or can be found by
-running pcql --help.
-
-This distribution requires a C++ 11 compiler. It has been compiled with
-GNU g++ and with clang, as well as with Microsoft Visual C++.
-
-LICENSE
- All the files in the subdirectory orig/ are by Shane Hudson and were
- distributed under the GNU License version 2.
-
- The file origChanges.cpp consists of minor modifications to those files.
-
- All other files are Copyright Lewis Stiller and Gady Costeff and except
- as specified all rights are reserved.
-
- For documentation, see http://www.gadycosteff.com/cql
-
Index: src/cql/assignnode.cpp
===================================================================
--- src/cql/assignnode.cpp	(revision 2842)
+++ src/cql/assignnode.cpp	(working copy)
@@ -1,34 +1 @@
-#include "node.h"
-AssignNode::AssignNode(NumericVariable * var, Node * filter){
-  variable=var;
-  uassert(var&&filter);
-  node=dynamic_cast<Countable*>(filter);
-  uassert(node,"unexpected non-countable argument to assignnode");
-  uassert(node->isCountable(),"argument to assign node is not an actual countable node");
-}
 
-bool AssignNode::match_position(Game*game){
-  NumValue value{-1000};
-  if(node->match_count(game,&value)){
-    variable->bindNumeric(value);
-    return true;
-  }
-  return false;
-}
-
-void AssignNode::print(){
-  printf("<%s variable: ",thisclass());
-  variable->print();
-  printf("\n");
-  indent();tab();
-  printf("Node: ");
-  node->print();
-  unindent();
-  printf(" %s>",thisclass());
-}
-
-vnode AssignNode::children(){
-  Node* n=dynamic_cast<Node*>(node);
-  uassert(n);
-  return vnode{n};
-}
Index: src/cql/attacknode.cpp
===================================================================
--- src/cql/attacknode.cpp	(revision 2842)
+++ src/cql/attacknode.cpp	(working copy)
@@ -1,138 +1 @@
-#include "node.h"
 
-void AttackNode::addcounts(pieceT piece, pieceT*board, squareT square){
-  switch(piece){
-  case WR: case BR:
-    addslidingcounts(UP,board,square);
-    addslidingcounts(DOWN,board,square);
-    addslidingcounts(LEFT,board,square);
-    addslidingcounts(RIGHT,board,square);
-    return;
-  case WB: case BB:
-    addslidingcounts(UP_LEFT,board,square);
-    addslidingcounts(DOWN_LEFT,board,square);
-    addslidingcounts(UP_RIGHT,board,square);
-    addslidingcounts(DOWN_RIGHT,board,square);
-    return;
-  case WQ: case BQ:
-    addcounts(WR,board,square);
-    addcounts(WB,board,square);
-    return;
-  case WN: case BN:
-    addknightcounts(board,square);
-    return;
-  case WP: case BP:
-    addpawncounts(piece,board,square);
-    return;
-  case WK: case BK:
-    addkingcounts(board,square);
-    return;
-  case EMPTY: return;
-  default: uassert(false,"attacknode bad switch");
-  }
-}
-	     
-void AttackNode::addslidingcounts(directionT direction,pieceT*board,squareT square){
-  int current=square;
-  do {
-    current=util::squareShiftDirection(current,direction);
-    if (current<0)return;
-    squarecounts[current]++;
-    if (board[current]!=EMPTY)return;
-  }
-  while (current>=0&&current<64);
-}
-
-void AttackNode::addknightcounts(pieceT*board, squareT square){
-  int fileoffsets[8]={1,2,2,1,-1,-2,-2,-1};
-  int rankoffsets[8]={2,1,-1,-2,-2,-1,1,2};
-  for (int i=0;i<8;++i) addnonsliding(fileoffsets[i],rankoffsets[i],board,square);
-}
-
-void AttackNode::addpawncounts(pieceT pawn, pieceT*board,squareT square){
-  uassert(pawn==WP||pawn==BP,"addpawncounts internal");
-  int rankoff=pawn==WP?1:-1;
-  addnonsliding(-1,rankoff,board,square);
-  addnonsliding(1,rankoff,board,square);
-}
-
-void AttackNode::addkingcounts(pieceT*board,squareT square){
-  int fileoffsets[8]={0,1,1,1,0,-1,-1,-1};
-  int rankoffsets[8]={1,1,0,-1,-1,-1,0,1};
-  for (int i=0;i<8;++i) addnonsliding(fileoffsets[i],rankoffsets[i],board,square);
-}
-
-void AttackNode::addnonsliding(int fileoff,int rankoff, pieceT*board, squareT square){
-  int file=square_Fyle(square)+fileoff;
-  int rank=square_Rank(square)+rankoff;
-  if (file<0||file>7||rank<0||rank>7) return;
-  squarecounts[square_Make(file,rank)]++;
-}
-
-AttackNode::AttackNode(SetBase*s, SetBase*t, Range*r){
-  uassert(s && t);
-  attacking=s;
-  attacked=t;
-  range=r;
-}
-
-void AttackNode::print(){
-  printf("<%s ",thisclass());
-  attacking->print();
-  printf(" ");
-  attacked->print();
-  if(range) range->print();
-  printf("> ");
-}
-
-vnode AttackNode::children(){
-  return vnode{attacking,attacked};
-}
-
-bool AttackNode::match_count(Game*game,NumValue*value){
-  uassert(isCountable()&&!isSet(), "Attempt to count an attack filter without a range");
-  if(match_position(game)){
-    *value=(NumValue)(count);
-    return true;
-  }
-  return false;
-}
-
-//Below is highly inefficient: it computes all attacks of all pieces in attacking
-//Should be fixed later.
-
-bool AttackNode::match_position(Game *game){ //This also MUST SET THE COUNTS
-  pieceT * board=game->GetCurrentPos()->GetBoard();
-  for (int i=0;i<64;++i) squarecounts[i]=0;
-  SquareMask attackingsquares=attacking->getSquares(game);
-  SquareMask attackedsquares=attacked->getSquares(game);
-  for (int sq=0;sq<64;++sq)
-    if (attackingsquares.member(sq))
-      addcounts(board[sq],board,sq);
-  count=0;
-  for (int sq=0;sq<64;++sq)
-    if (attackedsquares.member(sq))
-      count+=squarecounts[sq];
-  if(!range) return count;
-  else return range->valid(count);
-}
-
-SquareMask AttackNode::getSquares(Game*game){
-  SquareMask mask;
-  uassert(isSet(),"Attack filter has a range, but is used as a square set");
-  if(!match_position(game)) return mask;
-  SquareMask attackedsquares=attacked->getSquares(game); //computed here and in match_position
-  for(int sq=0;sq<64;++sq)
-    if(attackedsquares.member(sq)&&squarecounts[sq])
-      mask.insert(sq);
-  return mask;
-}
-
-bool AttackNode::isSet(){
-  return range==NULL;
-}
-
-bool AttackNode::isCountable(){
-  return range!=NULL;
-}
-
Index: src/cql/beginvariationnode.cpp
===================================================================
--- src/cql/beginvariationnode.cpp	(revision 2842)
+++ src/cql/beginvariationnode.cpp	(working copy)
@@ -1,12 +1 @@
-#include "node.h"
-bool BeginVariationNode::match_position(Game*game){
-  int varlevel=game->GetVarLevel();
-  if(varlevel==0)return false;
-  int parentvarlevel=-1;
-  auto me=MarkBoard::identity(game);
-  uassert(game->GetCurrentPly()!=0,"PVN: internal getcurrentply");
-  MarkBoard::gameBackup(game);
-  parentvarlevel=game->GetVarLevel();
-  MarkBoard::gameToChild(me,game,true);
-  return varlevel>parentvarlevel;
-}
+
Index: src/cql/betweennode.cpp
===================================================================
--- src/cql/betweennode.cpp	(revision 2842)
+++ src/cql/betweennode.cpp	(working copy)
@@ -1,34 +1 @@
-#include "node.h"
 
-BetweenNode::BetweenNode(SetBase*s, SetBase*t){
-  uassert(s&&t);
-  source=s;
-  target=t;
-}
-
-void BetweenNode::print(){
-  printf("<%s ",thisclass());
-  printf("\n");indent();tab();
-  printf("source: ");
-  source->print();
-  unindent();
-  printf("\n");indent();tab();
-  printf("target: ");
-  target->print();
-  printf("> ");
-  unindent();
-}
-
-SquareMask BetweenNode::getSquares(Game*game){
-  SquareMask mask;
-  SquareMask sm=source->getSquares(game);
-  SquareMask tm=target->getSquares(game);
-  for(squareT sourcesquare=0;sourcesquare<64;++sourcesquare)
-    if (sm.member(sourcesquare))
-      for(squareT targetsquare=0;targetsquare<64;++targetsquare)
-	if(tm.member(targetsquare))
-	  mask|=Direction::between(sourcesquare,targetsquare);
-  return mask;
-}
-
-
Index: src/cql/chesstypes.cpp
===================================================================
--- src/cql/chesstypes.cpp	(revision 2842)
+++ src/cql/chesstypes.cpp	(working copy)
@@ -1,144 +1 @@
-#include "chesstypes.h"
-const char * direction_to_string(directionT d){
-  switch(d){
-  case UP: return "U";
-  case DOWN: return "D";
-  case LEFT: return "L";
-  case RIGHT: return "R";
-  case UP_LEFT: return "UL";
-  case DOWN_LEFT: return "DL";
-  case UP_RIGHT: return "UR";
-  case DOWN_RIGHT: return "DR";
-      };
-  uassert(false, "unknown direction");
-  return NULL;
-}
 
-const char* color_string(colorT c){
-  if(c==WHITE)return "White";
-  if(c==BLACK)return "Black";
-  if(c==NOCOLOR)return " ";
-  uassert(false,"bad color color_string");
-  return "illegal";
-}
-
-bool file_valid(int f){
-  return f>=0&&f<8;
-}
-
-bool rank_valid(int r){
-  return file_valid(r);
-}
-
-char file_to_char_cql(int f){
-  uassert(file_valid(f));
-  return (char)(f+'a');
-}
-
-
-char rank_to_char_cql(int r){
-  uassert(rank_valid(r));
-  return (char)(r+'1');
-}
-
-bool piece_valid(pieceT p){
-  static vector<pieceT>valid{
-      WK,WQ,WR,WB,WN,WP,
-      BK,BQ,BR,BB,BN,BP,
-      EMPTY
-      };
-  for(pieceT x : valid) if(x==p)return true;
-  return false;
-}
-
-
-char piece_to_char(pieceT p){
-  switch(p){
-  case BR: return 'r';
-  case BN: return 'n';
-  case BB: return 'b';
-  case BQ: return 'q';
-  case BK: return 'k';
-  case BP: return 'p';
-
-  case WR: return 'R';
-  case WN: return 'N';
-  case WB: return 'B';
-  case WQ: return 'Q';
-  case WK: return 'K';
-  case WP: return 'P';
-
-  case EMPTY: return '.';
-  }
-  uassert(false,"bad piece");
-  return 0;
-}
-
-///square related functions
-
-char* square_to_string(squareT square){
-  char buffer[100];
-  uassert(square_valid(square));
-  int f=square_file(square);
-  int r=square_rank(square);
-  char fc=file_to_char_cql(f);
-  char rc=rank_to_char_cql(r);
-  sprintf(buffer,"%c%c",fc,rc);
-  return util::copy(buffer);
-}
-  
-void square_print(squareT square){
-  uassert(square_valid(square));
-  int f=square_file(square);
-  int r=square_rank(square);
-  char fc=file_to_char_cql(f);
-  char rc=rank_to_char_cql(r);
-  printf("%c%c",fc,rc);
-}
-
-// squareT square_make(int f , int r){
-//   uassert(rank_valid(r)&&file_valid(f));
-//   return square_Make((fyleT)f, (rankT)r);
-// }
-
-// int square_rank(int s){
-//   uassert(square_valid(s));
-//   int r=square_Rank(s);
-//   uassert(rank_valid(r));
-//   return r;
-// }
-
-// int square_file(int s){
-//   uassert(square_valid(s));
-//   int f=square_Fyle(s);
-//   uassert(file_valid(f));
-//   return f;
-// }
-
-////end square-related functions
-
-const char * result_to_string(resultT rc){
-  switch(rc){
-  case RESULT_White: return "1-0";
-  case RESULT_Black: return "0-1";
-  case RESULT_Draw: return "1/2-1/2";
-  case RESULT_None: return "No_Result";
-  }
-  uassert(false,"bad result");
-  return NULL;
-}
-
-bool direction_valid(directionT d){
-  static vector<directionT> allds{
-      UP, DOWN, LEFT, RIGHT,
-	UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT};
-  for(auto dir:allds) if(dir==d)return true;
-  return false;
-}
-      
-
-  
-		      
-bool mark_valid(markT mark){
-  return mark>=0&&mark<=31;
-}
Index: src/cql/chesstypes.h
===================================================================
--- src/cql/chesstypes.h	(revision 2842)
+++ src/cql/chesstypes.h	(working copy)
@@ -1,26 +1 @@
-#pragma once
-#include "common.h"
-#include "game.h"
-#include "util.h"
-typedef int markT;
 
-inline bool color_valid(colorT c) {return c==WHITE || c==BLACK;}
-const char* color_string(colorT c);
-bool file_valid(int f);
-bool rank_valid(int r);
-char file_to_char_cql(int f);
-char rank_to_char_cql(int r);
-bool piece_valid(pieceT p);
-inline bool square_valid(int s){return s>=0&&s<64;}
-bool direction_valid(directionT d);
-inline squareT square_make(int f, int r){return square_Make((fyleT)f,(rankT)r);}
-squareT square_make(int f, int r);
-void square_print(squareT);
-char piece_to_char(pieceT);
-bool piece_valid(pieceT);
-inline int square_rank(int s){return square_Rank(s);}
-inline int square_file(int s){return square_Fyle(s);}
-char* square_to_string(squareT);
-const char * direction_to_string(directionT);
-const char * result_to_string(resultT);
-bool mark_valid(markT mark);
Index: src/cql/clone.cpp
===================================================================
--- src/cql/clone.cpp	(revision 2842)
+++ src/cql/clone.cpp	(working copy)
@@ -1,71 +1 @@
-#include "node.h"
-#define CCCC(X) X* X::clone(){X* ret=new X(*this);ret->deepify();cloneverify(this,ret);return ret;}
-CCCC(AnyNode);
-CCCC(AssignNode);
-CCCC(AttackNode);
-CCCC(BetweenNode);
-CCCC(BeginVariationNode);
-CCCC(CheckNode);
-CCCC(ColorNode);
-CCCC(CommentSet);
-CCCC(CommentString);
-CCCC(CountSquaresNode);
-CCCC(CqlNode);
-CCCC(EchoMaxDistanceSpec);
-CCCC(EchoSourceDistanceSpec);
-CCCC(EchoSumDistanceSpec);
-CCCC(EchoTargetDistanceSpec);
-CCCC(EchoLongestSubstringSpec);
-CCCC(EchoNode);
-CCCC(EchoSideToMoveSpec);
-CCCC(EchoSquareSpec);
-CCCC(EchoTransformSpec);
-CCCC(EloNode);
-CCCC(ExistsNode);
-CCCC(ExtensionNode);
-CCCC(EventNode);
-CCCC(ForallNode);
-CCCC(FutureNode);
-CCCC(FutureStarNode);
-CCCC(GameNumberNode);
-CCCC(HolderConstituent);
-CCCC(InMainlineNode);
-CCCC(InVariationNode);
-CCCC(InitialNode);
-CCCC(KeywordNode);
-CCCC(MatchCommentNode);
-CCCC(MatchCountNode);
-CCCC(MateNode);
-CCCC(MovePastNode);
-CCCC(MoveFutureNode);
-CCCC(MoveLegalNode);
-CCCC(MoveNumberNode);
-CCCC(NotNode);
-CCCC(OrNode);
-CCCC(OnNode);
-CCCC(OptionalConstituent);
-CCCC(OriginNode);
-CCCC(OutputNode);
-CCCC(PastNode);
-CCCC(PastStarNode);
-CCCC(PgnNode);
-CCCC(PieceIdNode);
-CCCC(PieceLoc);
-CCCC(PlayerNode);
-CCCC(PlusConstituent);
-CCCC(PositionNode);
-CCCC(PowerNode);
-CCCC(PowerDifferenceNode);
-CCCC(RayNode);
-CCCC(RepeatConstituent);
-CCCC(ResultNode);
-CCCC(SilentFeatureNode);
-CCCC(SiteNode);
-CCCC(StalemateNode);
-CCCC(StarConstituent);
-CCCC(TerminalNode);
-CCCC(VariationsNode);
-CCCC(VectorConstituent);
-CCCC(VectorNode);
-CCCC(YearNode);
-;
+
Index: src/cql/clonevec.h
===================================================================
--- src/cql/clonevec.h	(revision 2842)
+++ src/cql/clonevec.h	(working copy)
@@ -1,8 +1 @@
-#pragma once
-template <class T> void clonevec(vector<T*> &v){
-  for(int i=0;i<v.size();++i){
-    uassert(v[i],"Clonevec: unexpected null argument");
-    v[i]=v[i]->clone();
-  }
-};
-    
+
Index: src/cql/colortransform.cpp
===================================================================
--- src/cql/colortransform.cpp	(revision 2842)
+++ src/cql/colortransform.cpp	(working copy)
@@ -1,6 +1 @@
-#include "node.h"
-Transform* ColorTransform::flipColorTransform(){
-  Transform*ct=new ColorTransform();
-  Transform*fh=DihedralTransform::flipHorizontal();
-  return ct->compose(fh);
-}
+
Index: src/cql/commentbase.cpp
===================================================================
--- src/cql/commentbase.cpp	(revision 2842)
+++ src/cql/commentbase.cpp	(working copy)
@@ -1,46 +1 @@
-#include "node.h"
-bool CommentBase::match_position(Game*game){
-  char buffer[maxLen+5];
-  printBuffer(game,buffer);
-  uassert(strlen(buffer)<maxLen,"bad comment");
-  MarkBoard::gameAppendComment(game,buffer);
-  return true;
-}
 
-CommentString::CommentString(const char*s):str(s){
-  uassert(s&&strlen(s)<maxLen,"bad commentstring arg");
-}
-
-void CommentString::printBuffer(Game*g,char*buffer){
-  sprintf(buffer,"%s",str);
-}
-
-CommentSet::CommentSet(SetBase*v):set(v){
-  uassert(v,"commentset arg");
-}
-
-void CommentSet::printBuffer(Game*g,char*buffer){
-  SquareMask mask=set->getSquares(g);
-  char*current=buffer;
-  current+=sprintf(buffer,"[");
-  bool seen=false;
-  for(int sq=0;sq<64;++sq)
-    if(mask.member(sq)){
-      if(seen)
-	current+=sprintf(current,",");
-      int file=square_file(sq);
-      int rank=square_rank(sq);
-      current+=sprintf(current,"%c%c",file_to_char_cql(file),rank_to_char_cql(rank));
-      seen=true;
-    }
-  sprintf(current,"]");
-  return;
-}
-void CommentSet::print(){
-  printf("<%s set: ",thisclass());
-  set->print();
-  printf(">");
-}
-void CommentString::print(){
-  printf("<%s \"%s\">",thisclass(),str);
-}
Index: src/cql/commentflags.h
===================================================================
--- src/cql/commentflags.h	(revision 2842)
+++ src/cql/commentflags.h	(working copy)
@@ -1,8 +1 @@
-#pragma once
-class CommentFlags{
- public:
-  bool thesilent{false};
-  bool isSilent(){return thesilent;}
-  void setSilent(bool b){thesilent=b;}
-  void makeSilent(){setSilent(true);}
-};
+
Index: src/cql/composetransform.cpp
===================================================================
--- src/cql/composetransform.cpp	(revision 2842)
+++ src/cql/composetransform.cpp	(working copy)
@@ -1,54 +1 @@
-#include "node.h"
-squareT ComposeTransform::transform(squareT square){
-  uassert(square_valid(square));
-  squareT current=square;
-  for(auto t: transforms){
-    current=t->transform(current);
-    if(!square_valid(current)) return current;
-  }
-  return current;
-}
 
-SquareMask ComposeTransform::transform(SquareMask mask){
-  SquareMask m=mask;
-  for(auto t:transforms) m=t->transform(m);
-  return m;
-}
-
-
-void ComposeTransform::print(){
-  printf("<%s ",thisclass());
-  for(auto t:transforms) t->print();
-  printf(">");
-}
-
-ComposeTransform::ComposeTransform(vector<Transform*>ts) :transforms{ts}{
-  for(auto t:transforms) uassert(t);
-  uassert(transforms.size()>=2);
-}
-
-ComposeTransform::ComposeTransform(Transform*t, Transform*s){
-  uassert(t&&s);
-  transforms.push_back(s);
-  transforms.push_back(t);
-}
-
-Direction ComposeTransform::transform(Direction d){
-  Direction current(d);
-  for(auto t:transforms) current=t->transform(current);
-  return current;
-}
-
-bool ComposeTransform::flipsColor(){
-  bool flips=false;
-  for(auto t:transforms) if (t->flipsColor()) flips= !flips;
-  return flips;
-}
-
-vector<Transform*> ComposeTransform::composeVectors(vector<Transform*>a, vector<Transform*>b){
-  vector<Transform*>ret;
-  for(auto at:a)
-    for (auto bt:b)
-      ret.push_back(new ComposeTransform(at,bt));
-  return ret;
-}
Index: src/cql/countsquaresnode.cpp
===================================================================
--- src/cql/countsquaresnode.cpp	(revision 2842)
+++ src/cql/countsquaresnode.cpp	(working copy)
@@ -1,31 +1 @@
-#include "node.h"
-bool CountSquaresNode::match_position(Game*game){
-  SquareMask mask=set->getSquares(game);
-  count=mask.size();
-  return range->valid(count);
-}
 
-bool CountSquaresNode::match_count(Game*game,NumValue*value){
-  if(match_position(game)){
-    *value=(NumValue)(getCount());
-    return true;
-  }
-  return false;
-}
-
-CountSquaresNode::CountSquaresNode(SetBase* dp, Range*rp){
-  uassert(dp);
-  set=dp;
-  range=rp;
-  uassert(range);
-}
-
-void CountSquaresNode::print(){
-  printf("<%s ",thisclass());
-  range->print();
-  indent();
-  set->print();
-  printf(">");
-}
-
-// for CountSquaresNode::match_count, see coutable.cpp
Index: src/cql/cql.cpp
===================================================================
--- src/cql/cql.cpp	(revision 2842)
+++ src/cql/cql.cpp	(working copy)
@@ -1,151 +1 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <tcl.h>
-#include "node.h"
-#include "parser.h"
 
-void printhelp();
-int Cql_InitTcl(Tcl_Interp * interp);
-CqlNode* pNode;
-
-int main(int argc, char*argv[]){
-  cql_initialize();
-  printf("CQL version %s (build %s) (c) Gady Costeff and Lewis Stiller\n",
-	 CqlVersion,
-	 CqlBuild);
-  parseargs(argc,argv);
-  printf("CQL: reading CQL file: %s\n",CqlFilename);
-  pNode=parseFile(CqlFilename);
-  if(!pNode){
-    fprintf(stderr,"CQL: unable to parse file: %s\n",CqlFilename);
-    exit(1);
-  }
-  if(CqlShowParse){
-    pNode->print();
-    printf("\n");
-  }
-  if(!CqlParseOnly) {
-    Tcl_Main(argc, argv, Cql_InitTcl);  // never returns
-    //exit(0);
-  }
-}
-
-	      
-int Cql_InitTcl(Tcl_Interp * ti) {
-
-  if (Tcl_Init(ti) == TCL_ERROR) { return TCL_ERROR; }
-
-  pNode->match();  // off to match games against the CQL script
-  exit (0);  // no need to return to an interactive interpreter
-
-  // return TCL_OK;
-}
-
-	
-void parseargs(int argc, char*argv[]){
-  int nextarg=0;
-  if(argc==1){
-    printhelp();
-    exit(0);
-  }
-  while (++nextarg<argc){
-    char*current=argv[nextarg];
-    if(current==NULL || strlen(current)==0) break;
-    else if (!strcmp(current,"-d") || !strcmp(current,"--debug"))
-      CqlDebug=1;
-    else if (!strcmp(current,"--parse")) {
-	CqlParseOnly=true;
-	CqlShowParse=true;
-	CqlShowLex=true;
-	CqlDebug=true;
-      }
-    else if (!strcmp(current,"--pgn")
-	     ||!strcmp(current,"-i")
-	     ||!strcmp(current,"--input")){
-	++nextarg;
-	uassert(nextarg<argc,"CQL command line: missing input file argument");
-	CqlPgnFilename=argv[nextarg];
-      uassert(filename_is_pgn(CqlPgnFilename),"invalid pgn input filename from command line", CqlPgnFilename);
-    }
-    else if (!strcmp(current,"--nolinearize"))
-      CqlDoNotLinearize=true;
-    else if (!strcmp(current,"--output")||!strcmp(current,"-o")){
-      ++nextarg;
-      uassert(nextarg<argc,"CQL command line: missing output file argument");
-      CqlOutputFilename=argv[nextarg];
-      uassert(CqlOutputFilename,"missing output file");
-      uassert(filename_is_pgn(CqlOutputFilename),"bad output filenemame from command line", CqlOutputFilename);
-    }
-    else if (!strcmp(current,"--player")){
-      ++nextarg;
-      uassert(nextarg<argc,"CQL command line: missing player argument");
-      CqlPlayer=argv[nextarg];
-      uassert(CqlPlayer,"missing player");
-    }
-    else if (!strcmp(current,"-g")||!strcmp(current,"--gamenumber")||!strcmp(current,"--game")){
-      ++nextarg;
-      uassert(nextarg<argc,"CQL command line: missing gamenumber");
-      int gamestart=0;
-      int gamestop=0;
-      if (!util::positiveIntValue(argv[nextarg],&gamestart))
-	uassert(false,"expected positive integer following -g or --game");
-      uassert(gamestart>0,"internal");
-      if(nextarg+1<argc&& util::positiveIntValue(argv[nextarg+1],&gamestop))
-	nextarg++;
-      if (gamestop==0) gamestop=gamestart;
-      CqlGameNumberRange=new Range(gamestart,gamestop);
-    }
-    else if (!strcmp(current,"--year")){
-      ++nextarg;
-      uassert(nextarg<argc,"CQL command line: missing year");
-      int yearstart=0;
-      int yearstop=0;
-      if (!util::positiveIntValue(argv[nextarg],&yearstart))
-	uassert(false,"expected positive integer following --year");
-      uassert(yearstart>0,"internal");
-      if(nextarg+1<argc&& util::positiveIntValue(argv[nextarg+1],&yearstop))
-	nextarg++;
-      if (yearstop==0) yearstop=yearstart;
-      CqlYearRange=new Range(yearstart,yearstop);
-    }
-    else if (!strcmp(current,"--silent")){
-      CqlSilent=true;
-    }
-    else if (!strcmp(current,"-h")|| !strcmp (current,"--help")){
-      printhelp();
-      exit(0);
-    }
-    else if (current[0]=='-'){
-      fprintf(stderr, "CQL: invalid option: %s. Printing help: \n",current);
-      printhelp();
-      exit(1);
-    }
-    else{
-    uassert(!CqlFilename,"cql command line: got two CQL filenames, last one is ", current);
-    CqlFilename=current;
-    if(!filename_extension(CqlFilename))
-      CqlFilename=util::string_append(CqlFilename,".cql");
-    uassert(filename_is_cql(CqlFilename),
-	    "CQL command line: CQL file must have extension .cql or .CQL, if it has an extension. Invalid CQL filename: ",CqlFilename);
-    uassert(nextarg==argc-1,"The CQL filename must be the last argument on the command line", current);
-    break;
-    }
-  }//while(++nextarg<argc)
-  uassert(CqlFilename,"No CQL file specified to command line");
-}
-
-void printhelp(){
-  printf("CQL usage: cql options filename\n");
-  printf(" the 'filename' above should a be a file with extension .cql. The allowed options are:\n");
-  printf("--help or -h: print this message\n");
-  printf("--parse: parse only, do not run [not supported]\n");
-  printf("--player playername to restrict output to given playername\n");
-  printf("--silent: do not add any annotations to matched games\n");
-  printf("--year number or --year number number to restrict output to year in the given range\n");
-  printf("-g number, or -g number number, or --game number, or --game number number to specify the range of games to search\n");
-  printf("-i inputfile.pgn (or --pgn inputfile.pgn, or --input inputfile.pgn): read games from inputfile.pgn\n");
-  printf("-o outputfile.pgn (or --output outputfile.pgn): write output to outputfile.pgn\n");
-}
-
Index: src/cql/cql.h
===================================================================
--- src/cql/cql.h	(revision 2842)
+++ src/cql/cql.h	(working copy)
@@ -1,9 +1 @@
-#pragma once
-extern const char * CqlVersion;
-extern const char * CqlBuild;
 
-void parseargs(int argc, char*argv[]);
-void cql_initialize();
-void versionInitialize();
-void cqlglobals_initialize();
-
Index: src/cql/cqlassert.cpp
===================================================================
--- src/cql/cqlassert.cpp	(revision 2842)
+++ src/cql/cqlassert.cpp	(working copy)
@@ -1,40 +1 @@
-#include <string>
-using std::string;
-#include "cqlassert.h"
-#include "cqlexit.h"
 
-void uassert(void* v){
-  uassert(v!=NULL);
-}
-
-void uassert(void* v,const char*s){
-  uassert(v!=NULL,s);
-}
-
-void uassert(void *v,const char*s, const char*s2){
-  uassert(v!=NULL,s,s2);
-}
-
-
-void uassert(bool b){
-  if(!b)
-    cql_exit("assertion failure");
-}
-
-void uassert(bool b,const char*s){
-  if (!b)
-    uassert(b,s,"");
-}
-
-void uassert(bool b,const char*s1, const char*s2){
-  if (!b){
-    if(!s1)s1="missing uassert argument1";
-    if(!s2)s2="missing uassert argument2";
-    string *ret=new string("CQL error: ");
-    if(!ret) cql_exit("Fatal memory");
-    *ret+=s1;
-    *ret+=s2;
-    cql_exit(ret->data());
-  }
-}
-
Index: src/cql/cqlassert.h
===================================================================
--- src/cql/cqlassert.h	(revision 2842)
+++ src/cql/cqlassert.h	(working copy)
@@ -1,8 +1 @@
-#pragma once
 
-void uassert(void*);
-void uassert(void*,const char*s);
-void uassert(void*,const char*s,const char*s1);
-void uassert(bool b);
-void uassert(bool b, const char*s, const char* s1);
-void uassert(bool, const char*s);
Index: src/cql/cqlexit.cpp
===================================================================
--- src/cql/cqlexit.cpp	(revision 2842)
+++ src/cql/cqlexit.cpp	(working copy)
@@ -1,23 +1 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include "cqlexit.h"
 
-#ifndef INTEGRATED  
-void cql_exit(const char* message){
-  if(!message)message="BAD CQL_EXIT ARGUMENT";
-  printf("\n%s\n",message);
-  exit(1);
-}
-#endif
-
-#ifdef INTEGRATED
-#include <iostream>
-#include <csetjmp>
-char *cqlErrMsg;
-std::jmp_buf jump_buffer;
-void cql_exit(const char* message){
-  cqlErrMsg = (char *)message;
-  std::longjmp(jump_buffer, 1);
-}
-#endif
-
Index: src/cql/cqlexit.h
===================================================================
--- src/cql/cqlexit.h	(revision 2842)
+++ src/cql/cqlexit.h	(working copy)
@@ -1,7 +1 @@
-#pragma once
-void cql_exit();
-void cql_exit(const char* message);
 
-extern char *cqlErrMsg;
-extern char *cqlDiagnostic;
-
Index: src/cql/cqlglobals.cpp
===================================================================
--- src/cql/cqlglobals.cpp	(revision 2842)
+++ src/cql/cqlglobals.cpp	(working copy)
@@ -1,53 +1 @@
-#include "cqlglobals.h"
-using std::set;
 
-bool CqlDebug=false;
-bool CqlParseOnly=false;
-bool CqlShowParse=false;
-bool CqlShowLex=false;
-
-const char* CqlFilename=0;
-#ifdef STANDALONE
-const char* CqlPgnFilename=0;
-const char* CqlOutputFilename=0;
-#endif
-#ifdef INTEGRATED
-const char* CqlPgnFilename="fileInNull.pgn";
-const char* CqlOutputFilename="fileOutNull.pgn";
-#endif
-bool CqlSilent=false;
-Range* CqlGameNumberRange=0;
-Range* CqlYearRange=0;
-const char* CqlPlayer=0;
-int MarkBoard_gameAppendComment_lastignored=-1; //must be initialized to -1
-int Tokens_match_optional_numericvariable_nextid=0; // the next valid id to use if no name specified by numeric
-Tokens* CqlGlobalTokens=0; //the list of tokens that have been read
-CqlNode* CqlParseRoot=0; //The most recently read CQL parse tree;
-set<SequenceBase*>* CqlAllSequences=0; //All of the sequences, used by Nest::getSequenceDescendants
-bool CqlDoNotLinearize=false;
-
-void cqlglobals_initialize(){
- CqlDebug=false;
- CqlParseOnly=false;
- CqlShowParse=false;
- CqlShowLex=false;
- CqlFilename=0;
- #ifdef STANDALONE
- CqlPgnFilename=0;
- CqlOutputFilename=0;
- #endif
- #ifdef INTEGRATED
- CqlPgnFilename="fileInNull.pgn";
- CqlOutputFilename="fileOutNull.pgn";
- #endif
- CqlSilent=false;
- CqlGameNumberRange=0;
- CqlYearRange=0;
- CqlPlayer=0;
- MarkBoard_gameAppendComment_lastignored=-1; //must be initialized to -1
- Tokens_match_optional_numericvariable_nextid=0; // the next valid id to use if no name specified by numeric
- CqlGlobalTokens=0; //the list of tokens that have been read
- CqlParseRoot=0; //The most recently read CQL parse tree;
- CqlAllSequences=0; //All of the sequences, used by SequenceBase::getSequenceDescendants()
- CqlDoNotLinearize=false;
-}
Index: src/cql/cqlglobals.h
===================================================================
--- src/cql/cqlglobals.h	(revision 2842)
+++ src/cql/cqlglobals.h	(working copy)
@@ -1,33 +1 @@
-#pragma once
-/***** certain global variables to be reset.*////
-/**the following are used to hold command line parameters. 
-   These parameters override values specified in the cql file itself
-   Most of these don't need to be global at all actually
-*/
-#include <set>
-class Range;
-class Tokens;
-class SequenceBase;
-class CqlNode;
 
-extern bool CqlDebug; // debugging, not used
-extern bool CqlParseOnly; //show only the parse
-extern bool CqlShowLex; // show only the lex, may not be used
-extern bool CqlShowParse; // show the parse
-extern const char* CqlFilename; // read from this CqlFilename
-extern const char* CqlPgnFilename; //read from this PgnFilename
-extern const char* CqlOutputFilename; // read from this CqlOutputFilename
-extern Range* CqlGameNumberRange; //Use this gamenumberrange
-extern bool CqlSilent; // don't comment
-extern Range* CqlYearRange; // only search in these years
-extern const char* CqlPlayer; //only look for this player
-extern bool CqlDoNotLinearize; // whether to linearize move filters inside next filter
-
-/* Caches: static variables in methods*/
-extern  int MarkBoard_gameAppendComment_lastignored; //must be initialized to -1
-extern int Tokens_match_optional_numericvariable_nextid; // the next valid id to use if no name specified by numeric
-extern Tokens* CqlGlobalTokens; //the list of tokens that have been read
-
-/* Other global variables*/
-extern CqlNode* CqlParseRoot; //The most recently read CQL parse tree;
-extern std::set<SequenceBase*>* CqlAllSequences; //All of the sequences, used by SequenceBase::nestsClearAll
Index: src/cql/cqlinitialize.cpp
===================================================================
--- src/cql/cqlinitialize.cpp	(revision 2842)
+++ src/cql/cqlinitialize.cpp	(working copy)
@@ -1,13 +1 @@
-#include "node.h"
-void cql_initialize(){
-  static bool first_call=true; //first time called
-  if(first_call){
-    uassert(sizeof(Mask)==8,"Expecting sizeof of datatype 'Mask' to be 8");
-    setbuf(stdout,NULL);
-    //scid_Init(); // remove this at some future point. 
-  }
-  cqlglobals_initialize();
-  MarkBoard::restart();
-  Deleteable::deleteableCleanup(); //Not deleteableInitalize!
-  first_call=false;
-}
+
Index: src/cql/cqlnode.cpp
===================================================================
--- src/cql/cqlnode.cpp	(revision 2842)
+++ src/cql/cqlnode.cpp	(working copy)
@@ -1,179 +1 @@
-#include "node.h"
-#include "pgnparse.h"
-#include "tokenstream.h"
-CqlNode::CqlNode(vector<Node*> features,Node*node){
-#ifdef STANDALONE
-  uassert(features.size(),"null feature");
-#endif
-  uassert(node);
-  filter=dynamic_cast<MFilter*>(node);
-  uassert(filter,"CqlNode: bad node argument: expected an mfilter");
-  filter->annotateFlag=true;
 
-  for(auto feature : features){
-    VariationsNode*variationsnode=dynamic_cast<VariationsNode*>(feature);
-    if(variationsnode){
-      uassert(!isVariationsSet(),"Only one :variations keyword allowed in a CQL node");
-      setSearchVariations(true);
-      continue;
-    }
-  
-    SilentFeatureNode*silent=dynamic_cast<SilentFeatureNode*>(feature);
-    if(silent){
-      makeSilent();
-      continue;
-    }
-    PgnNode *pgnnode=dynamic_cast<PgnNode*>(feature);
-    if(pgnnode){
-      uassert(!inputfile,"multiple pgn designators");
-      inputfile=pgnnode->value;
-      uassert(inputfile);
-      pgnnode->disable();
-      continue;
-    }
-
-    OutputNode* outputnode=dynamic_cast<OutputNode*>(feature);
-    if(outputnode){
-      uassert(!outputfile,"Multiple outputfiles");
-      outputfile=outputnode->value;
-      uassert(outputfile);
-      if(0)printf("cqlnode: got output file of: %s\n",outputfile);
-      outputnode->disable();
-      continue;
-    }
-
-    MatchCountNode* matchcountnode=dynamic_cast<MatchCountNode*>(feature);
-    if(matchcountnode){
-      uassert(!matchCountRange,"unexpected two matchcount ranges");
-      matchCountRange=matchcountnode->range;
-      if(matchcountnode->sort){
-	NumericVariable*mc=Variable::getNumericVariable("matchcount",true);
-	sortfields.push_back(mc);
-      }
-      continue;
-    }
-    
-    GameNumberNode* gamenumbernode=dynamic_cast<GameNumberNode*>(feature);
-    if(gamenumbernode){
-      uassert(!gamenumberrange,"unexpected two gamenumberranges");
-      gamenumberrange=gamenumbernode->range;
-      uassert(gamenumberrange,"expected non-null game number range");
-      continue;
-    }
-    
-    GameFilter* gamefilter=dynamic_cast<GameFilter*>(feature);
-    if(gamefilter){
-      gamefilters.push_back(gamefilter);
-      continue;
-    }
-    uassert(false,"cql unknown feature: ",feature->thisclass());
-  }
-  if(!isVariationsSet())
-    setSearchVariations(false);
-  if(!inputfile)
-    inputfile=CqlPgnFilename;
-  uassert(inputfile,"Missing pgn file: no pgn file was specified either (a) via 'pgn filname.pgn' in cql form, or (b) via '--pgn filename.pgn' or '--input filename.pgn' as a command line argument to 'cql'");
-  if(!outputfile)
-    outputfile=CqlOutputFilename;
-  if(outputfile)
-    uassert(filename_is_pgn(outputfile),"Expected pgn extension in output file: ",outputfile);
-  if(!outputfile)
-    outputfile=outputFileFromCqlFile(CqlFilename);
-  if(outputfile)
-    uassert(filename_is_pgn(outputfile),"Expected pgn extension in output file: ",outputfile);
-  uassert(outputfile,"internal: expected output file in cql creation");
-  if(CqlGameNumberRange)
-    gamenumberrange=CqlGameNumberRange;
-  if(CqlSilent)makeSilent();
-  if(CqlPlayer){
-    PlayerNode*p=new PlayerNode(CqlPlayer,NOCOLOR);
-    gamefilters.push_back(p);
-  }
-  if(CqlYearRange){
-    YearNode*y=new YearNode(CqlYearRange);
-    gamefilters.push_back(y);
-  }
-}
-
-const char* CqlNode::outputFileFromCqlFile(const char* cqlname){
-  uassert(filename_is_cql(cqlname));
-  const char*stem=filename_stem(cqlname);
-  uassert(stem&&strlen(stem),"bad stem from: ",cqlname);
-  return util::string_append(stem,"-out.pgn");
-}
-  
-void CqlNode::print(){
-  printf("<%s  inputfile: %s outputfile: %s",thisclass(),inputfile,outputfile);
-  printVariationFlags();
-  if(usemarks) printf(" usemarks ");
-  if(gamenumberrange){
-    printf(" gamenumberrange: ");
-    gamenumberrange->print();
-  }
-  if(!sortfields.empty()){
-    printf(" sortfields:");
-    for(int i=0;i<sortfields.size();++i){
-      sortfields[i]->print();}
-  }
-  if(matchCountRange){
-    printf("matchCountRange: ");
-    matchCountRange->print();
-  }
-  indent();
-  for(int i=0;i<gamefilters.size();++i){
-    printf("\n");
-    tab();
-    printf("GameFilter %d of %lu: ",i,gamefilters.size());
-    gamefilters[i]->print();
-  }
-    
-  printf("\n");tab();
-  printf("filter: ");
-  filter->print();
-  printf(" %s>",thisclass());
-}
-
-
-vnode CqlNode::children()
-{ vnode ret;
-  ret.push_back(filter);
-  ret.insert(ret.end(),gamefilters.begin(),gamefilters.end());
-  return ret;
-};
-
-void CqlNode::setUseMarks(){
-  vnode v=descendants();
-  for(auto w:v)
-    if(dynamic_cast<PieceIdNode*>(w))
-      usemarks=true;
-}
-
-void CqlNode::setFirstComment(Game*game){
-  if (isSilent())return;
-  MarkBoard::gameMoveToPly(game,0);
-  char buffer[10000];
-  char*current=buffer;
-  *current=0;
-  for(NumericVariable* var:sortfields)
-    current+=sprintf(current," %s: %d",var->name,(int)(var->getExtremalValue()));
-  MarkBoard::gameAppendComment(game,buffer);
-}
-
-     
-  
-GameSortInfo CqlNode::makeInfo(Game*game){
-  vector<SortValue> values;
-  for(NumericVariable* var : sortfields)
-    values.push_back(SortValue(var->getExtremalValue(),var->isMax()));
-  string out=util::game_to_string(game);
-  return GameSortInfo(out,values);
-}
-  
-void CqlNode::annotateEchoes(Game*game){
-  vnode ds=descendants();
-  for(auto n:ds){
-    EchoNode*e=dynamic_cast<EchoNode*>(n);
-    if(e)e->annotate(game);
-  }
-}
-	   
Index: src/cql/cqlnodematch.cpp
===================================================================
--- src/cql/cqlnodematch.cpp	(revision 2842)
+++ src/cql/cqlnodematch.cpp	(working copy)
@@ -1,141 +1 @@
-#include "node.h"
 
-int CqlMatchCount = 0;
-uint CqlMatchPlyFirst;
-
-void CqlNode::do_match(MFilter*p,Game*game){
-  NumericVariable*mc=Variable::matchCountVariable();
-  bool searchvariations=getSearchVariations();
-  if(!searchvariations)
-    uassert(MarkBoard::inMainline(game));
-  auto id=MarkBoard::identity(game);
-  if(p->match_position(game)){
-    mc->increment();
-    // If our first match is in a variation, set the ply to 1.
-    if (!CqlMatchCount++)
-      if (game->GetVarLevel()) CqlMatchPlyFirst = 1;
-      else CqlMatchPlyFirst = game->GetCurrentPly();
-    if(p->annotateFlag&&!isSilent())
-      MarkBoard::gameAppendComment(game,"MATCH");
-  }
-  //  printf("cqlnode: unbinding tags at ply: %d\n",game->GetCurrentPly());
-  Variable::unbindTags();
-  int nchildren=MarkBoard::number_children(game,searchvariations);
-  vector<moveT*>ids;
-  ids.push_back(id);
-  for(int i=0;i<nchildren;++i){
-    MarkBoard::move_to_child(game,i);
-    auto childid=MarkBoard::identity(game);
-    for(auto oid:ids)
-      uassert(oid!=childid,"idcheck fail");
-    ids.push_back(childid);
-    do_match(p,game);
-    MarkBoard::gameBackup(game);
-    uassert(id==MarkBoard::identity(game),"movecheckfail");
-  }
-  uassert(id==MarkBoard::identity(game),"movecheckfail2");
-  uassert(mc->getValue()==mc->getExtremalValue());
-}
-
-bool CqlNode::match_game(Game*game){
-  game->MoveToPly(0);
-  if(CqlDebug) {
-    printf("\n\ncqlnode:match_game entered: %d\n", game->GetNumber());
-    util::printgame(stdout,game);
-  }
-#ifdef STANDALONE
-  char buffer[500];
-  //MarkBoard::cleanFirstComment(game);
-  sprintf(buffer,"Game number %u",game->GetNumber());
-  if(!isSilent())MarkBoard::gameAppendComment(game,buffer); 
-#endif
-  if(usemarks) MarkBoard::mark(game);
-  SequenceBase::nestsClear();
-  NumericVariable::resetAll();
-  NumericVariable*mc=Variable::matchCountVariable();
-  mc->bindNumeric(0);
-  // first check the standard tags
-  for(GameFilter* gf : gamefilters)
-    if(!gf->match_game(game))
-      return false;
-  CqlMatchCount = 0;
-  do_match(filter,game);
-  int nmatches=(int)(mc->getValue());
-  uassert(nmatches==(int)(mc->getExtremalValue()));
-  bool matched=false;
-  if(matchCountRange)
-    matched=matchCountRange->valid(nmatches);
-  else matched=(nmatches>0);
-  if(matched)
-    annotateEchoes(game);
-  if(matched && CqlDebug) {
-    printf("\n\ncqlnode:match_game matched on game: %d\n", game->GetNumber());
-    util::printgame(stdout,game);
-  }
-  return matched;
-}
-      
-void CqlNode::match(){
-  Game * game=new Game;
-  MFile*inputMFile=new MFile;
-  printf("CQL: reading PGN file: %s: \n",inputfile);
-  if(inputMFile->Open(inputfile,FMODE_ReadOnly)!=OK)
-    uassert(false,"Unable to open file: ",inputfile);
-  inputMFile->skipNonAscii();
-  PgnParser pgnparser(inputMFile);
-  currentGameNumber=0;
-  uassert(outputfile,"missing output file");
-  uassert(!outputstream,"unexpected outputstream");
-  outputstream=fopen(outputfile,"w");
-  uassert(outputstream,"CQL: could not open file for writing: ",outputfile);
-  int nmatches=0;
-  vector<GameSortInfo>infos;
-  while(pgnparser.ParseGame(game)!=ERROR_NotFound){
-    if(0){
-      printf("cqlnode:match printing just after parse: \n");
-      util::printgame(stdout,game);
-      printf("clqnode:match: done print just after parse\n");
-    }
-    game->SetNumber(++currentGameNumber);
-    if(gamenumberrange){
-      if(currentGameNumber>gamenumberrange->max)
-	break;
-      else if(currentGameNumber<gamenumberrange->min)
-	continue;
-    }
-    if ((currentGameNumber-1)%1000==0&&currentGameNumber>1000)
-      printf("%d\n",currentGameNumber);
-    else if ((currentGameNumber-1)%100==0)printf(".");
-    bool matched=match_game(game);
-    if(matched) {
-      ++nmatches;
-      printf("+<%d>",game->GetNumber());
-      setFirstComment(game);
-      infos.push_back(makeInfo(game));
-    } // if (matched)
-  } // while next game
-  GameSortInfo::sort(infos);
-  GameSortInfo::output(outputstream,infos);
-  printf("\nCQL: wrote %d matching game%s to file: %s\n",
-	 nmatches,
-	 nmatches==1 ? "" : "s",
-	 outputfile);
-}
-
-
-// Everything below this line is kludgeville... necessary because any inclusion
-// of a header from this directory in tkscid.cpp descends into include-file-hell.
-
-#ifdef INTEGRATED
-
-bool CqlMatchGame(Game *game) {
-  Range* gamenumberrange = CqlParseRoot->gamenumberrange;
-  int currentGameNumber = game->GetNumber();
-  if(gamenumberrange) {
-    if(currentGameNumber > gamenumberrange->max || currentGameNumber < gamenumberrange->min)
-      return false;
-  }
-
-  return CqlParseRoot->match_game(game);
-}
-#endif
Index: src/cql/deleteable.cpp
===================================================================
--- src/cql/deleteable.cpp	(revision 2842)
+++ src/cql/deleteable.cpp	(working copy)
@@ -1,42 +1 @@
-#include "node.h"
-set<Deleteable*>*Deleteable::deleteableConstructed;
-bool Deleteable::deleteableCleaningUp=false;
-size_t Deleteable::deleteableNDeleted=0;
 
-Deleteable::Deleteable(){
-  deleteableInitialize();
-  uassert(!deleteableCleaningUp,"Deletable: constructing an object during the cleanup phase");
-  uassert(deleteableConstructed,"deleteable: internal: construct");
-  uassert(deleteableConstructed->count(this)==0,"Deleteable: attempted construction of already constructed object");
-  deleteableConstructed->insert(this);
-}
-
-Deleteable::~Deleteable(){
-  uassert(deleteableCleaningUp,"Deleteable: a deletion occurred outside of the allowed cleanup time");
-  uassert(deleteableConstructed,"deleteable: internal: delete");
-  uassert(deleteableConstructed->count(this)==1,"deleteable: deleting a non-constructed instance");
-  ++deleteableNDeleted;
-}
-
-void Deleteable::deleteableCleanup(){
-  uassert(!deleteableCleaningUp,"deleteableCleanup internal");
-  uassert(deleteableNDeleted==0,"deleteableCleanup: unexpectedly seen deletion");
-  deleteableCleaningUp=true;
-  deleteableInitialize();
-  size_t ninstances=deleteableConstructed->size();
-  for (auto d : *deleteableConstructed){
-    uassert(d!=NULL,"deleteableCleanup: unexpected null instance");
-    delete d;
-  }
-  uassert(deleteableNDeleted==ninstances,"deleteableCleanup: ninstances mismatch");
-  if(1)printf("deleteableCleanup: deleted %d instances\n",(int)ninstances);
-  delete deleteableConstructed;
-  deleteableConstructed=NULL;
-  deleteableCleaningUp=false;
-  deleteableNDeleted=0;
-}
-
-void Deleteable::deleteableInitialize(){
-  if (!deleteableConstructed)
-    deleteableConstructed=new set<Deleteable*>;
-}
Index: src/cql/deleteable.h
===================================================================
--- src/cql/deleteable.h	(revision 2842)
+++ src/cql/deleteable.h	(working copy)
@@ -1,32 +1 @@
-#pragma once
-#include <stdlib.h>
-#include<set>
-using std::set;
 
-/*
-Abstract base class Deleteable. Keeps a list of all its instances and deletes them
-when deleteableCleanup() is called. To use, make a class you want to make Deleteable inherit (directly or indirectly) from
-Deleteable, e.g.
-class A : public Deleteable...{...}
-class B: public A{...}
-class C: public B{...}
-
-No instance of class A or a subclass of A can be deleted by the user or on the stack. Thus no such object can be allocated on the stack. All references to such objects are stale after deleteableCleanup() is called. Here, A, B and C are all Deleteable.
-
-For safety there should be no class E with parents F and G both of which are Deleteable.
-*/
-
-
-
-class Deleteable{
- public:
-  Deleteable();
-  virtual ~Deleteable();
-  static void deleteableCleanup();
-
- private:
-  static void deleteableInitialize();
-  static set<Deleteable*>*deleteableConstructed;
-  static bool deleteableCleaningUp;
-  static size_t deleteableNDeleted;
-};
Index: src/cql/dihedraltransform.cpp
===================================================================
--- src/cql/dihedraltransform.cpp	(revision 2842)
+++ src/cql/dihedraltransform.cpp	(working copy)
@@ -1,78 +1 @@
-#include "node.h"
 
-squareT DihedralTransform::transform(squareT s){
-  uassert(square_valid(s));
-  int x=square_file(s);
-  int y=square_rank(s);
-  uassert(file_valid(x)&&rank_valid(y));
-  int nx=x, ny=y;
-  if (reflectx) nx= 7-nx;
-  if (reflecty) ny= 7-ny;
-  if(swap) std::swap(nx,ny);
-  uassert(file_valid(nx)&&rank_valid(ny));
-  squareT ret=square_make(nx,ny);
-  uassert(square_valid(ret));
-  return ret;
-}
-
-DihedralTransform::DihedralTransform(bool rx, bool ry, bool sw)
-  : reflectx{rx}, reflecty{ry}, swap{sw}{}
-
-vector<Transform*>DihedralTransform::allDihedral(){
-  vector<Transform*> v;
-  vector<bool> bools{false,true};
-  for(bool rx:bools)
-    for(bool ry:bools)
-      for(bool sw:bools)
-	v.push_back(new DihedralTransform(rx,ry,sw));
-  return v;
-}
-
-Direction DihedralTransform::transform(Direction d){
-  squareT d4=square_make(3,3);
-  squareT sd4=d.apply(d4);
-  uassert(square_valid(sd4)&&sd4!=d4);
-  uassert(d.reachable(d4,sd4));
-  uassert(!d.reachable(sd4,d4));
-  squareT td4=transform(d4);
-  squareT tsd4=transform(sd4);
-  Direction ret=Direction(0,1);
-  int count=0;
-  for(auto candidate : Direction::allDirections())
-    if(candidate.reachable(td4,tsd4)){
-      ret=candidate;
-      ++count;}
-  uassert(count==1,"bad count in reflect direction");
-  return ret;
-}
-
-DihedralTransform* DihedralTransform::flipVertical(){
-  return new DihedralTransform(true,false,false);
-}
-
-DihedralTransform* DihedralTransform::flipHorizontal(){
-  return new DihedralTransform(false,true,false);
-}
-
-vector<Transform*> DihedralTransform::rotations(){
-  return  vector<Transform*>{
-      new DihedralTransform(false, true, true),
-      new DihedralTransform(true, true, false),
-      new DihedralTransform(true, false, true)};
-}
-
-void DihedralTransform::print(){
-  printf("<%s %d %d %d>",thisclass(),reflectx,reflecty,swap);
-}
-
-SquareMask DihedralTransform::transform(SquareMask mask){
-  SquareMask ret;
-  for(int sq=0;sq<64;++sq)
-    if(mask.member(sq)){
-      squareT newsq=transform(sq);
-      if(square_valid(newsq)) ret.insert(newsq);
-      else uassert(false, "transform mask");
-    }
-  return ret;
-}
-
Index: src/cql/direction.cpp
===================================================================
--- src/cql/direction.cpp	(revision 2842)
+++ src/cql/direction.cpp	(working copy)
@@ -1,111 +1 @@
-#include "util.h"
-void Direction::print(){
-  printf("<%d,%d>",xoffset,yoffset);
-}
 
-squareT Direction::apply(squareT square){
-  return apply(square, 1);
-}
-
-squareT Direction::apply(squareT square, int times){
-  uassert(times>=-7&&times<=7);
-  uassert(square_valid(square));
-  int x= square_file(square);
-  int y= square_rank(square);
-  int nx= x+xoffset*times;
-  int ny= y+yoffset*times;
-  if(file_valid(nx)&&rank_valid(ny)){
-    squareT ret=square_make(nx,ny);
-    uassert(square_valid(ret));
-    return ret;
-  }
-  return 65;
-}
-
-bool Direction::reachable(squareT source, squareT target){
-  uassert(square_valid(source)&&square_valid(target));
-  int dx=square_file(target)-square_file(source);
-  int dy=square_rank(target)-square_rank(source);
-  if (xoffset==0){
-    uassert(yoffset);
-    return dx==0&& dy/yoffset >0;
-  }
-  else if(yoffset==0){
-    uassert(xoffset);
-    return dy==0&&dx/xoffset>0;
-  }
-  else
-    return dx/xoffset==dy/yoffset&&
-      dx/xoffset>0;
-}
-
-SquareMask Direction::between(squareT source, squareT target){
-  SquareMask mask;
-  uassert(square_valid(source)&&square_valid(target));
-  if (source==target)return mask;
-  int sx=square_file(source);
-  int sy=square_rank(source);
-  int tx=square_file(target);
-  int ty=square_rank(target);
-  int deltax=tx-sx;
-  int deltay=ty-sy;
-  if (deltax && deltay && abs(deltax)!=abs(deltay)) return mask;
-  int xsign=deltax>0?1 : deltax< 0 ? -1 : 0;
-  int ysign=deltay>0?1 : deltay< 0 ? -1 : 0;
-  squareT current=source;
-  int currentx=sx;
-  int currenty=sy;
-  while(true){
-    currentx+=xsign;
-    currenty+=ysign;
-    current=square_make(currentx,currenty);
-    uassert(square_valid(current));
-    if(current==target)return mask;
-    mask.insert(current);
-  }
-  return mask;
-}  
-
-Direction::Direction(int xoff, int yoff):xoffset{xoff},yoffset{yoff}{
-  uassert(validOffset(xoff,yoff));
-}
-
-bool Direction::validOffset(int xoff, int yoff){
-  return validOffset(xoff)
-    &&validOffset(yoff)&&
-    (xoff||yoff);
-}
-
-bool Direction::validOffset(int off){
-  return off>=-1&&off<=1;
-}
-
-bool Direction::eq(const Direction & other){
-  return xoffset==other.xoffset && yoffset==other.yoffset;
-}
-
-vector<Direction>Direction::allDirections(){
-  vector<Direction>ret;
-  for(int xo= -1;xo<=1;++xo)
-    for(int yo= -1;yo<=1;++yo)
-      if(validOffset(xo,yo))
-	ret.push_back(Direction(xo,yo));
-  return ret;
-}
-  
-bool Direction::isCompatible(pieceT piece){
-  pieceT newp=piece_Type(piece);
-  if (newp==ROOK) return isOrthogonal();
-  else if(newp==BISHOP) return isDiagonal();
-  else if(newp==QUEEN) return isOrthogonal()||isDiagonal();
-  else return false;
-}
-
-bool Direction::isOrthogonal(){
-  return xoffset==0||yoffset==0;
-}
-
-bool Direction::isDiagonal(){
-  return xoffset&&yoffset;
-}
-  
Index: src/cql/direction.h
===================================================================
--- src/cql/direction.h	(revision 2842)
+++ src/cql/direction.h	(working copy)
@@ -1,36 +1 @@
-#pragma once
-class Range;
-class Direction{
- public:
-   int xoffset;
-   int yoffset;
-  Direction(int xoff,int yoff);
-  char* toString();
-  static vector<Direction> directionsFromString(const char*s);
-  void print();
-  squareT apply(squareT square);
-  squareT apply(squareT square, int ntimes);
-  bool reachable(squareT source, squareT target);
-  static SquareMask between(squareT source, squareT target);
-  static Direction fromString(const char* name);
-  bool eq(const Direction& other);
-  Direction reverse();
-  static vector<Direction> allDirections();
-  bool isDiagonal();
-  bool isOffdiagonal();
-  bool isOrthogonal();
-  static bool validOffset(int xoffset, int yoffset);
-  static bool validOffset(int offset);
-  bool isCompatible(pieceT piece);
-};
-  
-class DirectionParameter {
- public: vector<Direction> directions;
-  Range*range {NULL};
-  const char* thisclass(){return "DirectionParameter";}
-  void print();
-  SquareMask neighborhood(squareT square);
-  SquareMask neighborhood(SquareMask mask);
-  DirectionParameter(vector<Direction> v, Range*r);
-};
-  
+
Index: src/cql/directionmatch.cpp
===================================================================
--- src/cql/directionmatch.cpp	(revision 2842)
+++ src/cql/directionmatch.cpp	(working copy)
@@ -1,46 +1 @@
-#include "util.h"
 
-vector<Direction> Direction::directionsFromString(const char*s){
-  typedef Direction D;
-  typedef vector<Direction>V;
-  D up(0,1);
-  D down(0,-1);
-  D left(-1,0);
-  D right(1,0);
-  D northwest(-1,1);
-  D northeast(1,1);
-  D southwest(-1,-1);
-  D southeast(1,-1);
-
-  V diagonal{northwest,northeast,southwest,southeast};
-  V orthogonal{up,down,left,right};
-  V vertical{up,down};
-  V maindiagonal{northeast,southwest};
-  V horizontal{left,right};
-  V offdiagonal{northwest,southeast};
-  V anydirection{northwest,northeast,southwest,southeast,up,down,left,right};
-  
- 
-#define X(q) if(strcmp(s,#q)==0) return vector<Direction>{q}
-
-      X(up);
-      X(down);
-      X(left);
-      X(right);
-      X(northeast);
-      X(northwest);
-      X(southeast);
-      X(southwest);
-
-#define Y(q) if(strcmp(s,#q)==0) return vector<Direction>{q}
-      Y(diagonal);
-      Y(orthogonal);
-      Y(vertical);
-      Y(horizontal);
-      Y(maindiagonal);
-      Y(offdiagonal);
-      Y(anydirection);
-   
-      return vector<Direction>{};
-}
-   
Index: src/cql/directionparameter.cpp
===================================================================
--- src/cql/directionparameter.cpp	(revision 2842)
+++ src/cql/directionparameter.cpp	(working copy)
@@ -1,39 +1 @@
-#include "util.h"
-void DirectionParameter::print(){
-  printf("<%s",thisclass());
-  for(Direction d : directions){
-    printf(" ");
-    d.print();
-  }
-  range->print();
-  printf(">");
-}
 
-SquareMask DirectionParameter::neighborhood(squareT square){
-  SquareMask mask;
-  for (Direction direction:directions)
-    for(int i=range->min;i<=range->max;++i){
-      squareT newsquare=direction.apply(square,i);
-      if(square_valid(newsquare))
-	mask.insert(newsquare);
-    }
-  return mask;
-}
-
-SquareMask DirectionParameter::neighborhood(SquareMask mask){
-  SquareMask m;
-  for (squareT square : mask.getSquares())
-    m|=neighborhood(square);
-  return m;
-}
-
-DirectionParameter::DirectionParameter(vector<Direction> ds,Range *r){
-  uassert(r&&r->min>=-7&&r->max<=7,"dp invalid range");
-  directions=ds;
-  range=r;
-}
-
-
-
-
-    
Index: src/cql/echodistancespec.cpp
===================================================================
--- src/cql/echodistancespec.cpp	(revision 2842)
+++ src/cql/echodistancespec.cpp	(working copy)
@@ -1,48 +1 @@
-#include "node.h"
-EchoDistanceSpec::EchoDistanceSpec(Range*r,NumericVariable*v){
-  uassert(r,"missing range to distancespec");
-  range=r;
-  assignee=v;
-}
 
-  
-void EchoDistanceSpec::print(){
-  printf("<%s Range:",thisclass());
-  range->print();
-  printf(">");
-}
-
-bool EchoDistanceSpec::match_distance(int sourcedistance,int targetdistance){
-  computeCount(sourcedistance,targetdistance);
-  int val=getCount();
-  uassert(val>=0,"internal echodistancespec");
-  return range->valid(val);
-}
-
-bool EchoDistanceSpec::match_lca(const vector<moveT*>& sourcepath,
-				 const vector<moveT*>& targetpath){
-  uassert(sourcepath.size()&&targetpath.size()&&sourcepath[0]==targetpath[0]);
-  uassert(targetpath.back()==MarkBoard::identity(theGame));
-  int sourcedistance=(int)(sourcepath.size()-1);
-  int targetdistance=(int)(targetpath.size()-1);
-  if(!match_distance(sourcedistance,targetdistance))return false;
-  return true;
-}
-
-
-void EchoMaxDistanceSpec::computeCount(int sourced, int targetd){
-  setCount(std::max(sourced,targetd));
-}
-
-void EchoSourceDistanceSpec::computeCount(int sourced,int targetd){
-  setCount(sourced);
-}
-
-void EchoTargetDistanceSpec::computeCount(int sourced, int targetd){
-  setCount(targetd);
-}
-
-void EchoSumDistanceSpec::computeCount(int sourced,int targetd){
-  setCount(sourced+targetd);
-}
-  
Index: src/cql/echolcaspec.cpp
===================================================================
--- src/cql/echolcaspec.cpp	(revision 2842)
+++ src/cql/echolcaspec.cpp	(working copy)
@@ -1,79 +1 @@
-#include "node.h"
-void EchoLcaSpec::setCount(int j){
-  uassert(j>=0,"setcount");
-  theCount=j;
-}
 
-int EchoLcaSpec::getCount(){
-  uassert(theCount>=0,"getCount eds");
-  return theCount;
-}
-
-void EchoLcaSpec::clearCount(){
-  theCount=-1;
-}
-
-void EchoLcaSpec::computeLca(moveT*sourceid,
-			     moveT*targetid,
-			     vector<moveT*>&sourcemoves,
-			     vector<moveT*>&targetmoves){
-  uassert (sourcemoves.empty()&&targetmoves.empty());
-  uassert(sourceid&&targetid&&sourceid!=targetid);
-  vector<moveT*>sourceback=backsequence(sourceid);
-  vector<moveT*>targetback=backsequence(targetid);
-  int sourcebacklen=(int)(sourceback.size());
-  int targetbacklen=(int)(targetback.size());
-  uassert(sourcebacklen&&targetbacklen);
-  uassert(sourceback[0]==targetback[0]);
-  uassert(sourceback.back()==sourceid);
-  uassert(targetback.back()==targetid);
-  int lcai=-1;
-  for(lcai=0;;lcai++)
-    if(lcai>=sourcebacklen||
-       lcai>=targetbacklen||
-       sourceback[lcai]!=targetback[lcai]
-       ) {lcai--;break;}
-  uassert(lcai>=0
-	  &&lcai<sourcebacklen
-	  &&lcai<targetbacklen
-	  &&sourceback[lcai]==targetback[lcai]);
-  for(int i=lcai;i<sourcebacklen;++i)
-    sourcemoves.push_back(sourceback.at(i));
-  for(int i=lcai;i<targetbacklen;++i)
-    targetmoves.push_back(targetback.at(i));
-  theLca=sourcemoves[0];
-  uassert(theLca==targetmoves[0]);
-}
-
-vector<moveT*>EchoLcaSpec::backsequence(moveT*theid){
-  vector<moveT*>ids;
-  moveT *oldid=MarkBoard::identity(theGame);
-  MarkBoard::gameToIdentity(theid,theGame,true);
-  while(true){
-    ids.push_back(MarkBoard::identity(theGame));
-    if(theGame->AtStart()) break;
-    else MarkBoard::gameBackup(theGame);
-  }
-  uassert(theGame->AtStart());
-  std::reverse(ids.begin(),ids.end());
-  MarkBoard::gameToIdentity(oldid,theGame,true);
-  return ids;
-}
-
-
-bool EchoLcaSpec::match_target(){
-  vector<moveT*>sourcepath,targetpath,lcapath;
-  moveT* targetid=MarkBoard::identity(theGame);
-  uassert(targetid&&sourceIdentity&&targetid!=sourceIdentity);
-  computeLca(sourceIdentity,targetid,sourcepath,targetpath);
-  uassert(sourcepath.size()&&targetpath.size()&&sourcepath[0]==targetpath[0]&&
-	  sourcepath.back()==sourceIdentity&&
-	  targetpath.back()==targetid);
-  return match_lca(sourcepath,targetpath);
-}
-
-void EchoLcaSpec::start_new_search(Game*g){
-  EchoSpec::start_new_search(g);
-  theLca=NULL;
-}
-
Index: src/cql/echolongestsubstringspec.cpp
===================================================================
--- src/cql/echolongestsubstringspec.cpp	(revision 2842)
+++ src/cql/echolongestsubstringspec.cpp	(working copy)
@@ -1,93 +1 @@
-#include "node.h"
-int longestCommonSubstring(std::vector<int>a, std::vector<int>b, int* astart, int*bstart);
 
-EchoLongestSubstringSpec::EchoLongestSubstringSpec(Range*r,NumericVariable*v):range{r}{
-  uassert(range);
-  uassert(range->min>0,"LongestSubstring requires a positive minimum length");
-  assignee=v;
-}
-
-bool EchoLongestSubstringSpec::match_lca(const vector<moveT*>&sourcepath,
-				    const vector<moveT*>&targetpath){
-  clearCount();
-  int splen=(int)(sourcepath.size());
-  int tplen=(int)(targetpath.size());
-  if(splen<2||tplen<2)return false; 
-  uassert(sourcepath[1]!=targetpath[1]);
-  uassert(splen&&tplen&&sourcepath[0]==targetpath[0]);
-  vector<int>spints=path_to_ints(sourcepath);
-  vector<int>tpints=path_to_ints(targetpath);
-  uassert(spints.size()==splen-1);
-  uassert(tpints.size()==tplen-1);
-  uassert(spints.size()&&tpints.size());
-  int sstarti=-1,tstarti=-2;
-  int mylen=longestCommonSubstring(spints,tpints,&sstarti,&tstarti);
-  if(!mylen)return false;
-  uassert(mylen<=spints.size()&&mylen<=tpints.size()&&sstarti>=0&&tstarti>=0&&sstarti<spints.size()&&tstarti<tpints.size());
-  uassert(mylen+sstarti<=spints.size());
-  uassert(mylen+tstarti<=tpints.size());
-  for(int i=0;i<mylen;++i)
-    uassert(spints.at(i+sstarti)==tpints.at(i+tstarti));
-  if(!range->valid(mylen))return false;
-  
-  setCount(mylen);
-  matchedSourceStart=sstarti;
-  matchedTargetStart=tstarti;
-  matchedSourcePath.clear();
-  matchedTargetPath.clear();
-  for(int i=0;i<mylen;++i){
-    matchedSourcePath.push_back(sourcepath.at(sstarti+i));
-    matchedTargetPath.push_back(targetpath.at(tstarti+i));
-  }
-  seenmatch=true;
-  return true;
-}
-
-vector<int> EchoLongestSubstringSpec::path_to_ints(const vector<moveT*>&path){
-  int len=(int)(path.size());
-  uassert(len>=2);
-  vector<int>ret;
-  for(int i=len-1;i>0;--i)
-    ret.push_back(id_to_int(path.at(i)));
-  std::reverse(ret.begin(),ret.end());
-  uassert(ret.size()==len-1);
-  return ret;
-}
-
-int EchoLongestSubstringSpec::id_to_int(moveT*posid){
-  uassert(posid);
-  pieceT piece=50;
-  squareT from=65, to=65;
-  //  colorT color=65; Not certain how to handle color, whether encoded in piecetype or not
-  getprev(posid,&piece, &from, &to);
-  uassert(piece_valid(piece)&&square_valid(from)&&square_valid(to)&&to!=from);
-  int tmp= to*100+from;
-  tmp=tmp*100+(int)piece;
-  uassert(tmp>0&&tmp<5000000);
-  return tmp;
-}
-
-/* see Game::MoveBackup in game.cpp. 
-   The previous position or move which should exist is pointed to in moveT* prev field of arg.
-   That field has a moveData field of type simpleMoveT (in orig/movelist.h).
-   See game.h for the moveT definition
-*/
-void EchoLongestSubstringSpec::getprev(moveT* posid,pieceT* piece, squareT*from,squareT*to){
-  uassert(posid);
-  moveT*prev=posid->prev;
-  uassert(prev&&prev->marker!=START_MARKER);
-  *from=prev->moveData.from;
-  *to=prev->moveData.to;
-  *piece=prev->moveData.movingPiece;
-  return;
-}
-
-void EchoLongestSubstringSpec::print(){
-  printf("<%s ",thisclass());
-  range->print();
-  if(assignee)assignee->print();
-  if(seenmatch)
-    printf(" matchedLen: %d matchedSourceStart: %d matchedTargetStart: %d",
-	   getCount(),matchedSourceStart,matchedTargetStart);
-  printf(">");
-}
Index: src/cql/echomatchinfo.cpp
===================================================================
--- src/cql/echomatchinfo.cpp	(revision 2842)
+++ src/cql/echomatchinfo.cpp	(working copy)
@@ -1,155 +1 @@
-#include "node.h"
-EchoMatchInfo::EchoMatchInfo(EchoNode* node){
-  Game*g=node->theGame;
-  uassert(g);
-  gamenumber=g->GetNumber();
-  targetnumber=node->nfound;
-  source=node->sourceIdentity;
-  uassert(source,"bad source emi");
-  target=MarkBoard::identity(g);
-  for (EchoSpec* spec:node->specs){
-    EchoTransformSpec* et=dynamic_cast<EchoTransformSpec*>(spec);
-    if(et){
-      transform=et->matchedTransform;
-      uassert(transform,"expecting nonnull matchedTransform");
-      continue;
-    }
-    EchoLcaSpec* e=dynamic_cast<EchoLcaSpec*>(spec);
-    if(!e) continue;
-    if(lca) uassert(lca==e->theLca);
-    lca=e->theLca;
-    uassert(lca);
-    EchoLongestSubstringSpec* esubstring=dynamic_cast<EchoLongestSubstringSpec*>(spec);
-    if(!esubstring)continue;
-    if(esubstring->matchedSourcePath.size()>substringsource.size()){
-      substringsource=esubstring->matchedSourcePath;
-      substringtarget=esubstring->matchedTargetPath;
-    }
-    uassert(substringsource.size()&&substringtarget.size()&&
-	    substringsource.size()==substringtarget.size());
-  }
-}
-bool EchoMatchInfo::uselca()const{
-  return lca!=NULL;
-}
 
-int EchoMatchInfo::substringlen()const{
-  return (int)(substringsource.size());
-}
-
-bool EchoMatchInfo::usesubstring()const{
-  return substringlen()>0;
-}
-
-void EchoMatchInfo::print(){
-  printf("<%s source: %p target: %p lca: %p gamenumber: %d targetnumber: %d substringlen: %d\n",
-	 thisclass(),
-	 source,
-	 target,
-	 lca,
-	 gamenumber,
-	 targetnumber,
-	 substringlen());
-}
-
-void EchoMatchInfo::annotate(Game* game, const vector<EchoMatchInfo>& infos){
-  //Stage 1: Compute the list of sources and targets used
-  vector<moveT*>sources;
-  vector<moveT*>targets;
-  for(auto &emi : infos){
-    myinsert(sources,emi.source);
-    myinsert(targets,emi.target);
-  }
-  uassert(sources.size()&&targets.size());
-
-  //Stage 2: Annotate the sources
-  for(int i=0;i<sources.size();++i){
-    moveT* thissource=sources[i];
-    vector<int>targetids;
-    for(auto &emi:infos)
-      if(emi.source==thissource){
-	int targetid=myindex(targets,emi.target);
-	uassert(targetid>=0);
-	myinsert(targetids,targetid);
-      }
-    uassert(targetids.size());
-    char buffer[2000];
-    char*current=buffer;
-    current+=sprintf(current,"SOURCE %d [",i+1);
-    for(auto targetid: targetids)
-      current+=sprintf(current,"%d ",targetid+1);
-    --current;
-    current+=sprintf(current,"]");
-    MarkBoard::gameAppendComment(game,thissource,buffer);
-  }
-
-  //Stage 3: Annotate the targets
-  for(int i=0;i<targets.size();++i){
-    moveT* thistarget=targets[i];
-    vector<int>sourceids;
-    for(auto &emi:infos)
-      if(emi.target==thistarget){
-	int sourceid=myindex(sources,emi.source);
-	uassert(sourceid>=0);
-	myinsert(sourceids,sourceid);
-      }
-    uassert(sourceids.size());
-    char buffer[2000];
-    char*current=buffer;
-    
-    current+=sprintf(current,"TARGET %d [",i+1);
-    for(auto sourceid: sourceids)
-      current+=sprintf(current,"%d ",sourceid+1);
-    --current;
-    current+=sprintf(current,"]");
-    MarkBoard::gameAppendComment(game,thistarget,buffer);
-  }
-
-  //Stage 4: Annotate the LCAs
-  vector<moveT*>lcas;
-  for(auto& emi:infos){
-    if(emi.lca)
-      myinsert(lcas,emi.lca);
-  }
-  for(auto& lca:lcas)
-    MarkBoard::gameAppendComment(game,lca,"LCA");
-  for(auto& emi:infos)
-    if(emi.lca){
-      int sourceid=myindex(sources,emi.source);
-      int targetid=myindex(targets,emi.target);
-      uassert(sourceid>=0&&targetid>=0);
-      char buffer[100];
-      sprintf(buffer,"[%d,%d]",sourceid+1,targetid+1);
-      MarkBoard::gameAppendComment(game,emi.lca,buffer);
-    }
-      
-  //Stage 5: Annotate the longest substring
-  vector<moveT*>sourcesubstring;
-  vector<moveT*>targetsubstring;
-  int maxsubstring=0;
-  for(auto&emi:infos)
-    if(emi.usesubstring()&&emi.substringlen()>maxsubstring){
-      sourcesubstring=emi.substringsource;
-      targetsubstring=emi.substringtarget;
-      maxsubstring=emi.substringlen();
-      uassert(maxsubstring==(int)(sourcesubstring.size())&&
-	      sourcesubstring.size()==targetsubstring.size());
-    }
-  if(maxsubstring>0){
-    annotatePath(game, sourcesubstring,"SOURCEPATH",1);
-    annotatePath(game, targetsubstring,"TARGETPATH",1);
-  }
-}
-  
-void EchoMatchInfo::annotatePath(Game*game, const vector<moveT*>&path,const char * message,int start){
-  moveT*oldid=MarkBoard::identity(game);
-  MarkBoard::gameToIdentity(path.at(0),game,true);
-  char buffer[1000];
-  for(int pathi=start;pathi<path.size();++pathi){
-    MarkBoard::gameToIdentity(path.at(pathi),game,true);
-    sprintf(buffer,"%s: %d",message,pathi);
-    MarkBoard::gameAppendComment(game,buffer);
-  }
-  MarkBoard::gameToIdentity(oldid,game,true);
-}
-
Index: src/cql/echomatchinfo.h
===================================================================
--- src/cql/echomatchinfo.h	(revision 2842)
+++ src/cql/echomatchinfo.h	(working copy)
@@ -1,24 +1 @@
-#pragma once
-#include "node.h"
-class EchoMatchInfo{
- public:
-  Game*game{NULL};
-  int gamenumber{-1};
-  
-  int targetnumber{0};
-  moveT* source{NULL};
-  moveT* target{NULL};
-  moveT* lca{NULL};
-  bool uselca()const;
-  vector<moveT*> substringsource;
-  vector<moveT*> substringtarget;
-  Transform*transform{NULL};
-  int substringlen()const;
-  bool usesubstring()const;
-  static void annotate (Game*game, const vector<EchoMatchInfo>& infos);
-  EchoMatchInfo(EchoNode* node);
-  void print();
-  const char* thisclass(){return "EchoMatchInfo";}
-  static void annotatePath(Game*game, const vector<moveT*>&path, const char* message, int start);
 
-};
Index: src/cql/echonode.cpp
===================================================================
--- src/cql/echonode.cpp	(revision 2842)
+++ src/cql/echonode.cpp	(working copy)
@@ -1,124 +1 @@
-#include "node.h"
 
-EchoNode::EchoNode(vector<Node*>fs, vector<EchoSpec*>ss){
-  uassert(filters.size()==0);
-  for(Node*n:fs){
-    MFilter*m=dynamic_cast<MFilter*>(n);
-    uassert(m,"Bad argument to echonode, expected MFilter");
-    filters.push_back(m);
-  }
-  specs=ss;
-  for(auto s:specs) uassert(s,"invalid null spec to echoNode");
-  uassert(filters.size()==fs.size());
-  uassert(specs.size()==ss.size());
-}
-
-void EchoNode::print(){
-  printf("<%s NFilters: %lu NSpecs: %lu ",thisclass(),filters.size(),specs.size());
-  if(isSilent())printf("silent ");
-  for(int i=0;i<filters.size();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("Filter <%d of %lu: ",i,filters.size());
-    filters[i]->print();
-    unindent();
-  }
-  for(int i=0;i<specs.size();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("Spec <%d of %lu: ",i,specs.size());
-    specs[i]->print();
-    unindent();
-  }
-};
-vnode EchoNode::children(){
-  vnode v;
-  v.insert(v.end(),filters.begin(),filters.end());
-  v.insert(v.end(),specs.begin(),specs.end());
-  return v;
-}
-
-
-bool EchoNode::match_position(Game*g){
-  nfound=0;
-  start_new_search(g); //resets game to ply 0
-  match_target_children();
-  end_search();
-  return nfound>0;
-}
-
-//begin new search and set game to start
-void EchoNode::start_new_search(Game*g){
-  uassert(!insearch);
-  insearch=true;
-  theGame=g;
-  if(matchinfos.size()&&matchinfos[0].gamenumber!=g->GetNumber())
-    matchinfos.clear();
-  sourceIdentity=MarkBoard::identity(g);
-  for(auto spec:specs)
-    spec->start_new_search(g);
-  MarkBoard::gameMoveToPly(theGame,0);
-  return;
-}
-
-// match the target and, if not found, match the children of the target
-void EchoNode::match_target_children(){
-  bool searchvariations=getSearchVariations();
-  if(match_target()){++nfound;}
-  int nchildren=MarkBoard::number_children(theGame,searchvariations);
-  for(int child=0;child<nchildren;++child){
-      MarkBoard::move_to_child(theGame,child);
-      match_target_children();
-      MarkBoard::gameBackup(theGame);
-    }
-}
-
-bool EchoNode::match_target(){
-  if(MarkBoard::identity(theGame)==sourceIdentity) return false; //change later if allowed
-  for(MFilter*filter : filters)
-    if(!filter->match_position(theGame))
-      return false;
-  for(EchoSpec*spec:specs)
-    if(!spec->match_target()) return false;
-  assignVariables();
-  registerMatch();
-  return true;
-};
-
-void EchoNode::assignVariables(){
-  for(EchoSpec*spec:specs){
-    EchoLcaSpec* lcaspec=dynamic_cast<EchoLcaSpec*>(spec);
-    if(!lcaspec)continue;
-    NumericVariable*var=lcaspec->assignee;
-    if(!var) continue;
-    int len=lcaspec->getCount();
-    var->bindNumeric((NumValue)len);
-  }
-}
-
-void EchoNode::end_search(){
-  uassert(insearch);
-  for(auto spec:specs)
-    spec->end_search();
-  uassert(sourceIdentity);
-  MarkBoard::gameToIdentity(sourceIdentity,theGame,true);
-  sourceIdentity=NULL;
-  insearch=false;
-}
-
-void EchoNode::registerMatch(){
-  EchoMatchInfo info(this);
-  if(matchinfos.size())
-    uassert(matchinfos.back().gamenumber==theGame->GetNumber());
-  matchinfos.push_back(info);
-}
-
-void EchoNode::annotate(Game*game){
-  if(isSilent())return;
-  if(matchinfos.empty() || matchinfos.front().gamenumber!=game->GetNumber())
-    return;
-  EchoMatchInfo::annotate(game, matchinfos);
-}
-  
Index: src/cql/echonode.h
===================================================================
--- src/cql/echonode.h	(revision 2842)
+++ src/cql/echonode.h	(working copy)
@@ -1,30 +1 @@
-#pragma once
-#include "node.h"
 
-class EchoNode : public MFilter,public VariationFlags,public CommentFlags{
- public:
-  vector<MFilter*>filters;
-  vector<EchoSpec*> specs;
-  EchoNode(vector<Node*> filters, vector<EchoSpec*> specs);
-  bool match_position(Game*game);
-  void print();
-  CVV(EchoNode);
-  vnode children();
-  moveT* sourceIdentity{NULL};
-  void deepify(){clonevec(filters);clonevec(specs);}
-  vector<EchoMatchInfo> matchinfos;
-  void registerMatch();
-  bool matched{false};
-  int nfound{0};
-  Game*theGame{NULL};
-  void annotate(Game*game);
- private:
-  bool insearch{false};
-  void initialize();
-  bool match_target();
-  void start_new_search(Game*g);
-  void match_target_children();
-  void end_search();
-  void assignVariables();
-};
-
Index: src/cql/echoparse.cpp
===================================================================
--- src/cql/echoparse.cpp	(revision 2842)
+++ src/cql/echoparse.cpp	(working copy)
@@ -1,248 +1 @@
-#include "node.h"
-#include "tokenstream.h"
-EchoNode* Tokens::match_echonode(){
-  if(!match_keyword("relation")&&!match_keyword("echo")) return NULL;
-  vector<Node*>filters=match_some_basicnodes();
-  vector<EchoSpec*>specs=match_echospecs();
-  if(specs.empty())
-    show_error(
-	       "Syntax error parsing 'relation'. Expected a relation parameter enclosed in parens, or an echotransform spec, following the specifications after the relation keyword\n");
-  EchoNode*e=new EchoNode(filters,specs);
-  if(0)
-    {
-      printf("\nmatch_echonode: filters:\n");
-      for(auto f:filters){
-	printf("filter: %p: \n",f);
-	f->print();
-      }
-      printf("\nmatch_echonode: specs:\n");
-      for(auto s:specs){
-	printf("spec: %p: \n",s);
-	s->print();
-      }
-      printf("\nmatch_echonode: got echonode of: \n");
-      e->print();
-    }
-  return new EchoNode(filters,specs);
-  
-}
 
-vector<EchoSpec*> Tokens::match_echospecs(){
-  vector<EchoSpec*>specs;
-  EchoSpec*spec=NULL;
-  while(spec=match_echospec())
-    specs.push_back(spec);
-  return specs;
-}
-
-
-EchoSpec* Tokens::match_echospec(){
-  if(match_echoemptyspec())
-    show_error("Invalid empty 'relation' specification");
-  EchoSpec*e=NULL;
-  if(!e) e=match_echodescendant();
-  if(!e) e=match_echosquarespec();
-  if(!e) e=match_echolongestsubstringspec();
-  if(!e) e=match_echomaxdistancespec();
-  if(!e) e=match_echosumdistancespec();
-  if(!e) e=match_echosourcedistancespec();
-  if(!e) e=match_echotargetdistancespec();
-  if(!e) e=match_echoancestor();
-  if(!e) e=match_echotransformspec();
-  if(!e) e=match_echosidetomovespec();
-  return e;
-}
-
-bool Tokens::match_echoemptyspec(){
-  int x=save();
-  if(!match_lparen())return false;
-  if(!match_rparen()){
-    restore(x);
-    return false;
-  }
-  return true;
-}
-
-EchoSquareSpec* Tokens::match_echosquarespec(){
-  int x=save();
-  if(!match_lparen())return NULL;
-  SetBase*source=NULL;
-  SetBase*target=NULL;
-  Range*match=NULL;
-  Range*mismatch=NULL;
-  while(true)
-    if(match_keyword("sourcesquares")){
-      source=match_set();
-      if(!source) show_error("missing set specifier after 'sourcesquares'");
-      continue;
-    }
-    else if(match_keyword("targetsquares")){
-      target=match_set();
-      if(!target) show_error("missing set specifier after 'targetsquares'");
-      continue;
-    }
-    else if(match_keyword("match")){
-      match=match_range();
-      if(!match) show_error("missing range following 'match' in relation");
-      continue;
-    }
-    else if(match_keyword("mismatch")){
-      mismatch=match_range();
-      if(!mismatch) show_error("missing range following 'mismatch' in relation");
-      continue;
-    }
-    else break;
-  if(source||target||match||mismatch){
-    if(!match_rparen())
-      show_error("Expected ')' or relation specifier consituent: illegal relation specifier");
-    return new EchoSquareSpec(source,target,match,mismatch);
-  }
-  restore(x);
-  return NULL;
-}
-
-EchoDistanceSpec* Tokens::match_echoancestor(){
-  int x=save();
-  if(!match_lparen()) return NULL;
-  if (!match_keyword("ancestor")) {
-    restore(x);
-    return NULL;
-  }
-  if (!match_rparen())
-    show_error("expecting ')' following 'ancestor' keyword in relation specification");
-  return new EchoTargetDistanceSpec(new Range(0,0),NULL);
-}
-
-EchoDistanceSpec* Tokens::match_echodescendant(){
-  int x=save();
-  if(!match_lparen()) return NULL;
-  if (!match_keyword("descendant")) {
-    restore(x);
-    return NULL;
-  }
-  if (!match_rparen())
-    show_error("expecting ')' following 'descendant' keyword in relation specification");
-  return new EchoSourceDistanceSpec(new Range(0,0),NULL);
-}
-
-EchoMaxDistanceSpec* Tokens::match_echomaxdistancespec(){
-  int x=save();
-  if(!match_lparen()) return NULL;
-  NumericVariable*var=match_sortheader();
-  if(!match_keyword("lcamax")){
-    restore(x);
-    return NULL;
-  }
-  Range*range=match_range();
-  if(!range)
-    show_error("missing range in range specifier following 'lcamax'");
-  if(!match_rparen())
-    show_error("illegal specifier constituent, expecting ')'");
-  return new EchoMaxDistanceSpec(range,var);
-}
-
-EchoSumDistanceSpec* Tokens::match_echosumdistancespec(){
-  int x=save();
-  if(!match_lparen()) return NULL;
-  NumericVariable*var=match_sortheader();
-  if(!match_keyword("lcasum")){
-    restore(x);
-    return NULL;
-  }
-  Range*range=match_range();
-  if(!range)
-    show_error("missing range in range specifier following 'lcasum'");
-  if(!match_rparen())
-    show_error("illegal specifier constituent, expecting ')'");
-  return new EchoSumDistanceSpec(range,var);
-}
-
-EchoSourceDistanceSpec* Tokens::match_echosourcedistancespec(){
-  int x=save();
-  if(!match_lparen()) return NULL;
-  NumericVariable*var=match_sortheader();
-  if(!match_keyword("lcasource")){
-    restore(x);
-    return NULL;
-  }
-  Range*range=match_range();
-  if(!range)
-    show_error("missing range in range specifier following 'lcasource'");
-  if(!match_rparen())
-    show_error("illegal specifier constituent, expecting ')'");
-  return new EchoSourceDistanceSpec(range,var);
-}
-
-EchoTargetDistanceSpec* Tokens::match_echotargetdistancespec(){
-  int x=save();
-  if(!match_lparen()) return NULL;
-  NumericVariable*var=match_sortheader();
-  if(!match_keyword("lcatarget")){
-    restore(x);
-    return NULL;
-  }
-  Range*range=match_range();
-  if(!range)
-    show_error("missing range in range specifier following 'lcatarget'");
-  if(!match_rparen())
-    show_error("illegal specifier constituent, expecting ')'");
-  return new EchoTargetDistanceSpec(range,var);
-}
-
-EchoLongestSubstringSpec* Tokens::match_echolongestsubstringspec(){
-  int x=save();
-  if(!match_lparen())return NULL;
-  NumericVariable*var=match_sortheader();
-  if(!match_keyword("lcasubstring")){
-    restore(x);
-    return NULL;
-  }
-  Range*range=match_range();
-  if(!range)
-    show_error("Expected range following 'lcasubstring'");
-  if(!match_rparen())
-    show_error("expected ')' following range after 'lcasubstring'");
-  return new EchoLongestSubstringSpec(range,var);
-}
-
-EchoSpec* Tokens::match_echotransformspec(){
-  vector<Transform*> transforms=match_echotransforms();
-  if(transforms.empty())return NULL;
-  EchoSpec*spec=match_echospec();
-  if(!spec)
-    show_error("echo transforms  must be followed by a specification: expecting '(' for an echo spec");
-  return new EchoTransformSpec(transforms,spec);
-}
-
-vector<Transform*>Tokens::match_echotransforms(){
-  if (match_keyword("echoshiftvertical"))
-    return ShiftTransform::shiftVertical();
-  else if (match_keyword("echoshifthorizontal"))
-    return ShiftTransform::shiftHorizontal();
-  else if (match_keyword("echoshift"))
-    return ShiftTransform::allShift();
-  else if (match_keyword("echoflipvertical"))
-    return vector<Transform*>{DihedralTransform::flipVertical()};
-  else if (match_keyword("echofliphorizontal"))
-    return vector<Transform*>{DihedralTransform::flipHorizontal()};
-  else if (match_keyword("echorotate90"))
-    return DihedralTransform::rotations();
-  else if (match_keyword("echorotate45"))
-    return PiOver4Transform::rotations();
-  else if (match_keyword("echoflip") || match_keyword("echoflipdihedral")||match_keyword("echodihedral"))
-    return DihedralTransform::allDihedral();
-  else return vector<Transform*>{};
-}  
-
-EchoSideToMoveSpec* Tokens::match_echosidetomovespec(){
-  int x=save();
-  if(!match_lparen())return NULL;
-  if(!match_keyword("tomove")) {restore(x);return NULL;}
-  bool same=false;
-  if(match_keyword("match")) same=true;
-  else if (match_keyword("mismatch")) same=false;
-  else show_error("'tomove' in relation must be followed by either 'match' or 'mismatch'");
-  if(!match_rparen())
-    show_error ("missing ')' after '(tomove match' or '(tomove mismatch'");
-  return new EchoSideToMoveSpec(same);
-}
Index: src/cql/echosidetomovespec.cpp
===================================================================
--- src/cql/echosidetomovespec.cpp	(revision 2842)
+++ src/cql/echosidetomovespec.cpp	(working copy)
@@ -1,32 +1 @@
-#include "node.h"
-EchoSideToMoveSpec::EchoSideToMoveSpec(bool sameside){
-  same=sameside;
-}
 
-void EchoSideToMoveSpec::print(){
-  printf("<%s %s>",thisclass(),
-	 same?"same":"different");
-}
-
-bool EchoSideToMoveSpec::match_target(){
-  uassert(insearch,"sidetomove");
-  colorT tomove=theGame->GetCurrentPos()->GetToMove();
-  uassert (color_valid(tomove)&&color_valid(sourceToMove));
-  if (same) return tomove==sourceToMove;
-  else return tomove!=sourceToMove;
-}
-
-void EchoSideToMoveSpec::start_new_search(Game*game){
-  uassert(!insearch&&!color_valid(sourceToMove));
-  EchoSpec::start_new_search(game);
-  uassert(insearch&&game==theGame);
-  sourceToMove=game->GetCurrentPos()->GetToMove();
-  uassert(color_valid(sourceToMove));
-}
-
-void EchoSideToMoveSpec::end_search(){
-  uassert(insearch&&color_valid(sourceToMove));
-  sourceToMove=NOCOLOR;
-  EchoSpec::end_search();
-}
-
Index: src/cql/echospec.cpp
===================================================================
--- src/cql/echospec.cpp	(revision 2842)
+++ src/cql/echospec.cpp	(working copy)
@@ -1,20 +1 @@
-#include "node.h"
-void EchoSpec::start_new_search(Game*game){
-  uassert(!insearch&&!sourceIdentity);
-  sourceIdentity=MarkBoard::identity(game);
-  theGame=game;
-  insearch=true;
-}
 
-void EchoSpec::end_search(){
-  uassert(insearch&&sourceIdentity);
-  insearch=false;
-  sourceIdentity=NULL;
-}
-
-bool EchoSpec::match_target(Transform*t){
-  uassert(false,
-	  "\nAn echo transform can only operator on echo square specifiers, not on specifiers of type: ",
-	  thisclass());
-  return false;
-}
Index: src/cql/echospec.h
===================================================================
--- src/cql/echospec.h	(revision 2842)
+++ src/cql/echospec.h	(working copy)
@@ -1,134 +1 @@
-#pragma once
-class EchoSpec:public Node{ //abstract
- public:
-  bool insearch{false};
-  moveT* sourceIdentity{NULL};
-  Game*theGame{NULL};
-  virtual bool match_target()=0;
-  virtual void start_new_search(Game*game);
-  virtual void end_search();
-  virtual EchoSpec* clone()=0;
-  virtual bool match_target(Transform*); //returns error by default
-};
-class EchoSquareSpec:public EchoSpec{
- public:
-  EchoSquareSpec(SetBase*source,SetBase*target,Range*match,Range*mismatch);
-  void start_new_search(Game*game);
-  bool compareSourceTarget(squareT square);
-  bool compareSourceTargetTransformed(squareT square, squareT transformedsquare);
-  SquareMask sourcemask;
-  pieceT sourceboard[64];
-  SetBase*sourceset{NULL};
-  SetBase*targetset{NULL};
-  Range*mismatchrange{NULL};
-  Range*matchrange{NULL};
-  CVV(EchoSquareSpec);
-  vnode children(){return vnode{sourceset,targetset};}
-  void deepify(){sourceset=sourceset->clone();targetset=targetset->clone();}
-  void print();
-  bool match_target();
-  bool match_target(Transform*);
-};
-class EchoLcaSpec:public EchoSpec{//abstract
- public:
-  void computeLca(moveT*sourceid,
-		  moveT*targetid,
-		  vector<moveT*>&sourcemoves,
-		  vector<moveT*>&targetmoves);
-  vector<moveT*> backsequence(moveT*id);
-  void start_new_search(Game*g);
-  static void print(moveT*);
-  vnode children(){return vnode{};}
-  virtual bool match_target();
-  moveT* theLca{NULL};
-  NumericVariable*assignee{NULL};
-  virtual bool match_lca(const vector<moveT*>&sourcepath, const vector<moveT*>&targetpath)=0;
-  virtual int getCount();
-  virtual void clearCount();
-  virtual void setCount(int j);
- private:
-  int theCount=-1;
-};
 
-class EchoDistanceSpec:public EchoLcaSpec{//abstract
- public:
-  EchoDistanceSpec(Range*r,NumericVariable*v);
-  bool match_distance(int sourcedistance, int targetdistance);
-  virtual void computeCount(int sourcedistance, int targetdistance)=0;
-  bool match_lca(const vector<moveT*>&sourcepath, const vector<moveT*>&targetpath);
-  Range* range{NULL};
-  void print();
-  vnode children(){return vnode{};}
-};
-
-class EchoMaxDistanceSpec:public EchoDistanceSpec{
- public:
- EchoMaxDistanceSpec(Range*r,NumericVariable*v) : EchoDistanceSpec(r,v){}
-  CVV(EchoMaxDistanceSpec);
-  void computeCount(int sd, int td);
-};
-class EchoSumDistanceSpec:public EchoDistanceSpec{
- public:
- EchoSumDistanceSpec(Range*r,NumericVariable*v) : EchoDistanceSpec(r,v){}
-  CVV(EchoSumDistanceSpec);
-  void computeCount(int sd, int td);
-};
-class EchoSourceDistanceSpec:public EchoDistanceSpec{
- public:
- EchoSourceDistanceSpec(Range*r,NumericVariable*v) : EchoDistanceSpec(r,v){}
-  CVV(EchoSourceDistanceSpec);
-  void computeCount(int sd, int td);
-};
-class EchoTargetDistanceSpec:public EchoDistanceSpec{
- public:
- EchoTargetDistanceSpec(Range*r,NumericVariable*v) : EchoDistanceSpec(r,v){}
-  CVV(EchoTargetDistanceSpec);
-  void computeCount(int sd, int td);
-};
-  
-class EchoLongestSubstringSpec:public EchoLcaSpec{
- public:
-  Range*range{NULL};
-  bool seenmatch{false};
-  vector<moveT*>matchedSourcePath;
-  vector<moveT*>matchedTargetPath;
-  int matchedSourceStart{-1};
-  int matchedTargetStart{-1};
-  EchoLongestSubstringSpec(Range*r,NumericVariable*v);
-  bool match_lca(const vector<moveT*>&sourcepath,const vector<moveT*>&targetpath);
-  void print();
-  vnode children(){return vnode{};}
-  CVV(EchoLongestSubstringSpec);
-
- private:
-  static void getprev(moveT*posid,pieceT*piece,squareT*from,squareT*to);
-  static int id_to_int(moveT*posid);
-  static vector<int>path_to_ints(const vector<moveT*>&path);
-};
-
-class EchoTransformSpec:public EchoSpec{
- public:
-  EchoTransformSpec(vector<Transform*>,EchoSpec*);
-  vector<Transform*> transforms;
-  EchoSpec* spec{NULL};
-  Transform* matchedTransform{NULL};
-  vnode children(){return vnode{spec};}
-  void print();
-  bool match_target();
-  CVV(EchoTransformSpec);
-  void deepify(){spec=spec->clone();}
-  void start_new_search(Game*);
-  void end_search();
-};
-
-class EchoSideToMoveSpec:public EchoSpec{
- public: EchoSideToMoveSpec(bool sameside);
-  bool same{false};
-  colorT sourceToMove{NOCOLOR};
-  vnode children(){return vnode{};}
-  void print();
-  bool match_target();
-  void start_new_search(Game*game);
-  void end_search();
-  CVV(EchoSideToMoveSpec);
-};
Index: src/cql/echosquarespec-transform.cpp
===================================================================
--- src/cql/echosquarespec-transform.cpp	(revision 2842)
+++ src/cql/echosquarespec-transform.cpp	(working copy)
@@ -1,54 +1 @@
-#include "node.h"
-//This should be kept in sync with match_target()
-bool EchoSquareSpec::match_target(Transform*transform){
-  uassert(insearch);
-  int nmatches=0;
-  int nmismatches=0;
-  pieceT*targetboard=theGame->GetCurrentPos()->GetBoard();
-  SquareMask targetmask=targetset->getSquares(theGame);
-  SquareMask mask=sourcemask&targetmask;
-  SquareMask targettested;
-  pieceT targetpiece=EMPTY;
-  for(squareT square=0;square<64;++square)
-    if(mask.member(square)){
-      squareT transformedsquare=transform->transform(square);
-      if(square_valid(transformedsquare)){
-	targettested.insert(transformedsquare);
-	targetpiece=targetboard[transformedsquare];
-      }
-      else
-	targetpiece=EMPTY;
-      if(sourceboard[square]==targetpiece)
-	++nmatches;
-      else
-	++nmismatches;
-      if(nmatches>matchrange->max) return false;
-      if(nmismatches>mismatchrange->max) return false;
-    }
-  SquareMask remainder= mask & ~targettested;
-  for(squareT targetsquare=0;targetsquare<64;++targetsquare)
-    if(remainder.member(targetsquare)){
-      if(targetboard[targetsquare]!=EMPTY)
-	nmismatches=std::min(nmismatches+1,64);
-      else
-	nmatches=std::min(nmatches+1,64);
-      if (nmatches>matchrange->max||nmismatches>mismatchrange->max) return false;
-    }
-  if (!matchrange->valid(nmatches))return false;
-  if(!mismatchrange->valid(nmismatches))return false;
-  return true;
-};
 
-// bool EchoSquareSpec::compareSourceTargetTransformed(squareT square,squareT transformedsquare){
-//   uassert(square_valid(square));
-//   pieceT sourcepiece=sourceboard[square];
-//   pieceT targetpiece;
-  
-// =
-//     square_valid(transformedsquare) ? 
-//      MarkBoard::piece_at_square(transformedsquare,theGame)
-//     : EMPTY;
-  
-//   //  uassert(piece_valid(sourcepiece)&&piece_valid(targetpiece));
-//   return sourcepiece==targetpiece;
-// }
Index: src/cql/echosquarespec.cpp
===================================================================
--- src/cql/echosquarespec.cpp	(revision 2842)
+++ src/cql/echosquarespec.cpp	(working copy)
@@ -1,78 +1 @@
-#include "node.h"
-EchoSquareSpec::EchoSquareSpec(SetBase*source,
-			       SetBase*target,
-			       Range*match,
-			       Range*mismatch){
-  sourceset=source;
-  targetset=target;
-  matchrange=match;
-  mismatchrange=mismatch;
-  if(!sourceset)sourceset=new AnyNode();
-  if(!targetset)targetset=new AnyNode();
-  if (!matchrange)matchrange=new Range(0,64);
-  if(!mismatchrange)mismatchrange=new Range(0,64);
-}
 
-void EchoSquareSpec::start_new_search(Game*game){
-  EchoSpec::start_new_search(game);
-  uassert(insearch&&game==theGame);
-  sourcemask=sourceset->getSquares(game);
-  for(int sq=0;sq<64;++sq)
-    sourceboard[sq]=MarkBoard::piece_at_square(sq,game);
-}
-
-//keep in sync with match_target(Transform*)
-bool EchoSquareSpec::match_target(){
-  uassert(insearch);
-  int nmatches=0;
-  int nmismatches=0;
-  SquareMask targetmask=targetset->getSquares(theGame);
-  SquareMask mask=sourcemask&targetmask;
-  for(squareT square=0;square<64;++square)
-    if(mask.member(square)){
-      if(compareSourceTarget(square))
-	++nmatches;
-      else
-	++nmismatches;
-      if(nmatches>matchrange->max) return false;
-      if(nmismatches>mismatchrange->max) return false;
-    }
-  if (!matchrange->valid(nmatches))return false;
-  if(!mismatchrange->valid(nmismatches))return false;
-  return true;
-};
-
-bool EchoSquareSpec::compareSourceTarget(squareT square){
-  uassert(square_valid(square));
-  pieceT sourcepiece=sourceboard[square];
-  pieceT targetpiece=MarkBoard::piece_at_square(square,theGame);
-  uassert(piece_valid(sourcepiece)&&piece_valid(targetpiece));
-  return sourcepiece==targetpiece;
-}
-
-void EchoSquareSpec::print(){
-  printf("<%s",thisclass());
-    printf(" Match: ");
-  matchrange->print();
-  printf(" Mismatch: ");
-  mismatchrange->print();
-  if(sourceset){
-    printf("\n");
-    indent();
-    tab();
-    printf("sourceset: ");
-    sourceset->print();
-    unindent();
-  }
-  if(targetset){
-    printf("\n");
-    indent();
-    tab();
-    printf("targetset: ");
-    targetset->print();
-    unindent();
-  }
-}
-
-
-
Index: src/cql/echotransformspec.cpp
===================================================================
--- src/cql/echotransformspec.cpp	(revision 2842)
+++ src/cql/echotransformspec.cpp	(working copy)
@@ -1,43 +1 @@
-#include "node.h"
-EchoTransformSpec::EchoTransformSpec(vector<Transform*>ts, EchoSpec*s){
-  uassert(ts.size()&&s);
-  transforms=ts;
-  spec=s;
-}
 
-void EchoTransformSpec::print(){
-  int ntransforms=transforms.size();
-  printf("<%s ntransforms: %d",thisclass(),ntransforms);
-  for(int i=0;i<ntransforms;++i){
-    auto t=transforms[i];
-    printf("\n");indent();tab();
-    printf("Transform %d of %d: ",i,ntransforms);
-    t->print();
-    unindent();
-  }
-  printf("\n");indent();tab();
-  printf("Spec:");
-  spec->print();
-  printf(" EchoTransformSpec>");
-}
-
-bool EchoTransformSpec::match_target(){
-  matchedTransform=NULL;
-  for(Transform* t : transforms)
-    if (spec->match_target(t)){
-      matchedTransform=t;
-      return true;
-    }
-  return false;
-}
-  
-void EchoTransformSpec::start_new_search(Game*game){
-  EchoSpec::start_new_search(game);
-  uassert(insearch&&game==theGame);
-  spec->start_new_search(game);
-}
-
-void EchoTransformSpec::end_search(){
-  spec->end_search();
-  EchoSpec::end_search();
-}
Index: src/cql/elonode.cpp
===================================================================
--- src/cql/elonode.cpp	(revision 2842)
+++ src/cql/elonode.cpp	(working copy)
@@ -1,37 +1 @@
-#include "node.h"
-EloNode::EloNode(Range* r,colorT c):range{r},color{c}{
-  uassert(r&&range,"elonode internal");
-  uassert(color==WHITE||color==BLACK||color==NOCOLOR,"playernode color");
-}
 
-bool EloNode::match_count(Game*game,NumValue*value){
-  int maxelo=0;
-  int whiteelo=game->GetWhiteElo();
-  int blackelo=game->GetBlackElo();
-  bool matched=false;
-  if( (color==WHITE||color==NOCOLOR)
-      && range->valid(whiteelo)){
-    matched=true;
-    maxelo=std::max(maxelo,whiteelo);
-  }
-  if ((color==BLACK||color==NOCOLOR)
-      && range->valid(blackelo)){
-    matched=true;
-    maxelo=std::max(maxelo,whiteelo);
-  }
-  if(!matched)return false;
-  *value=(NumValue)maxelo;
-  return true;
-}
-
-bool EloNode::match_game(Game*game){
-  NumValue n= -1;
-  return match_count(game,&n);
-}
-
-void EloNode::print(){
-  printf("<%s %s",thisclass(),color_string(color));
-  range->print();
-  printf(">");
-}
-  
Index: src/cql/eventnode.cpp
===================================================================
--- src/cql/eventnode.cpp	(revision 2842)
+++ src/cql/eventnode.cpp	(working copy)
@@ -1,16 +1 @@
-#include "node.h"
-EventNode::EventNode(const char* n):name{n}{
-  uassert(n&&name,"eventnode internal");
-}
 
-bool EventNode::match_game(Game*game){
-  char* event=game->GetEventStr();
-  if(event&&strstr(event,name))
-    return true;
-  return false;
-}
-  
-void EventNode::print(){
-  printf("<%s %s>",thisclass(),name);
-}
-  
Index: src/cql/existsnode.cpp
===================================================================
--- src/cql/existsnode.cpp	(revision 2842)
+++ src/cql/existsnode.cpp	(working copy)
@@ -1,66 +1 @@
-#include "node.h"
-ExistsNode::ExistsNode(SquareVariable*v, SetBase*trgt, vector<Node*>nodes){
-  uassert(v&&v->isUnbound(),"existsnode, internal");
-  variable=v;
-  target=trgt;
-  uassert(nodes.size(),"Expected nonzero number of nodes");
-  for(Node*np: nodes){
-    uassert(np,"internal existsnode");
-    MFilter * mf=dynamic_cast<MFilter*>(np);
-    uassert(mf,"ExistsNode: unexpected non-mfilter");
-    filters.push_back(mf);
-  }
-  //possibly check none of the mfilters is free in variable here
-}
 
-void ExistsNode::print(){
-  printf("<%s : variable: ",thisclass());
-  variable->print();
-  if(target){
-    printf("\n");indent();tab();
-    printf("target: ");
-    target->print();
-    unindent();
-  }
-  printf(" %lu filters: ",filters.size());
-    for(int i=0;i<filters.size();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("<%d of %lu: ",i,filters.size());
-    filters[i]->print();
-    unindent();
-  }
-  printf(" %s> ",thisclass());
-}
-
-SquareMask ExistsNode::getSquares(Game*game){
-  SquareMask ret;
-  SquareMask targetmask;
-  if(target) targetmask=target->getSquares(game);
-  else targetmask=SquareMask::all();
-  for(int sq=0;sq<64;++sq)
-    if(targetmask.member(sq)&&match_filters(sq,game))
-      ret.insert(sq);
-  return ret;
-}
-      
-    
-bool ExistsNode::match_filters(squareT square, Game* game){
-  uassert(square_valid(square)&&filters.size());
-  uassert(variable->isUnbound(),"ExistsNode: Attempting to match a square but am bound");
-  variable->bindSquare(square);
-  for(MFilter* filter:filters)
-    if(!filter->match_position(game)){
-      variable->unbind();
-      return false;
-    }
-  variable->unbind();
-  return true;
-}
-
-vnode ExistsNode::children(){
-  vnode v{filters.begin(),filters.end()};
-  if(target) v.push_back(target);
-  return v;
-}
Index: src/cql/extensionnode.cpp
===================================================================
--- src/cql/extensionnode.cpp	(revision 2842)
+++ src/cql/extensionnode.cpp	(working copy)
@@ -1,49 +1 @@
-#include "node.h"
-void ExtensionNode::print(){
-  printf("<%s>",thisclass());
-}
 
-bool ExtensionNode::match_position(Game*game){
-  char buffer[5000];
-  char*current=buffer;
-  vector<simpleMoveT*>moves=MarkBoard::getLegalMoves(game);
-  current+=sprintf(current,"Nlegal: %d ",(int)(moves.size()));
-  for (int i=0;i<moves.size();++i){
-    auto smt=moves[i];
-    squareT fromsq=smt->from;
-    squareT tosq=smt->to;
-    char*fromname=square_to_string(fromsq);
-    char*toname=square_to_string(tosq);
-    current+=sprintf(current,"%d: %s-%s; ",i,fromname,toname);
-  }
-   MarkBoard::gameAppendComment(game,buffer);
-   return true;
-}  
-    
-		   
-
-// bool ExtensionNode::match_position(Game*game){
-//   char buffer[1000];
-//   buffer[0]=0;
-//   if(game->GetCurrentPly()==0)
-//     sprintf(buffer,"STARTGAME");
-//   else{
-//     moveT* prev=game->CurrentMove->prev;
-//     if(!prev)
-//       sprintf(buffer,"NULL");
-//     else if (prev->marker==START_MARKER)
-// 	sprintf(buffer,"STARTMARKER");
-//     else {
-//       simpleMoveT* smt= &(prev->moveData);
-//       squareT fromsq=smt->from;
-//       squareT tosq=smt->to;
-//       char*fromname=square_to_string(fromsq);
-//       char*toname=square_to_string(tosq);
-//       sprintf(buffer,"Prev: %s-%s",fromname,toname);
-//     }
-//   }
-//   MarkBoard::gameAppendComment(game,buffer);
-//   return true;
-// }
-      
-  
Index: src/cql/filename.cpp
===================================================================
--- src/cql/filename.cpp	(revision 2842)
+++ src/cql/filename.cpp	(working copy)
@@ -1,57 +1 @@
-#include "node.h"
-bool filename_is_pgn(const char*filename){
-  const char*ext=filename_extension(filename);
-  if(!ext)return false;
-  return !strcmp(ext,".pgn")||!strcmp(ext,".PGN");
-}
 
-bool filename_is_cql(const char* filename){
-  const char*ext=filename_extension(filename);
-  if(!ext)return false;
-  return !strcmp(ext,".cql")||!strcmp(ext,".CQL");
-}
-  
-const char* filename_extension(const char* filename){
-  uassert(filename,"bad filename to filename_extension");
-  const char* last=strrchr(filename,'.');
-  return last;
-}
-
-const char* filename_stem(const char*name){
-  const char* noprefix=filename_trim_path_prefix(name);
-  const char* noext=filename_trim_extension(noprefix);
-  return noext;
-}
-
-const char* filename_trim_path_prefix(const char*name){
-  uassert(name);
-  const char* ret=name;
-  ret=filename_trim_last(ret,'\\');
-  ret=filename_trim_last(ret,':');
-  ret=filename_trim_last(ret,'/');
-  uassert(ret&&strlen(ret)>0,"unable to obtain filename from string",name);
-  return ret;
-}
-
-const char* filename_trim_last(const char* name, char c){
-  uassert(name,"null trim last arg");
-  const char * ret=strrchr(name,c);
-  if(ret) return ret+1;
-  return name;
-}
-
-const char* filename_trim_extension(const char* name){
-  uassert(name,"bad arg to trim_ext");
-  const char* ext=filename_extension(name);
-  if(!ext)return name;
-  char buffer[200];
-  uassert(strlen(name)<sizeof(buffer)-5,"too long name trim");
-  sprintf(buffer,"%s",name);
-  char* last=strrchr(buffer,'.');
-  uassert(last,"internal trimext");
-  *last=0;
-  uassert(!filename_extension(buffer),"multiple . in filename not supported for name: ",name);
-  return util::copy(buffer);
-}
-
-  
Index: src/cql/forallnode.cpp
===================================================================
--- src/cql/forallnode.cpp	(revision 2842)
+++ src/cql/forallnode.cpp	(working copy)
@@ -1,59 +1 @@
-#include "node.h"
-ForallNode::ForallNode(SquareVariable*v,SetBase*t, vector<Node*>nodes){
-  uassert(v&&v->isUnbound(),"existsnode, internal");
-  variable=v;
-  target=t;
-  for(Node*np: nodes){
-    uassert(np,"internal existsnode");
-    MFilter * mf=dynamic_cast<MFilter*>(np);
-    uassert(mf,"AllsNode: unexpected non-mfilter");
-    filters.push_back(mf);
-  }
-  //possibly check none of the mfilters is free in variable here
-}
 
-void ForallNode::print(){
-  printf("<%s : variable: ",thisclass());
-  variable->print();
-  if(target){
-    printf(" : ");
-    target->print();
-  }
-  printf(" %lu filters: ",filters.size());
-    for(int i=0;i<filters.size();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("<%d of %lu: ",i,filters.size());
-    filters[i]->print();
-    unindent();
-  }
-  printf(" %s> ",thisclass());
-}
-
-bool ForallNode::match_position(Game*game){
-  uassert(variable->isUnbound());
-  SquareMask targetmask;
-  if(target) targetmask=target->getSquares(game);
-  else targetmask = ~targetmask;
-  if(targetmask.empty())return true;
-  for(squareT square=0;square<64;++square)
-    if(targetmask.member(square)){
-      if(variable->isBound()) variable->unbind();
-      variable->bindSquare(square);
-      for(MFilter* filter:filters)
-	if(!filter->match_position(game)){
-	  variable->unbind();
-	  return false;
-	}
-    }
-  variable->unbind();
-  return true;
-}
-
-vnode ForallNode::children(){
-  vnode v;
-  if(target) v.push_back(target);
-  v.insert(v.end(),filters.begin(),filters.end());
-  return v;
-}
Index: src/cql/futurenode.cpp
===================================================================
--- src/cql/futurenode.cpp	(revision 2842)
+++ src/cql/futurenode.cpp	(working copy)
@@ -1,65 +1 @@
-#include "node.h"
 
-FutureNode::FutureNode(vector<SeqConstituent*>cs,Range*r,bool isskip,bool allownest):SequenceBase(cs,r,isskip,allownest){
-}
-
-SeqRet FutureNode::compute(HolderConstituent*holder,SeqStack&stack){
-  size_t stacklen=stack.size();
-  uassert(holder,"fncholdererr");
-  MFilter*filter=holder->filter;
-  uassert(filter,"fncfilter");
-  if (!CqlDoNotLinearize && !linearize(filter).empty())
-    return computeLinearize(holder,stack);
-  if(!filter->match_position(game))
-    return SeqRet(false);
-  if(stack.empty())return SeqRet(game,holder->getOffset());
-  auto me=MarkBoard::identity(game);
-  int nchildren=MarkBoard::number_children(game,getSearchVariations());
-  SeqRet best(false);
-  for(int childindex=0;childindex<nchildren;++childindex){
-    MarkBoard::move_to_child(game,childindex);
-    SeqRet sub=SequenceBase::compute(stack); //Why do I need the class qualifier?
-    best=std::max(best,sub);
-    MarkBoard::gameBackup(game);
-  }
-  if(nchildren==0)
-    best=computeNull(stack);
-  uassert(me==MarkBoard::identity(game),"id fail check sequence");
-  if(best.isFalse())return best;
-  best.addParent(game,holder->getOffset());
-  uassert(stack.size()==stacklen,"fnch size");
-  return best;
-}
-
-void FutureNode::notate(SeqRet& ret){
-  if(isSilent())return;
-  uassert(ret.isTrue(),"notate rist");
-  int len=ret.getLength();
-  if(!len)return;
-  moveT*me=MarkBoard::identity(game);
-  moveT*previousid=NULL;
-  uassert(me==ret.getId(0),"notate bad back");
-  char buffer[1000];
-  int positionsseen=0;
-  int positionsexpected=len;
-  if(isSkip()) positionsexpected=(len+1)/2;
-  for(int index=0;index<len;++index){
-    if(previousid){
-      uassert(previousid==MarkBoard::identity(game),"idcheck fail notateoop");
-      moveT*nextid=ret.getId(index);
-      MarkBoard::gameToChild(nextid,game,getSearchVariations());
-    }
-    moveT*thisid=MarkBoard::identity(game);
-    uassert(thisid==ret.getId(index),"idcheck fail notate");
-    int offset=ret.getOffset(index);
-    if(offset>=0){
-      nestRegisterPosition(game);
-      ++positionsseen;
-      sprintf(buffer,"NEXT %d (position %d of %d)",offset+1,positionsseen,positionsexpected);
-      MarkBoard::gameAppendComment(game,buffer);
-    }
-    previousid=thisid;
-  }
-  uassert(MarkBoard::identity(game)==ret.getId(len-1),"bad id check notate");
-  MarkBoard::gameToIdentity(me,game,getSearchVariations());
-}
Index: src/cql/futurestarnode.cpp
===================================================================
--- src/cql/futurestarnode.cpp	(revision 2842)
+++ src/cql/futurestarnode.cpp	(working copy)
@@ -1,75 +1 @@
-#include "node.h"
-FutureStarNode::FutureStarNode(Node*node,Range*r, int depth){
-  uassert(node);
-  filter=dynamic_cast<MFilter*>(node);
-  uassert(filter,"unexpected nonmfilter to futurestartnode");
-  range=r;
-  depthMax=depth;
-}
 
-void FutureStarNode::print(){
-  printf("<%s ",thisclass());
-  if(isSilent())printf("silent ");
-  if(range)range->print();
-  if(depthMax>=0) printf("depthMax: %d",depthMax);
-  printf("\n");indent();tab();
-  filter->print();
-  unindent();
-  printf(">");
-}
-
-bool FutureStarNode::match_count(Game*game,NumValue*value){
-  uassert(range,"If next* is sorted, it requires an explicit range: missing range");
-  if(match_position(game)){
-    *value=(NumValue)(getCount());
-    return true;
-  }
-  return false;
-}
-
-
-bool FutureStarNode::match_position(Game*game){
-  count=0;
-  auto pid=MarkBoard::identity(game);
-  vector<moveT*> ids;
-  compute_counts(game,ids,0);
-  uassert(count==(int)(ids.size()));
-  uassert(pid==MarkBoard::identity(game));
-  if(!range&&!count) return false;
-  if(range&& !range->valid(count)) return false;
-  for(int idindex=0;idindex<count;++idindex){
-    MarkBoard::gameToIdentity(ids[idindex],
-			      game,
-			      getSearchVariations());
-    char buffer[100];
-    sprintf(buffer,"next* %d of %d",idindex+1,count);
-    if(!isSilent())MarkBoard::gameAppendComment(game,buffer);
-  }
-  MarkBoard::gameToIdentity(pid,game,getSearchVariations());
-  return true;
-}
-
-void FutureStarNode::compute_counts(Game*game,vector<moveT*>&ids, int depth){
-  if (depthMax>=0 && depth>depthMax) return;
-  if(!range&&count)return;
-  if(filter->match_position(game)){
-    ++count;
-    ids.push_back(MarkBoard::identity(game));
-    if(!range)return;
-  }
-  int nchildren=MarkBoard::number_children(game,getSearchVariations());
-  for(int child=0;child<nchildren;++child){
-    MarkBoard::move_to_child(game,child);
-    compute_counts(game,ids,depth+1);
-    MarkBoard::gameBackup(game);
-  }
-}
-
-
-
-
-
-  
-
-					  
-  
Index: src/cql/gamesortinfo.cpp
===================================================================
--- src/cql/gamesortinfo.cpp	(revision 2842)
+++ src/cql/gamesortinfo.cpp	(working copy)
@@ -1,53 +1 @@
-#include "node.h"
-#include "gamesortinfo.h"
 
-GameSortInfo::GameSortInfo(string d, vector<SortValue> v){
-  values=v;
-  uassert(!d.empty(),"bad gamesortinfo constructor arg");
-  data=d;
-}
-
-void GameSortInfo::print(){
-  output(stdout);
-}
-
-void GameSortInfo::output(FILE* os)const{
-  fprintf(os,"%s\n\n",data.data());
-}
-
-void GameSortInfo::output(FILE* os, const vector<GameSortInfo>& v){
-  for (const auto gs : v)
-    gs.output(os);
-}
-
-void GameSortInfo::sort(vector<GameSortInfo>& v){
-  if(0){
-    printf("\n\nGSI: got v presort of:\n");
-    for(int i=0;i<v.size();++i){
-      printf("sortinfo value %d is: \n",i);
-      for(auto &w : v[i].values){
-	printf("     ");
-	w.print();
-      }
-      printf("\n");
-    }
-  }
-  std::stable_sort(v.begin(), v.end());
-  if(0){
-    printf("\n\nGSI: got v postsort of:\n");
-    output(stdout,v);
-  }
-
-}
-
-
-bool operator<(const GameSortInfo& a, const GameSortInfo& b){
-  uassert(!a.data.empty()&&!b.data.empty()&&a.values.size()==b.values.size(),"gamesortinfo < internal");
-  int len=(int)(a.values.size());
-  for (int i=0;i<len;i++)
-    if(b.values[i]<a.values[i]) return true;
-    else if (a.values[i]<b.values[i]) return false;
-  return false;
-}
-
-       
Index: src/cql/gamesortinfo.h
===================================================================
--- src/cql/gamesortinfo.h	(revision 2842)
+++ src/cql/gamesortinfo.h	(working copy)
@@ -1,18 +1 @@
-#pragma once
-#include<string>
-using std::string;
-class GameSortInfo{
- public:
-  string data;
-  int gamenumber{0};
-  vector<SortValue> values;
-  const char* thisclass(){return "GameSortInfo";}
-  GameSortInfo(string d, vector<SortValue> values);
-  void print();
-  static void sort(vector<GameSortInfo>&);
-  void output(FILE* ostream) const;
-  static void output(FILE* ostream,const vector<GameSortInfo>&);
-};
 
-bool operator< (const GameSortInfo& a, const GameSortInfo& b);
-
Index: src/cql/holderconstituent.cpp
===================================================================
--- src/cql/holderconstituent.cpp	(revision 2842)
+++ src/cql/holderconstituent.cpp	(working copy)
@@ -1,20 +1 @@
-#include "node.h"
-HolderConstituent::HolderConstituent(MFilter*f){
-  uassert(f,"hc");
-  filter=f;
-}
 
-void HolderConstituent::print(){
-  printf("<%s ",thisclass());
-  filter->print();
-  printf(">");
-}
-
-
-void HolderConstituent::setOffsets(int i){
-  setOffset(i);
-}
-
-bool HolderConstituent::matchesNull(){
-  return false;
-}
Index: src/cql/keywords.cpp
===================================================================
--- src/cql/keywords.cpp	(revision 2842)
+++ src/cql/keywords.cpp	(working copy)
@@ -1,130 +1 @@
-#include "node.h"
-bool KeywordToken::isReserved(const char* s){
-  static const vector<const char*> reserved{
-    "all",
-    "ancestor",
-      "any",
-      "attack",
-      "attacks",
-      "beginvariation",
-      "between",
-      "black",
-      "btm",
-      "check",
-      "cql",
-      "comment",
-      "countsquares",
-      "depth",
-      "descendant",
-      "dihedral",
-      "echodihedral",
-      "echoflip",
-      "echoflipdihedral",
-      "echoflipvertical",
-      "echofliphorizontal",
-      "echorotate45",
-      "echorotate90",
-      "echoshift",
-      "echoshifthorizontal",
-      "echoshiftvertical",
-      "elo",
-      "enpassant",
-      "enpassantsquare",
-      "event",
-      "extension",
-      "flip",
-      "flipcolor",
-      "flipdihedral",
-      "fliphorizontal",
-      "flipvertical",
-      "from",
-      "gamenumber",
-      "hascomment",
-      "in",
-      "initial",
-      "input",
-      "lcamax",
-      "lcasource",
-      "lcasubstring",
-      "lcasum",
-      "lcatarget",
-      "legal",
-      "mainline",
-      "match",
-      "matchcount",
-      "mate",
-      "max",
-      "min",
-      "mismatch",
-      "move",
-      "movenumber",
-      "nestban",
-      "next",
-      "next2",
-      "next*",
-      "not",
-      "null",
-      "number",
-      "on",
-      "or",
-      "origin",
-      "output",
-      "pgn",
-      "piece",
-      "player",
-      "power",
-      "powerdifference",
-      "previous",
-      "previous2",
-      "previous*",
-      "primary",
-      "promote",
-      "ray",
-      "relation",
-      "result",
-      "rotate45",
-      "rotate90",
-      "secondary",
-      "shift",
-      "shifthorizontal",
-      "shiftvertical",
-      "silent",
-      "site",
-      "sort",
-      "sourcesquares",
-      "square",
-      "stalemate",
-      "targetsquares",
-      "terminal",
-      "to",
-      "tomove",
-      "variation",
-      "variations",
-      "white",
-      "wtm",
-      "year",
-      "."
-	};
-  
-  uassert(s,"reserved, internal");
-  if(*s==':')++s;
-  for(const char* k : reserved)
-    if(strcmp(k,s)==0) return true;
-  return false;
-}
 
-bool KeywordToken::eq(const char*s){
-  uassert(*s,"eq: internal");
-  if(*s==':') s++;
-  return strcmp(s,value)==0;
-}
-
-KeywordToken::KeywordToken(const char*x){
-  uassert(isReserved(x),"Cannot create keyword from unreserved name: ",x);
-  if(*x==':')++x;
-  value=x;
-}
-
-void KeywordToken::print(){
-  printf("<%s: %s %s>",thisclass(),locationString(), value);
-}
Index: src/cql/lexer.cpp
===================================================================
--- src/cql/lexer.cpp	(revision 2842)
+++ src/cql/lexer.cpp	(working copy)
@@ -1,345 +1 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include "token.h"
-#include "node.h"
-#include "lexer.h"
 
-bool lexFile(const char*filename, vector<Token*>*tokens){
-  FILE * file=fopen(filename,"r");
-  if (file==NULL){
-    fprintf(stderr,"Could not open file: %s\n",filename);
-    exit(1);
-  }
-  return lexStream(file,NULL,tokens);
-  fclose(file);
-  return true;
-}
-
-int rsIndex;
-bool lexStream(FILE*file, char*buffer, vector<Token*>*tokens){
-  char* current = NULL;
-  rsIndex = 0;
-  Token::incrementLine();
-  while(true){
-    // kludge alert
-    if (file) current=readstring(file);
-    else if (buffer) current=readstring(buffer);
-    else uassert(false,"Could not find syntax");
-
-    if(current==NULL) return true;
-    Token* token=makeToken(current);
-    if(!token){
-      fprintf(stderr,"Unable to process string: %s\n",current);
-      uassert(false,"Syntax error");
-    }
-    tokens->push_back(token);
-  }
-  return true;
-}
-
-char * readstring(FILE * file){
-  char buffer[1000];
-  int c;
-  int nextchar=0;
-  while ((c=fgetc(file))>=0){
-    Token::incrementChar();
-    if(c=='\n')Token::incrementLine();
-    if (isspace(c)) continue;
-    else if (c==';'){
-      while((c=fgetc(file))>=0){
-	Token::incrementChar();
-	if (c=='\n') {Token::incrementLine();break;}
-      }
-      if (c<0) break;
-      else continue;
-    }
-    else if (c=='"'){
-      Token::incrementChar();
-      buffer[nextchar++]=c;
-      uassert(nextchar<sizeof(buffer)-2,"Token too long");
-      while ((c=fgetc(file))>=0){
-	uassert(c>0,"Unexpected EOF in quoted string");
-	uassert(c!='\n',"Unexpected newline inside quoted string");
-	uassert(nextchar<sizeof(buffer)-2,"Token too long here");
-	buffer[nextchar++]=c;
-	Token::incrementChar();
-	if (c=='"'){
-	  buffer[nextchar++]=0;
-	  return util::copy(buffer);
-	} // if c is the trailing quote
-      } // end read the quote
-    }// end beging the quote
-    else if (c=='(') return "(";
-    else if (c==')') return ")";
-    else if (c=='{') return "{";
-    else if (c=='}') return "}";
-    else if (c=='*') return "*";
-    else if (c=='+') return "+";
-    else if (c=='?') return "?";
-    else {
-      ungetc(c,file);
-      if(c=='\n')
-	Token::decrementLine();
-      else
-	Token::decrementChar();
-      break;
-    }
-  }
-  if (c<0) return NULL;
-  while((c=fgetc(file))>=0){
-    if(c=='\n')Token::incrementLine();
-    else
-      Token::incrementChar();
-    if (isspace(c)||c=='('||c==')'||c=='{'||c=='}'||c=='*'||c=='+'||c=='?'){
-      ungetc(c,file);
-      if(c=='\n') Token::decrementLine();
-      else
-	Token::decrementChar();
-      buffer[nextchar++]=0;
-      return util::copy(buffer);
-    }
-    else if (nextchar>500){
-      fprintf(stderr,"token too long: readstring");
-      exit(1);
-    }
-    else buffer[nextchar++]=c;
-  }
-  if (nextchar==0)
-    return NULL;
-  buffer[nextchar++]=0;
-  return util::copy(buffer);
-}
-
-
-int bgetc(char *buffer) {
-  int c = buffer[rsIndex++];
-  if (c) return c;
-  else return EOF;
-}
-
-int bungetc(int c, char *buffer) {
-  rsIndex--;
-  return c;
-}
-
-char * readstring(char * syntax){
-  char buffer[1000];
-  int c;
-  int nextchar=0;
-  while ((c=bgetc(syntax))>=0){
-    Token::incrementChar();
-    if(c=='\n')Token::incrementLine();
-    if (isspace(c)) continue;
-    else if (c==';'){
-      while((c=bgetc(syntax))>=0){
-	Token::incrementChar();
-	if (c=='\n') {Token::incrementLine();break;}
-      }
-      if (c<0) break;
-      else continue;
-    }
-    else if (c=='"'){
-      Token::incrementChar();
-      buffer[nextchar++]=c;
-      uassert(nextchar<sizeof(buffer)-2,"Token too long");
-      while ((c=bgetc(syntax))>=0){
-	uassert(c>0,"Unexpected EOF in quoted string");
-	uassert(c!='\n',"Unexpected newline inside quoted string");
-	uassert(nextchar<sizeof(buffer)-2,"Token too long here");
-	buffer[nextchar++]=c;
-	Token::incrementChar();
-	if (c=='"'){
-	  buffer[nextchar++]=0;
-	  return util::copy(buffer);
-	} // if c is the trailing quote
-      } // end read the quote
-    }// end beging the quote
-    else if (c=='(') return "(";
-    else if (c==')') return ")";
-    else if (c=='{') return "{";
-    else if (c=='}') return "}";
-    else if (c=='*') return "*";
-    else if (c=='+') return "+";
-    else if (c=='?') return "?";
-    else {
-      bungetc(c,syntax);
-      if(c=='\n')
-	Token::decrementLine();
-      else
-	Token::decrementChar();
-      break;
-    }
-  }
-  if (c<0) return NULL;
-  while((c=bgetc(syntax))>=0){
-    if(c=='\n')Token::incrementLine();
-    else
-      Token::incrementChar();
-    if (isspace(c)||c=='('||c==')'||c=='{'||c=='}'||c=='*'||c=='+'||c=='?'){
-      bungetc(c,syntax);
-      if(c=='\n') Token::decrementLine();
-      else
-	Token::decrementChar();
-      buffer[nextchar++]=0;
-      return util::copy(buffer);
-    }
-    else if (nextchar>500){
-      uassert(false,"token too long: readstring");
-    }
-    else buffer[nextchar++]=c;
-  }
-  if (nextchar==0)
-    return NULL;
-  buffer[nextchar++]=0;
-  return util::copy(buffer);
-}
-
-Token* makeToken(char* val){
-  char*current=val;
-  uassert(current&&strlen(current),"makeToken bad arg");
-  uassert(strlen(val)<100,"Max token size too large");
-  Token* t=NULL;
-  if(!t) t=match_LParen(current);
-  if(!t) t=match_RParen(current);
-  if(!t) t=match_LBrace(current);
-  if(!t) t=match_RBrace(current);
-  if(!t) t=match_Star(current);
-  if(!t) t=match_Plus(current);
-  if(!t) t=match_QuestionMark(current);
-  if(!t) t=match_keyword(current);
-  if(!t) t=match_int(current);
-  if(!t) t=match_piecedesignator(current);
-  if(!t) t=match_quotedstring(current);
-  if(!t) t=match_name(current);
-  if (t==NULL){
-    //If val has a '.' in it, then it is likely due to a wrong CQL version:
-    uassert(current==val,"makeToken: logic");
-    for(current=val;*current;++current)
-	uassert(*current!='.',
-		"A lexer error involving a token with a '.' in it was observed. The '.' means 'any' since version 5.2. Use '_' to denote an empty square: ",
-		val);
-    uassert(false,"Lexer: Unknown or not understood sequence of characters: ",val);
-  } // if (t==NULL)
-  uassert(t,"make_token: internal");
-  return t;
-}
-
-Token* match_Star(char*v){
-  uassert(v,"match_Star internal");
-  if (*v=='*') return new StarToken;
-  return NULL;
-}
-Token* match_Plus(char*v){
-  uassert(v);
-  if (*v=='+') return new PlusToken;
-  return NULL;
-}
-Token* match_QuestionMark(char*v){
-  uassert(v);
-  if (*v=='?') return new QuestionMarkToken;
-  return NULL;
-}
-
-Token* match_Bar(char*v){
-  uassert(v);
-  if (*v=='|') return new BarToken;
-  return NULL;
-}
-
-Token* match_LParen(char*v){
-  uassert(v);
-  if(*v=='(') return new LParenToken;
-  return NULL;
-}
-
-Token* match_RParen(char*v){
-  uassert(v);
-  if(*v==')') return new RParenToken;
-  return NULL;
-}
-
-Token* match_LBrace(char*v){
-  uassert(v);
-  if(*v=='{') return new LBraceToken;
-  return NULL;
-}
-
-Token* match_RBrace(char*v){
-  uassert(v);
-  if(*v=='}') return new RBraceToken;
-  return NULL;
-}
-
-Token* match_LessThan(char*v){
-  uassert(v);
-  if(*v=='<') return new LessThanToken;
-  return NULL;
-}
-
-Token* match_GreaterThan(char*v){
-  uassert(v);
-  if(*v=='>') return new GreaterThanToken;
-  return NULL;
-}
-
-
-Token* match_int(char*val){
-  int tokval=0;
-  if(util::signedIntValue(val,&tokval))
-    return new IntToken(tokval);
-  return NULL;
-}
-  
-  
-Token* match_keyword(char*input){
-  if(!KeywordToken::isReserved(input))return NULL;
-  return new KeywordToken(input);
-}
-
-bool match_letterdigits(char*input){
-  uassert(input);
-  char*current=input;
-  while(char c=*current++)
-    if(!isalnum(c))return false;
-  return true;
-}
-
-Token* match_name(char*input){
-  uassert(input);
-  char*current=input;
-  while(char c=*current++)
-    if(!isalnum(c)&&
-       c!='.'&&
-       c!='/'&&
-       c!='-'&&
-       c!='_')return NULL;
-  return new NameToken(input);
-}
-
-bool match_letterdigit(char**inputp,char * ch){
-  char*current=*inputp;
-  uassert(current);
-  if(isalnum(current[0])){
-    *inputp= *inputp+1;
-    return true;
-  }
-  return false;
-}
-  
-Token* match_quotedstring(char* v){
-  if (!v) return NULL;
-  //  if(1)printf("match_quotedstring called on v: %s\n",v);
-  int vlen=(int)(strlen(v));
-  if (vlen<=2)return NULL;
-  if(v[0]!='"'||v[vlen-1]!='"')return NULL;
-  uassert(vlen<500,"string token too long: 500 character limit");
-  char buffer[502];
-  sprintf(buffer,"%s",v);
-  uassert(buffer[vlen-1]=='"',"internal");
-  buffer[vlen-1]=0;
-  char*result=buffer+1;
-  uassert(strlen(result)==vlen-2);
-  return new QuotedStringToken(util::copy(result));
-}
Index: src/cql/lexer.h
===================================================================
--- src/cql/lexer.h	(revision 2842)
+++ src/cql/lexer.h	(working copy)
@@ -1,46 +1 @@
-#pragma once
-#include "node.h"
 
-bool lexFile(const char*filename, vector<Token*>*tokens);
-bool lexStream(FILE*file,char*buffer,vector<Token*>*tokens);
-char * readstring(FILE * file);
-char * readstring(char * buffer);
-Token* makeToken(char* val);
-PieceDesignatorToken* match_piecedesignator(char* input);
-bool match_piecespecifier(char**inputp,vector<PieceToken*>*pieces);
-PieceToken* match_singlepiecespecifier(char**inputp);
-bool match_singlepiecespecifierplus(char**input,vector<PieceToken*>*piecesp);
-PieceToken* match_simplepiecespecifier(char**inputp);
-bool match_compoundpiecespecifier(char**inputp,vector<PieceToken*>*piecesp);
-bool match_alphanums(char**inputp, char* result, int maxlength);
-Token* match_keyword(char*input); 
-bool match_char(char**input,char c);
-VariableToken* match_variable(char**input);
-void match_variables(char**input,vector<VariableToken*>*variablesp);
-VariableToken* match_variable(char*input);
-bool match_letterdigit(char**inputp,char * ch);
-bool match_letterdigits(char*input);
-bool match_squarespecifier(char**inputp, vector<SquareToken*>*squaresp);
-SquareToken* match_square(char**inputp);
-bool match_commasquares(char**input,vector<SquareToken*>*squaresp);
-bool match_file(char**inputp,int * result);
-bool match_rank(char**inputp,int * result);
-SquareToken* match_blocksquarespecifier(char**inputp);
-bool match_compoundsquarespecifier(char**inputp,vector<SquareToken*>*squaresp);
-bool match_files(char**inputp,int*min,int *max);
-bool match_filerange(char**inputp,int*min,int*max);
-bool match_ranks(char**inputp,int*min,int *max);
-bool match_rankrange(char**inputp,int*min,int*max);
-Token* match_int(char*val);
-Token* match_Bar(char*v);
-Token* match_Star(char*v);
-Token* match_QuestionMark(char*v);
-Token* match_Plus(char*v);
-Token* match_LParen(char*v);
-Token* match_RParen(char*v);
-Token* match_LBrace(char*v);
-Token* match_RBrace(char*v);
-Token* match_LessThan(char*v);
-Token* match_GreaterThan(char*v);
-Token* match_name(char*input);
-Token* match_quotedstring(char*v);
Index: src/cql/linearize.cpp
===================================================================
--- src/cql/linearize.cpp	(revision 2842)
+++ src/cql/linearize.cpp	(working copy)
@@ -1,86 +1 @@
-#include "node.h"
- 
-SeqRet FutureNode::computeLinearize(HolderConstituent* holder, SeqStack&stack){
-  size_t stacklen=stack.size();
-  uassert(holder,"computerLinearize internal");
-  MFilter*filter=holder->filter;
-  uassert (filter, "computeLinearize: bad filter");
-  vector<simpleMoveT*>allmoves=MarkBoard::getMoves(game,getSearchVariations());
-  auto me=MarkBoard::identity(game);
-  int nchildren=MarkBoard::number_children(game,getSearchVariations());
-  uassert(allmoves.size()==nchildren,"moves/nchildren mismatch: computeLinearize");
-  vector<MoveFutureNode*>movefutures=linearize(filter);
-  for(auto movefuture : movefutures){
-    uassert(movefuture->requiredMove==NULL,"computeLinearize rM");
-    uassert(movefuture->requiredIndex=-1,"computeLinearize rI");
-  }
-  uassert(!movefutures.empty(),"unexpected emptymovefutures");
-  SeqRet best(false);
-  for (int childindex=0;childindex<nchildren;++childindex){
-    /* Set the moveIndex of all the MoveFutureNodes in the current filter*/
-    simpleMoveT* currentmove=allmoves.at(childindex);
-    for (auto movefuture: movefutures){
-      uassert(movefuture->requiredMove==NULL,"cLmfrbmn");
-      movefuture->requiredMove=currentmove;
-      uassert(movefuture->requiredIndex== -1,"cLmfrI");
-      movefuture->requiredIndex=childindex;
-  }
-    /* Now match the position and restore the old moveIndex values*/
-    bool matchedcurrentfilter=filter->match_position(game);
-    for (auto movefuture: movefutures){
-      uassert(movefuture->requiredMove==currentmove,"cLmfrbmn2");
-      movefuture->requiredMove=NULL;
-      uassert(movefuture->requiredIndex== childindex,"cLmfrI2");
-      movefuture->requiredIndex=-1;
-  }
-    /*now continue as usual for this childindex*/
-    uassert(me==MarkBoard::identity(game),"identity mismatch computeLinear");
-    if(matchedcurrentfilter){
-    // Now the current filter is a match, but we just look the child'th child...
-      MarkBoard::move_to_child(game,childindex);
-      // should do error checking here to make sure this child was reached from the right move
-      SeqRet sub=SequenceBase::compute(stack);
-      best=std::max(best,sub);
-      MarkBoard::gameBackup(game);
-    } // if matchedcurrentfilter, inside the for(..child...)loop
-  } // end the for(...child...) loop
-  if(nchildren==0){
-    uassert(best.isFalse(),"computeLinear internal best");
-    bool defaultmatch=filter->match_position(game);
-    if(defaultmatch)best=computeNull(stack);
-  }
-  uassert(me==MarkBoard::identity(game),"id fail check sequence");
-  if(best.isFalse())return best;
 
-  best.addParent(game,holder->getOffset());
-  uassert(stack.size()==stacklen,"computeLinear stacksize");
-  return best;
-  
-}
-
-vector<MoveFutureNode*> FutureNode::linearize(Node* filter){
-  uassert(filter!=NULL, "linearize null filter");
-  vector<MoveFutureNode*> ret;
-  MoveFutureNode* movefuturefilter=dynamic_cast<MoveFutureNode*>(filter);
-  MovePastNode* movepastfilter=dynamic_cast<MovePastNode*>(filter);
-  EchoNode* echofilter=dynamic_cast<EchoNode*>(filter);
-  SequenceBase* seqfilter=dynamic_cast<SequenceBase*>(filter);
-  FutureStarNode* futurestarfilter=dynamic_cast<FutureStarNode*>(filter);
-  PastStarNode* paststarfilter=dynamic_cast<PastStarNode*>(filter);
-  if (seqfilter ||
-      futurestarfilter ||
-      paststarfilter||
-      echofilter ||
-      movepastfilter) return ret;
-  if (movefuturefilter)
-    {ret.push_back(movefuturefilter);
-      return ret;}
-  vector<Node*> children=filter->children();
-  for (auto child:children){
-    vector<MoveFutureNode*> childlinear=linearize(child);
-    for(auto childm : childlinear)
-      myinsert(ret,childm);
-  }
-  return ret;
-}
-    
Index: src/cql/longestcommonsubstring.cpp
===================================================================
--- src/cql/longestcommonsubstring.cpp	(revision 2842)
+++ src/cql/longestcommonsubstring.cpp	(working copy)
@@ -1,47 +1 @@
-#include <vector>
-using std::vector;
-//void printarray(int m, int n, vector<vector<int>>arr);
 
-int longestCommonSubstring(std::vector<int>a, std::vector<int>b, int* astart, int*bstart){
-  int m=(int)(a.size());
-  int n=(int)(b.size());
-  if(!m|!n)return 0;
-  /* lcsuff[i][j] is the longest common suffix in a[0..i]
-      and b[0..j]
-  */
-  std::vector<std::vector<int>>lcsuff;
-  lcsuff.resize(m);
-  for(int i=0;i<m;++i) lcsuff[i].resize(n);
-
-  for(int i=0;i<m;++i)for(int j=0;j<n;++j)lcsuff[i][j]=-1000;
-  for(int j=0;j<n;++j) lcsuff[0][j]= a[0]==b[j]?1:0;
-  for(int i=0;i<m;++i) lcsuff[i][0]= a[i]==b[0]?1:0;
-  for(int i=1;i<m;++i)
-    for(int j=1;j<n;++j)
-      if(a[i]==b[j])
-	lcsuff[i][j]=lcsuff[i-1][j-1]+1;
-      else
-	lcsuff[i][j]=0;
-  int longest=-1;
-  int longi=-1;
-  int longj=-1;
-  for(int i=0;i<m;++i)
-    for(int j=0;j<n;++j){
-      int x=lcsuff[i][j];
-      if(x>longest){
-	longest=x;
-	longi=i;
-	longj=j;
-      }
-    }
-  *astart=longi-longest+1;
-  *bstart=longj-longest+1;
-  return longest;
-}
-      
-// void printarray(int m, int n, vector<vector<int>>arr){
-//   for(int i=0;i<m;i++)
-//     for(int j=0;j<m;j++)
-//       printf("i: %d j: %d arr[i][j]: %d\n",i,j,arr[i][j]);
-// }
-	  
Index: src/cql/markboard.cpp
===================================================================
--- src/cql/markboard.cpp	(revision 2842)
+++ src/cql/markboard.cpp	(working copy)
@@ -1,112 +1 @@
-#include "util.h"
-#include "markboard.h"
-#include "variable.h"
 
-MarkBoard * MarkBoard::globalMarkBoard=NULL;
-
-MarkBoard::MarkBoard(Game*game){
-  initialize(game);
-  Variable::unbindTags();
-}
-
-//This should be called by external routines to begin marking a game.
-
-void MarkBoard::mark(Game*game){
-  if (!globalMarkBoard) globalMarkBoard=new MarkBoard(game);
-  globalMarkBoard->initialize(game);
-}
-
-MarkBoard*MarkBoard::global(){
-  return globalMarkBoard;
-}
-
-bool MarkBoard::myIsNullMove(simpleMoveT* sm){
-  uassert(sm,"myIsNullMove: null parameter");
-  return isNullMove(sm);
-}
-
-void MarkBoard::print(){
-  printf("%s stacksize: %lu printing the markmap\n",
-	 thisclass(),
-	 stack.size());
-
-  map.print();
-  printf("MarkBoard: Printing the underlying board:\n");
-  util::my_dump_board(game->GetCurrentPos()->GetBoard());
-}
-
-void MarkBoard::verify(){
-  map.verify(game);
-}
-
-void MarkBoard::MoveForward(){
-  verify();
-  pushstate();
-  
-  simpleMoveT * currentmove=game->GetCurrentMove();
-  uassert(currentmove!=NULL);
-  squareT from=currentmove->from;
-  squareT to=currentmove->to;
-  bool isnull=myIsNullMove(currentmove);
-  uassert(isnull || (square_valid(from)&&square_valid(to)&&from!=to),"mark forward internal");
-  Position * position=game->GetCurrentPos();
-  pieceT * board=position->GetBoard();
-  colorT color=position->GetToMove();
-  map.make_move(from,to,board,color);
-  game->MoveForward();
-  verify();
-}
-    
-void MarkBoard::MoveBackup(){ 
-  popstate();
-  game->MoveBackup();
-  while(atVarStart(game)&&inVariation(game))
-    game->MoveExitVariation();
-  verify();
-}
-  
-
-void MarkBoard::initialize(Game * newgame){
-  game=newgame;
-  uassert(game->GetCurrentPly()==0,"expected game at start in markboard");
-  stack.clear();
-  map.initialize(newgame);
-}
-
-void MarkBoardMap::initialize(Game*game){
-  int nmarks=0;
-  for(markT& m : squares_to_marks)
-    m=-1;
-  for(int& i : marks_to_squares)
-    i=65;
-  uassert(game->GetCurrentPly()==0,"expected game at start in markboard2");
-  pieceT * board=game->GetCurrentPos()->GetBoard();
-  for (int sq=0;sq<64;++sq)
-    if (board[sq]!=EMPTY){
-      uassert(mark_valid(nmarks));
-      squares_to_marks[sq]=nmarks;
-      marks_to_squares[nmarks]=sq;
-      nmarks++;
-    }
-    else // square is empty
-      squares_to_marks[sq]=-1;
-  verify(game);
-}
-
-void MarkBoard::popstate(){
-  uassert(!stack.empty());
-  map=stack.back();
-  stack.pop_back();
-}
-
-void MarkBoard::pushstate(){
-  stack.push_back(map);
-}
-
-void MarkBoard::MoveToPly(int n){
-  uassert(n==0,"impl movetoply");
-  while(game->GetCurrentPly())
-    MoveBackup();
-  uassert(game->GetCurrentPly()==0);
-  uassert(game->AtStart(),"movetoply");
-}
Index: src/cql/markboard.h
===================================================================
--- src/cql/markboard.h	(revision 2842)
+++ src/cql/markboard.h	(working copy)
@@ -1,72 +1 @@
-#pragma once
 
-class MarkBoardMap{
- public:
-  markT squares_to_marks[64];
-  int marks_to_squares[32];
-  void initialize(Game*game);
-  void print();
-  void verify(Game*game);
-  const char*thisclass(){return "MarkBoardMap";}
-  void make_move(squareT from, squareT to, pieceT*board, colorT color);
-  void make_null_move(squareT from, squareT to, pieceT*board, colorT color);
-};
-
-
-  
-class MarkBoard{
- private:
-  MarkBoard(Game*game);
- public:
-  //fields
-  vector<MarkBoardMap>stack;
-  MarkBoardMap map;
-  Game * game;
-  //member methods
-  const char* thisclass(){return "MarkBoard";}
-  void print();
-  void MoveForward();
-  void MoveToPly(int n);
-  void MoveBackup();
-  void initialize(Game *game);
-  void verify();
-  void popstate();
-  void pushstate();
-    //class variables
-  static MarkBoard * globalMarkBoard;
-
-
-  //static methods
-  static void restart(); //delete current globalMarkBoard if any
-  static int getSquare(markT mark);
-  static markT getMark(int square);
-  static simpleMoveT* getCurrentMove(Game*game);
-  static moveT* identity(Game*game);
-  static bool myIsNullMove(simpleMoveT*);
-  static pieceT piece_at_square(squareT square, Game*game);
-  static int number_children(Game*game, bool searchvariations);
-  static void move_to_child(Game*game, int child);
-  static void make_move(simpleMoveT*move,Game*game); 
-  static vector<simpleMoveT*> getMoves(Game*g,bool searchvariations);
-  static vector<simpleMoveT*> getLegalMoves(Game*g);
-  static bool inMainline(Game*game);
-  static bool inVariation(Game*game);
-  static bool atVarEnd(Game*game);
-  static bool atVarStart(Game*game);
-  static MarkBoard * global();
-  static void mark(Game*game);
-  static void gameForward(Game*game);
-  static void gameBackup(Game*game);
-  static void gameSaveState(Game*game);
-  static void gameRestoreState(Game*game);
-  static void gameMoveToPly(Game*game, int ply); //ply must be 0
-  static void MoveIntoVariation(Game*game, int i);
-  static void gameToIdentity(moveT*id, Game*game, bool variations);
-  static bool gameSeekIdDescendants(moveT*id, Game*game, bool variations);
-  static void gameAppendComment(Game*game, const char* comment);
-  static void gameAppendComment(Game*game, moveT* loc, const char* comment);
-  static void gameToChild(moveT*id, Game*game, bool vars);
-  };
-
-
-
Index: src/cql/markboardmap.cpp
===================================================================
--- src/cql/markboardmap.cpp	(revision 2842)
+++ src/cql/markboardmap.cpp	(working copy)
@@ -1,120 +1 @@
-#include "util.h"
-#include "markboard.h"
 
-void MarkBoardMap::verify(Game*game){
-  //return;
-  if(0)return;
-  pieceT* board=game->GetCurrentPos()->GetBoard();
-  int marksseen=0;
-  for (int square=0;square<64;++square){
-    markT mark=squares_to_marks[square];
-    pieceT piece=board[square];
-    if(mark<0) {
-      uassert(piece==EMPTY,"no mark on nonempty");
-      continue;}
-    uassert(piece!=EMPTY,"mark on empty");
-    uassert(mark_valid(mark),"bad mark");
-    uassert(marks_to_squares[mark]==square);
-    marksseen++;
-  }
-  int marksinlist=0;
-  for (int sq:marks_to_squares)
-    if(square_valid(sq))++marksinlist;
-  uassert(marksseen==marksinlist);
-}
-
-void MarkBoardMap::print(){
-  FILE * fp=stdout;
-  squareT s;
-  printf("%s printing marked board: \n",thisclass());
-    for (int i=7; i>=0; i--) {
-    fputs ("   ", fp);
-    for (int j=0; j<8; j++) {
-      s = (i*8) + j;
-      markT val=squares_to_marks[s];
-      if (val<0){
-	char c= (i%2)==(j%2) ? '+':'-';
-	printf("%3c",c);
-      }
-      else printf("%3d",val);
-    }
-    putc ('\n', fp);
-    }
-}
-
-void MarkBoardMap::make_null_move(squareT fromsquare, squareT tosquare, pieceT*board, colorT color){
-  // NULL MOVE CONTRIVED EXCEPTION... testing purposes only
-  //uassert(false, "contrived null move markboard exception");
-  uassert(square_valid(fromsquare)&&
-	  square_valid(tosquare)&&
-	  fromsquare==tosquare&&
-	  (color==WHITE||color==BLACK),
-	  "make_null_move internal 1");
-  pieceT p = piece_Type(board[fromsquare]);
-  uassert(p==KING,"expecting a king on the null move from square");
-  return;
-}
-  
-			
-void MarkBoardMap::make_move(squareT fromsquare,
-			     squareT tosquare,
-			     pieceT*board,
-			     colorT color){
-  if(fromsquare==tosquare){
-    make_null_move(fromsquare,tosquare,board,color);
-    return;}
-  
-  uassert(square_valid(fromsquare)&&
-	  square_valid(tosquare)&&
-	  fromsquare!=tosquare &&
-	  (color==WHITE || color==BLACK),
-	  "map args");
-  markT frommark=squares_to_marks[fromsquare];
-  uassert(mark_valid(frommark),"bad from mark");
-  
-  pieceT ptype=piece_Type(board[fromsquare]);
-  bool ep=(ptype==PAWN)&&board[tosquare]==EMPTY&&(square_Fyle(fromsquare)!=square_Fyle(tosquare));
-  if (ep){
-    int capturedsquare=(color==WHITE) ? (tosquare-8) : (tosquare+8);
-    uassert(square_valid(capturedsquare),"map mark pawn bad");
-    uassert(piece_Type(board[capturedsquare])==PAWN);
-    markT capturedpawn=squares_to_marks[capturedsquare];
-    uassert(mark_valid(capturedpawn));
-    marks_to_squares[capturedpawn]=65;
-    squares_to_marks[capturedsquare]=-1;
-  }
-  else if (ptype==KING && square_Fyle(fromsquare)==E_FYLE&&
-	   (square_Fyle(tosquare)==C_FYLE||square_Fyle(tosquare)==G_FYLE)){
-    int rookfromsquare,rooktosquare;
-
-    if(square_Fyle(tosquare)==C_FYLE){
-      rookfromsquare=tosquare-2;
-      rooktosquare=tosquare+1;
-    }
-    else{
-      rookfromsquare=tosquare+1;
-      rooktosquare=tosquare-1;
-    }
-    uassert(rookfromsquare!=rooktosquare&&
-	    square_valid(rookfromsquare)&&
-	    square_valid(rooktosquare),
-	    "mark makemove bad rook");
-    markT rookfrommark=squares_to_marks[rookfromsquare];
-    uassert(mark_valid(rookfrommark));
-    squares_to_marks[rooktosquare]=rookfrommark;
-    squares_to_marks[rookfromsquare]=-1;
-    marks_to_squares[rookfrommark]=rooktosquare;
-  }
-	  //handle the general case
-  markT capturedmark=squares_to_marks[tosquare];
-  if(mark_valid(capturedmark)){
-      uassert(board[tosquare]!=EMPTY);
-      marks_to_squares[capturedmark]= -1;
-    };
-  markT movingmark=squares_to_marks[fromsquare];
-  uassert(movingmark>=0);
-  squares_to_marks[tosquare]=movingmark;
-  squares_to_marks[fromsquare]=-1;
-  marks_to_squares[movingmark]=tosquare;
-}
-  
Index: src/cql/markboardstatic.cpp
===================================================================
--- src/cql/markboardstatic.cpp	(revision 2842)
+++ src/cql/markboardstatic.cpp	(working copy)
@@ -1,264 +1 @@
-#include "util.h"
-#include "cql.h"
-#include "markboard.h"
-#include "cqlglobals.h"
-#include <map>
 
-int  MarkBoard::number_children(Game*game, bool searchvariations){
-  int nseen=0;
-  bool currentatend=game->AtVarEnd();
-  if (!currentatend)++nseen;
-  if(searchvariations){
-    int numvars=game->GetNumVariations();
-    // This code assumes that a variation will never be at its own varend.
-    nseen+=numvars;
-  }
-  return nseen;
-}
-
-pieceT MarkBoard::piece_at_square(squareT square, Game*game){
-  uassert(square_valid(square), "internal piece_at_square");
-  pieceT p= game->GetCurrentPos()->GetBoard()[square];
-  uassert(piece_valid(p));
-  return p;
-}
-    
-moveT* MarkBoard::identity(Game*game){
-  return game->GetCurrentMoveCQL();
-}
-
-simpleMoveT* MarkBoard::getCurrentMove(Game*game){
-  uassert(!atVarEnd(game),
-	  "Attempt to get a move where there are none to be had"
-	  );
-  simpleMoveT* s=game->GetCurrentMove();
-  uassert(s,"expecting non-null move");
-  return s;
-}
-
-
-
-void MarkBoard::move_to_child(Game*game, int child){
-  bool hasmainline= !atVarEnd(game);
-  if(hasmainline&& child==0){
-    gameForward(game);
-    return;
-  }
-  int variationnumber=child;
-  if(hasmainline) variationnumber--;
-  uassert(variationnumber>=0 && variationnumber<game->GetNumVariations());
-  MoveIntoVariation(game,variationnumber);
-  gameForward(game);
-}
-
-
-bool MarkBoard::inMainline(Game*game){
-  return game->GetVarLevel()==0;
-}
-
-bool MarkBoard::inVariation(Game*game){
-  return game->GetVarLevel()>0;
-}
-
-bool MarkBoard::atVarEnd(Game*game){
-  return game->AtVarEnd();
-}
-
-bool MarkBoard::atVarStart(Game*game){
-  return game->AtVarStart();
-}
-
-void MarkBoard::MoveIntoVariation(Game*game, int i){
-  if(game->MoveIntoVariation(i))
-    uassert(false,"Move Into Variation error");
-}
-
-void MarkBoard::gameForward(Game*g){
-  if (global())
-    global()->MoveForward();
-  else
-    {bool r=g->MoveForward();
-      uassert(!r,"gameforward fail");
-    }
-}
-
-void MarkBoard::gameBackup(Game*g){
-  if(global()){
-    uassert(g==global()->game,"gameBackup");
-    global()->MoveBackup();
-  }
-  else g->MoveBackup();
-  if(atVarStart(g)&&inVariation(g))
-    g->MoveExitVariation();
-  uassert(inMainline(g) || !atVarStart(g));
-}
-
-void MarkBoard::gameMoveToPly(Game*g, int ply){ //ply must be 0
-  uassert(ply==0);
-  if(global()){
-    uassert(global()->game==g);
-    global()->MoveToPly(ply);
-  }
-  else
-    g->MoveToPly(0);
-}
-    
-  
-void MarkBoard::make_move(simpleMoveT*move,Game*game){
-  if(move==game->GetCurrentMove())
-    {gameForward(game);return;}
-  for(int varnumber=0;varnumber<game->GetNumVariations();++varnumber){
-    MoveIntoVariation(game,varnumber);
-    if(move==game->GetCurrentMove()){
-      gameForward(game);
-      return;
-    }
-    else
-      game->MoveExitVariation();
-  }
-  uassert(false,"move not found in make_move");
-}
-
-int MarkBoard::getSquare(markT mark){
-  MarkBoard*g=global();
-  uassert(g,"internal no global found");
-  uassert(mark_valid(mark),"internal bad mark gets");
-  int square=g->map.marks_to_squares[mark];
-  if(square_valid(square))
-    uassert(g->map.squares_to_marks[square]==mark,"getsquare mismatch");
-  return square;
-}
-
-markT MarkBoard::getMark(int square){
-  uassert(square_valid(square));
-  MarkBoard*g=global();
-  uassert(g,"internal no global found2");
-  int mark=g->map.squares_to_marks[square];
-  if(mark_valid(mark))
-    uassert(g->map.marks_to_squares[mark]==square);
-  return mark;
-}
-    
-    
-  
-void MarkBoard::gameToIdentity(moveT* myid, Game*game,bool variations){
-  gameMoveToPly(game,0);
-  if(gameSeekIdDescendants(myid,game,variations))
-    return;
-  else uassert(false,"id not found gametoid",myid->san);
-}
-
-void MarkBoard::gameToChild(moveT*childid,Game*game, bool variations){
-  int nchildren=MarkBoard::number_children(game,variations);
-  uassert(nchildren,"No children in gameToChild");
-  for (int child=0;child<nchildren;++child){
-    move_to_child(game,child);
-    if (identity(game)==childid) return;
-    else gameBackup(game);
-  }
-  uassert(false,"gametochild: id not found");
-}
-
-bool MarkBoard::gameSeekIdDescendants(moveT*myid, Game*game, bool vars){
-  if(identity(game)==myid) return true;
-  int nchildren=MarkBoard::number_children(game, vars);
-  for(int child=0;child<nchildren;++child){
-    move_to_child(game,child);
-    if(gameSeekIdDescendants(myid,game,vars)) return true;
-    else MarkBoard::gameBackup(game);
-  }
-  return false;
-}
-
-void MarkBoard::gameAppendComment(Game*game, const char* comment){
-  uassert(comment);
-  uassert(strlen(comment)<2000);
-  if(strlen(comment)==0)return;
-  char buffer[5000];
-  char*current=buffer;
-  current[0]=0;
-  char * oldcomment=game->GetMoveComment();
-  if(oldcomment){
-    if (strstr(oldcomment,comment)) return;
-    if(strlen(oldcomment)>500){
-      printf("\nIgnoring too long comment in game: %d\n",game->GetNumber());
-      return;
-    }
-    current+=sprintf(current,"%s",oldcomment);
-  }
-  if(current!=buffer){
-    uassert(*current==0);
-#ifdef STANDALONE
-    current+=sprintf(current,"; ");
-#endif
-#ifdef INTEGRATED
-    current+=sprintf(current," ");
- #endif
-  }
-  uassert(*current==0);
-  sprintf(current,"%s",comment);
-  if(strlen(buffer)>500){
-    if(MarkBoard_gameAppendComment_lastignored!=game->GetNumber()){
-      MarkBoard_gameAppendComment_lastignored=game->GetNumber();
-      printf("\nNote: Truncating long comment in game: %d\n",MarkBoard_gameAppendComment_lastignored);
-    }
-    return;
-  }
-  game->SetMoveComment(buffer);
-  game->SetAltered(true);
-}
-
-void MarkBoard::gameAppendComment(Game*game, moveT*loc, const char*comment){
-  moveT* me=identity(game);
-  gameToIdentity(loc,game,true);
-  gameAppendComment(game,comment);
-  gameToIdentity(me,game,true);
-}
-  
-vector<simpleMoveT*> MarkBoard::getMoves(Game*game,bool searchvars){
-  vector<simpleMoveT*> moves;
-  if(!atVarEnd(game))
-    moves.push_back(getCurrentMove(game));
-  if(!searchvars) return moves;
-  for(int varnum=0;varnum<game->GetNumVariations();++varnum){
-    MoveIntoVariation(game,varnum);
-    uassert(!atVarEnd(game),"get_moves end of var in var");
-    moves.push_back(getCurrentMove(game));
-    uassert(!game->MoveExitVariation());
-  }
-  int nm=(int)(moves.size());
-  for(int i=0;i<nm;++i)
-    for(int j=i+1;j<nm;++j)
-      uassert(moves[i]!=moves[j],"get_moves internal");
-  return moves;
-}
-  
-vector<simpleMoveT*> MarkBoard::getLegalMoves(Game*game){
-  uassert(false,"getLegalMoves is not implemented");
-  static int gamenumber=0; //ignore non-reentrancy as not called
-  static std::map<moveT*,vector<simpleMoveT*>> legalmap; //ignore non-reentrancy as not called
-  if(game->GetNumber()!=gamenumber){
-    gamenumber=game->GetNumber();
-    legalmap.clear();
-  }
-  moveT* me=identity(game);
-  if(legalmap.find(me)==legalmap.end()){
-    Position*position=game->GetCurrentPos();
-    position->GenerateMoves();
-    MoveList* movelist=position->GetLegalMoves();
-    uassert(movelist,"getLegalMoves");
-    vector<simpleMoveT*> movevec;
-    for(unsigned int i=0;i<movelist->Size();++i)
-      movevec.push_back(movelist->Get(i));
-    legalmap[me]=movevec;
-  }
-  uassert(legalmap.find(me)!=legalmap.end());
-  return legalmap[me];
-}
-  
-void MarkBoard::restart(){
-  if(globalMarkBoard){
-    delete globalMarkBoard;
-    globalMarkBoard=NULL;
-  }
-}
Index: src/cql/match.cpp
===================================================================
--- src/cql/match.cpp	(revision 2842)
+++ src/cql/match.cpp	(working copy)
@@ -1,53 +1 @@
-#include "node.h"
 
-  
-bool PositionNode::match_position(Game*game){
-  for(MFilter* spec:specs)
-    if(!spec->match_position(game))
-      return false;
-  return true;
-}
-
-
-    
-
-bool ColorNode::match_position(Game*game){
-  colorT tomove=game->GetCurrentPos()->GetToMove();
-  uassert(tomove==WHITE||tomove==BLACK);
-  return color==tomove;
-}
-
-bool InitialNode::match_position(Game*game){
-  return game->GetCurrentPly()==0;
-}
-
-bool TerminalNode::match_position(Game*game){
-  return game->AtVarEnd();
-}
-
-
-bool CheckNode::match_position(Game*game){
-  Position*pos=game->GetCurrentPos();
-  return pos->IsKingInCheck();
-}
-
-bool InVariationNode::match_position(Game*game){
-  return MarkBoard::inVariation(game);
-}
-
-bool InMainlineNode::match_position(Game*game){
-  return MarkBoard::inMainline(game);
-}
-
-bool MateNode::match_position(Game*game){
-  Position*pos=game->GetCurrentPos();
-  return pos->IsKingInMate();
-}
-
-
-bool StalemateNode::match_position(Game*game){
-  Position*pos=game->GetCurrentPos();
-  return pos->IsStaleMate();
-}
-
-
Index: src/cql/matchcommentnode.cpp
===================================================================
--- src/cql/matchcommentnode.cpp	(revision 2842)
+++ src/cql/matchcommentnode.cpp	(working copy)
@@ -1,17 +1 @@
-#include "node.h"
-MatchCommentNode::MatchCommentNode(const char* v){
-  uassert(v);
-  uassert(strlen(v)>0,"cannot match empty string");
-  value=v;
-}
 
-void MatchCommentNode::print(){
-  printf("<%s %s>",thisclass(),value);
-}
-
-bool MatchCommentNode::match_position(Game*game){
-  char * comment=game->GetMoveComment();
-  if(!comment) return false;
-  return strstr(comment,value)!=NULL;
-}
-
Index: src/cql/matchcountnode.cpp
===================================================================
--- src/cql/matchcountnode.cpp	(revision 2842)
+++ src/cql/matchcountnode.cpp	(working copy)
@@ -1,13 +1 @@
-#include "node.h"
-void MatchCountNode::print(){
-  printf("<%s ",thisclass());
-  if(sort) printf("sort ");
-  range->print();
-  printf(">");
-}
 
-MatchCountNode::MatchCountNode(Range*r,bool s) : range{r},sort{s} {
-  uassert(range);
-  uassert(range->min>=0);
-}
-
Index: src/cql/movebase.cpp
===================================================================
--- src/cql/movebase.cpp	(revision 2842)
+++ src/cql/movebase.cpp	(working copy)
@@ -1,217 +1 @@
-#include "node.h"
-MoveBase::MoveBase(SetBase*f, SetBase*t, PieceLoc*p,SetBase* e,bool nullmove, bool mainline, bool variation){
-  uassert(!(mainline&&variation),"Movebase args");
-  from =f;
-  to=t;
-  promote=p;
-  enpassantsquare=e;
-  nullMove=nullmove;
-  primaryMove=mainline;
-  secondaryMove=variation;
-}
 
-MoveFutureNode::MoveFutureNode(SetBase*from,
-			       SetBase*to,
-			       PieceLoc* promote,
-			       SetBase* enpassant,
-			       bool nullmove,
-			       bool mainline,
-			       bool variation) :
-  MoveBase(from, to, promote, enpassant,nullmove,mainline,variation){}
-
-MoveLegalNode::MoveLegalNode(SetBase*from,
-			       SetBase*to,
-			       PieceLoc* promote,
-			       SetBase* enpassant,
-			       bool nullmove,
-			       bool mainline,
-			       bool variation) :
-  MoveBase(from, to, promote, enpassant,nullmove,mainline,variation){}
-
-MovePastNode::MovePastNode(SetBase*from,
-			       SetBase*to,
-			       PieceLoc* promote,
-			       SetBase* enpassant,
-			       bool nullmove,
-			       bool mainline,
-			       bool variation) :
-  MoveBase(from, to, promote, enpassant,nullmove,mainline,variation){}
-
-
-vector<simpleMoveT*> MovePastNode::getMoves(Game*game){
-  vector<simpleMoveT*>moves;
-  if(game->GetCurrentPly()==0) return moves;
-  if(primaryMove||secondaryMove){
-    int varlevel=game->GetVarLevel(); // should put this in MarkBoard of course, copied from beginvariationnode
-    int parentlevel=-1;
-    auto me=MarkBoard::identity(game);
-    uassert(game->GetCurrentPly()!=0,"MovePastNode: internal getcurrentply");
-    MarkBoard::gameBackup(game);
-    parentlevel=game->GetVarLevel();
-    uassert (varlevel==parentlevel||varlevel==parentlevel+1,"MovePastNode: internal level");
-    MarkBoard::gameToChild(me,game,true);
-    if (primaryMove && varlevel>parentlevel) return moves;
-    if (secondaryMove && varlevel==parentlevel)return moves;
-  }
-  
-  moveT*prev=game->GetCurrentMoveCQL()->prev;
-  uassert(prev&&prev->marker!=START_MARKER);
-  simpleMoveT* smt= &(prev->moveData);
-  moves.push_back(smt);
-  return moves;
-}
-
-vector<simpleMoveT*>MoveLegalNode::getMoves(Game*game){
-  return MarkBoard::getLegalMoves(game);
-}
-
-vector<simpleMoveT*>MoveFutureNode::getMoves(Game*game){
-  uassert (!(primaryMove&&secondaryMove),"getMoves mv");
-  vector<simpleMoveT*>allmoves=MarkBoard::getMoves(game,getSearchVariations());
-  vector<simpleMoveT*>ret;
-  if (requiredMove){
-    uassert(requiredIndex>=0 && requiredIndex<allmoves.size(),"getMoves: required size");
-    uassert(requiredMove==allmoves.at(requiredIndex),"getMove, rm ==, possible issue");
-    vector<simpleMoveT*>requiredret(1, allmoves.at(requiredIndex));
-    if(primaryMove && requiredIndex>0) return ret;
-    else if (primaryMove && requiredIndex==0) return requiredret;
-    else if (secondaryMove&&requiredIndex==0) return ret;
-    else if (secondaryMove&&requiredIndex>0) return requiredret;
-    else return requiredret;
-  }      
-  uassert(requiredIndex== -1,"getMoves: rimo");
-  
-  if (allmoves.empty())return allmoves;
-  if (primaryMove){
-    ret.push_back(allmoves.at(0));
-    return ret;
-  }
-  else if (secondaryMove){
-    for (int i=1;i<allmoves.size();++i)
-      ret.push_back(allmoves.at(i));
-    return ret;
-  }
-  return allmoves;
-}  
-  
-    
-SquareMask MoveBase::getSquares(Game*game){
-  bool searchvariations=getSearchVariations();
-  SquareMask ret;
-  if(!searchvariations)
-    uassert(MarkBoard::inMainline(game),
-	    "unexpectedly in a variation in move");
-  vector<simpleMoveT*>moves=getMoves(game);
-  for(auto move:moves)
-    if(match_move(move,game)){
-      squareT tosquare=move->to;
-      uassert(square_valid(tosquare));
-      ret.insert(tosquare);
-    }
-  return ret;
-}
-  
-bool MoveBase::match_position(Game*game){
-  return getSquares(game).nonempty();
-}
-
-bool MoveBase::match_move(simpleMoveT* move, Game*game){
-  bool ispast=(dynamic_cast<MovePastNode*>(this)!=NULL);
-  bool ret=true;
-  auto me=MarkBoard::identity(game);
-  bool movenull=MarkBoard::myIsNullMove(move);
-  if(nullMove && !movenull)
-    return false;
-
-  //if this is a past move, we backup for all the filters
-  if(ispast){
-    if(game->GetCurrentPly()==0)
-      return false;
-    MarkBoard::gameBackup(game);
-  }
-  if(from){
-    squareT fromsquare=move->from;
-    uassert(square_valid(fromsquare),"match_move, bad from square");
-    bool checkfrom=from->getSquares(game).member(fromsquare);
-    if(!checkfrom)ret=false;
-  }
-  if(to){
-    squareT tosquare=move->to;
-    uassert(square_valid(tosquare),"match_move, bad to square");
-    bool checkto=to->getSquares(game).member(tosquare);
-    if(!checkto)ret=false;
-  }
-  if(promote){
-    pieceT promoted=move->promote;
-    if(promoted==EMPTY) ret=false;
-    else{
-      colorT color=game->GetCurrentPos()->GetToMove();
-      pieceT promotedpiece=piece_Make(color,promoted);
-      if(color==WHITE)
-	uassert(promotedpiece==WQ||
-		promotedpiece==WR||
-		promotedpiece==WN||
-		promotedpiece==WB);
-      else if(color==BLACK)
-	uassert(promotedpiece==BQ||
-		promotedpiece==BR||
-		promotedpiece==BN||
-		promotedpiece==BB);
-      else
-	uassert(false, "promotion internal");
-      bool checkpromoted=promote->match_piece(promotedpiece);
-      if(!checkpromoted)ret=false;
-    }
-  }
-  if(enpassantsquare){
-    squareT capturedsquare=move->capturedSquare;
-    squareT tosquare=move->to;
-    if(tosquare==capturedsquare)ret= false;
-    else{
-      bool epto=enpassantsquare->getSquares(game).member(capturedsquare);
-      if(!epto)ret=false;
-    }
-  }//enpassantsquare
-  if(ispast)
-    MarkBoard::gameToChild(me,game,getSearchVariations());
-  uassert(me==MarkBoard::identity(game),"id fail check movebase");
-  return ret;
-}
-
-vnode MoveBase::children(){
-  vnode v;
-  if(from)v.push_back(from);
-  if(to)v.push_back(to);
-  if(promote)v.push_back(promote);
-  if(enpassantsquare)v.push_back(enpassantsquare);
-  return v;
-}
-  
-void MoveBase::print(){
-  printf("<%s",thisclass());
-  printVariationFlags();
-  if(from) {
-    printf(" from ");
-    from->print();}
-  if (to){
-    printf(" to ");
-    to->print();
-  }
-  if (promote){
-    printf(" promote ");
-    promote->print();
-  }
-  if(enpassantsquare){
-    printf(" enpassant ");
-    enpassantsquare->print();
-  }
-  if(nullMove){
-    printf(" nullMove ");
-  }
-  if (primaryMove)
-    printf(" primaryMove ");
-  if (secondaryMove)
-    printf(" secondaryMove ");
-  printf("%s>",thisclass());
-}
-
Index: src/cql/movenumbernode.cpp
===================================================================
--- src/cql/movenumbernode.cpp	(revision 2842)
+++ src/cql/movenumbernode.cpp	(working copy)
@@ -1,24 +1 @@
-#include "node.h"
 
-MoveNumberNode::MoveNumberNode(Range*r):range{r}{
-  uassert(range,"bad movenumber arg");
-}
-
-void MoveNumberNode::print(){
-  printf("<%s ",thisclass());
-  range->print();
-  printf(">");
-}
-
-bool MoveNumberNode::match_position(Game*game){
-  NumValue move=-1;
-  return match_count(game,&move);
-}
-
-bool MoveNumberNode::match_count(Game*game, NumValue*value){
-  int ply=game->GetCurrentPly();
-  int mn=ply/2+1;
-  if (!range->valid(mn)) return false;
-  *value=mn;
-  return true;
-}
Index: src/cql/myvector.h
===================================================================
--- src/cql/myvector.h	(revision 2842)
+++ src/cql/myvector.h	(working copy)
@@ -1,12 +1 @@
-#pragma once
-template <class T> void myinsert(vector<T>&v, const T& t){
-  for(auto e: v)
-    if (e==t) return;
-  v.push_back(t);
-}
 
-template <class T> int myindex(const vector<T>&v, const T& t){
-  for(int i=0;i<v.size();++i)
-    if(v[i]==t)return i;
-  return -1;
-}
Index: src/cql/node.cpp
===================================================================
--- src/cql/node.cpp	(revision 2842)
+++ src/cql/node.cpp	(working copy)
@@ -1,194 +1 @@
-#include "node.h"
-int Node::counter=0;     
-int Node::ndisabled=0;
 
-bool Node::isSet(){
-  SetBase* set=dynamic_cast<SetBase*>(this);
-  return set && set->isSet();
-}
-
-bool Node::isCountable(){
-  Countable* countable=dynamic_cast<Countable*>(this);
-  return countable&&countable->isCountable();
-}
-
-void Node::cloneverify(Node*s,Node*t){
-  uassert(s,"cloneverify s");
-  uassert(t,"cloneverify t");
-  vector<Node*>schildren=s->children();
-  vector<Node*>tchildren=t->children();
-  uassert(schildren.size()==tchildren.size(),"bad child count");
-  for(int i=0;i<schildren.size();++i){
-    Node*schild=schildren[i];
-    Node*tchild=tchildren[i];
-    uassert(schild&&tchild,"internal cloneverify");
-    uassert(strcmp(schild->thisclass(),tchild->thisclass())==0,"bad classes");
-    if(schild==tchild){
-      printf("Unexpected identical children after cloning. \n");
-      printf("Source child: \n");
-      schild->print();
-      printf("\nTarget child: \n");
-      tchild->print();
-      printf("\n");
-      uassert(false,"cloneverify child identical");
-    }
-    cloneverify(schild,tchild);
-  }
-}
-
-	     
-  
-  
-void KeywordNode::print(){
-  printf("%s: %s>",thisclass(),value);
-}
-
-void PgnNode::print(){
-  printf("<%s: %s>",thisclass(),value);
-}
-
-void OutputNode::print(){
-  printf("<%s: %s>",thisclass(),value);
-}
-
-KeywordNode::KeywordNode(const char* v){
-  uassert(v&&strlen(v)>=1);
-  uassert(KeywordToken::isReserved(v),"KeywordNode: internal");
-  value=v;
-}
-
-bool KeywordNode::eq(const char*v){
-  if(!v) return false;
-  return strcmp(value,v)==0;
-}
-
-Range::Range(int mi){
-  min=mi;
-  max=mi;
-}
-
-Range::Range(int mi,int ma){
-  uassert(mi<=ma,"Invalid range: max smaller than min");
-  min=mi;
-  max=ma;
-}
-
-void Range::print(){
-  printf("<%s %d %d>",thisclass(),min,max);
-}
-
-void ResultNode::print(){
-  printf("<%s %s>",thisclass(),result_to_string(result));
-}
-
-
-vnode Node::descendants(){
-  vnode start{this};
-  alldescendants(&start);
-  return start;
-}
-
-void Node::alldescendants(vnode*v){
-  vnode c=children();
-  for(auto np : c)
-    if(np){
-      v->push_back(np);
-      np->alldescendants(v);
-    }
-}
-	
-GameNumberNode::GameNumberNode(Range*r){
-  if(!r) 
-    r=new Range(1,100000000);
-  range=r;
-}
-
-void GameNumberNode::print(){
-  uassert(range);
-  printf("<%s: ",thisclass());
-  range->print();
-  printf(">");
-}
-
-ResultNode::ResultNode(const char*v){
-  uassert(v,"bad result node");
-  if(!strcmp(v,"1-0"))
-    result=RESULT_White;
-  else if(!strcmp(v,"0-1"))
-    result=RESULT_Black;
-  else if(!strcmp(v,"1/2-1/2"))
-    result=RESULT_Draw;
-  else
-    uassert(false,"Invalid result string",v);
-}
-
-bool GameNumberNode::match_game(Game*game){
-  return range->valid(game->GetNumber());
-}
-
-bool ResultNode::match_game(Game*game){
-  uassert(game);
-  if(result!=RESULT_None&&
-     result!=game->GetResult())
-    return false;
-  return true;
-}
-
-vnode RayNode::children(){
-  return vnode {designators.begin(),designators.end()};
-}
-
-void Node::disable(){
-  uassert(!disabled,"internal delete");
-  disabled=true;
-  ++ndisabled;
-}
-
-ColorNode::ColorNode(colorT c){
-  uassert(c==BLACK||c==WHITE);
-  color=c;
-}
-
-void ColorNode::print(){
-  if(color==WHITE)
-    printf(" :wtm");
-  else if (color==BLACK)
-    printf(" :btm");
-  else
-    uassert(false,"internal color");
-}
-
-void Node::makeSilentRecursively(){
-  CommentFlags* cf=dynamic_cast<CommentFlags*>(this);
-  if(cf)cf->makeSilent();
-  for (Node*child:children()){
-    uassert(child,"null child expand silent");
-    child->makeSilentRecursively();
-  }
-}
-
-//I have no idea why this is here or what this does
-void Node::makeNotNodeSilentRecursively(){
-  if(dynamic_cast<NotNode*>(this))
-    makeSilentRecursively();
-  for(Node*child:children()){
-        uassert(child,"null child notsilentrecursive");
-	child->makeNotNodeSilentRecursively();
-  }
-}
-
-void Node::addSortFields(vector<NumericVariable*>&fields){
-  AssignNode*a=dynamic_cast<AssignNode*>(this);
-  if(a){
-    NumericVariable* v=a->variable;
-    uassert(v,"unexpected null variable in an assignnode");
-    myinsert(fields,v);
-  }
-  EchoLcaSpec*spec=dynamic_cast<EchoLcaSpec*>(this);
-  if(spec){
-    NumericVariable*v=spec->assignee;
-    if(v) myinsert(fields,v);
-  }
-  for(Node* child:children())
-    child->addSortFields(fields);
-}
Index: src/cql/node.h
===================================================================
--- src/cql/node.h	(revision 2842)
+++ src/cql/node.h	(working copy)
@@ -1,806 +1 @@
-#pragma once
-#include "deleteable.h"
-#include "util.h"
-#include "cqlglobals.h"
-#include "token.h"
-#include "game.h"
-#include "variable.h"
-#include "markboard.h"
-#include "squaremask.h"
-#include "variationflags.h"
-#include "commentflags.h"
-#include "clonevec.h"
-#include "sortvalue.h"
-#include "gamesortinfo.h"
-#include "cql.h"
-#include "seqret.h"
 
-class PieceLoc;
-class Node;
-class CqlNode;
-class Range;
-class MFilter;
-class Transform;
-class TransformNode;
-class SeqConstituent;
-class StarConstituent;
-class RepeatConstituent;
-class HolderConstituent;
-
-typedef vector<Node*> vnode;
-#define CVV(name) const char * thisclass() {return #name;} name* clone() 
-
-class Node : public Deleteable { //abstract
- public:
-  static int ndisabled;
-  bool disabled{false};
-  void disable();
-  bool annotateFlag{false};
-  virtual void print(){printf("<%s>",thisclass());}
-  virtual const char* thisclass()=0;
-  virtual vnode children()=0;
-  vnode descendants();
-  void alldescendants(vnode*);
-  static int counter;
-  Node(){++counter;}
-  virtual void setVariations(bool arg);
-  virtual void deepify(){};
-  void cloneverify(Node*source,Node*target);
-  virtual Node* clone()=0;
-  virtual void transform_members(Transform*){}
-  virtual void transform_in_place(Transform*);
-  virtual void expand();
-  void makeSilentRecursively();
-  void makeNotNodeSilentRecursively();
-  virtual Node* transform(Transform*t);
-  virtual bool hasEmptySquareMaskDescendant();
-  virtual bool hasEmptySquareMask(){return false;}
-  virtual void addSortFields(vector<NumericVariable*>& fields);
-  virtual bool isSet();
-  virtual bool isCountable();
-};
-
-
-
-  
-class MFilter : public Node { //abstract
- public:
-  virtual bool match_position(Game*game)=0;
-  virtual bool isGap(){return false;}
-  virtual MFilter* clone()=0;
-};
-
-class Countable{
- public:
-  virtual bool match_count(Game*game, NumValue*value)=0;
-  virtual Countable* clone()=0;
-  virtual void print()=0;
-  virtual bool isCountable(){return true;}
-};
-
-class SetBase: public MFilter{ //abstract
- public:
-  //  virtual bool match_square(squareT square, Game*game)=0;
-  virtual bool match_position(Game*game);
-  virtual SquareMask getSquares(Game*game)=0;
-  virtual bool isSet(){return true;}
-  virtual SetBase* clone()=0;
-
-};
-
-class PieceLoc:public SetBase{
- public:
-  SquareMask pieces;
-  SquareMask squaremask;
-  /*caching related members*/
-  moveT* lastid;
-  int lastgamenumber=-1;
-  SquareMask lastmask;
-  /*end of caching related members*/
-  vector<Variable*> variables;
-  //  bool piecemask[18];
-  //  bool matchPieceSquare(pieceT piece,squareT square);
-  PieceLoc(vector<PieceToken*>piecetokens,
-	   vector<SquareToken*> squaretokens,
-	   vector<VariableToken*> variabletokens);
-  static vector<pieceT>piecesFromChar(char c);
-  void print();
-  CVV(PieceLoc);
-  vnode children(){return vnode{};}
-  bool match_piece(pieceT piece);
-  bool isPurePiece();
-  Variable* getAsVariable();
-  void transform_members(Transform *);
-  bool hasEmptySquareMask();
-  SquareMask getSquares(Game*game);
-  SquareMask getPieceMask(Game*game);
-};
-
-class GameFilter:public MFilter{ //abstract
- public:
-  virtual bool match_game(Game*game)=0;
-  bool match_position(Game*game){return match_game(game);}
-  virtual GameFilter*clone()=0;
-};
-
-
-
-////////Simple keyword specs with no arguments, base class is KeywordNode, subclasses
-///////are TransformNode, VariationsNode
-class Childless : public Node{ //abstract
- public:
-  vnode children(){return vnode{};}
-  virtual Childless* clone()=0;
-};
-  
-class KeywordNode: public Childless{
- public:
-  const char*value;
-  KeywordNode(const char*v);
-  CVV(KeywordNode);
-  void print();
-  bool eq(const char*);
-};
-
-class SilentFeatureNode: public KeywordNode{
- public:
-  CVV(SilentFeatureNode);
- SilentFeatureNode(): KeywordNode("silent"){};
-};
-
-class VariationsNode: public KeywordNode{
- public:
-  CVV(VariationsNode);
- VariationsNode(): KeywordNode(":variations"){}
-};
-
-
-class AnyNode:public SetBase{
- public:
-  SquareMask getSquares(Game*game){return SquareMask::all();}
-  bool match_position(Game*game){return true;}
-  vnode children(){return vnode{};}
-  CVV(AnyNode);
-};
-
-
-class SimpleNode:public MFilter { //no arg keywords corresponding to a filter, abstract
- public:
-  virtual SimpleNode*clone()=0;
-  vnode children(){return vnode{};}
-};
-
-class CheckNode:public SimpleNode{
-  CVV(CheckNode);
-  bool match_position(Game*game);
-};
-
-class StalemateNode:public SimpleNode{
-  CVV(StalemateNode);
-  bool match_position(Game*);
-};
-
-class MateNode:public SimpleNode{
-  CVV(MateNode);
-  bool match_position(Game*);
-};
-
-class ColorNode:public MFilter{
- public:
-  CVV(ColorNode);
-  void print();
-  bool match_position(Game*);
-  colorT color;
-  ColorNode(colorT c);
-  vnode children(){return vnode{};}
-  void transform_members(Transform*);
-};
-
-
-class InitialNode:public SimpleNode{
-  CVV(InitialNode);
-  bool match_position(Game*);
-};
-
-class InVariationNode:public SimpleNode{
- public:
-  CVV(InVariationNode);
-  bool match_position(Game*game);
-};
-
-class BeginVariationNode:public SimpleNode{
- public:
-  CVV(BeginVariationNode);
-  bool match_position(Game*game);
-};
-
-
-class InMainlineNode:public SimpleNode{
- public:
-  CVV(InMainlineNode);
-  bool match_position(Game*game);
-};
-
-
-
-class TerminalNode:public SimpleNode{
-  CVV(TerminalNode);
-  bool match_position(Game*);
-};
-
-class NotNode:public SetBase{
- public:
-  MFilter* filter{NULL};
-  CVV(NotNode);
-  vnode children(){return vnode{filter};}
-  void print();
-  NotNode(Node*np);
-  bool match_position(Game*);
-  void deepify(){filter=filter->clone();}
-  virtual bool isSet();
-  SquareMask getSquares(Game*);
-};
-
-class PositionNode: public MFilter{
- public:
-  vector<MFilter*> specs;
-  PositionNode(vector<Node*>);
-  void print();
-  bool variations{false};
-  CVV(PositionNode);
-  vnode children();
-  bool match_position(Game*game);
-  void deepify(){clonevec(specs);}
-};
-
-class MatchCountNode: public Node{
- public:
-  Range*range{NULL};
-  MatchCountNode(Range*,bool);
-  bool sort{false};
-  void print();
-  vnode children(){return vnode{};}
-  CVV(MatchCountNode);
-};
-
-class PgnNode: public Node{
- public:
-  PgnNode(const char*v){value=v;}
-  const char* value;
-  CVV(PgnNode);
-  void print();
-  vnode children(){return vnode{};}
-};
-
-class OutputNode: public Node{
- public:
-  OutputNode(const char*v){value=v;}
-  const char* value;
-  CVV(OutputNode);
-  void print();
-  vnode children(){return vnode{};}
-};
-
-class ResultNode: public GameFilter{
- public:
-  ResultNode(const char*v);
-  resultT result{RESULT_None};
-  void transform_members(Transform*t);
-  CVV(ResultNode);
-  void print();
-  bool match_game(Game*game);
-  vnode children(){return vnode{};}
-};
-
-class PlayerNode: public GameFilter{
- public:
-  const char* name{NULL};
-  colorT color {NOCOLOR};
-  vnode children(){return vnode{};}
-  bool match_game(Game*game);
-  void print();
-  CVV(PlayerNode);
-  PlayerNode(const char*,colorT);
-  void transform_members(Transform*);
-};
-
-class EventNode: public GameFilter{
- public:
-  const char* name{NULL};
-  vnode children(){return vnode{};}
-  bool match_game(Game*game);
-  void print();
-  CVV(EventNode);
-  EventNode(const char*);
-};
-
-class SiteNode: public GameFilter{
- public:
-  const char* name{NULL};
-  vnode children(){return vnode{};}
-  bool match_game(Game*game);
-  void print();
-  CVV(SiteNode);
-  SiteNode(const char*);
-};
-
-
-class EloNode: public GameFilter,public Countable{
- public:
-  Range*range{NULL};
-  colorT color {NOCOLOR};
-  vnode children(){return vnode{};}
-  bool match_game(Game*game);
-  bool match_count(Game*game, NumValue*value);
-  void print();
-  CVV(EloNode);
-  EloNode(Range*range,colorT);
-  void transform_members(Transform*);
-};
-
-  
-class YearNode: public GameFilter, public Countable{
- public:
-  Range*range{NULL};
-  vnode children(){return vnode{};}
-  bool match_game(Game*game);
-  bool match_count(Game*game, NumValue*value);
-  void print();
-  CVV(YearNode);
-  YearNode(Range*range);
-};
-
-class GameNumberNode: public GameFilter{
- public:
-  Range * range{NULL};
-  CVV(GameNumberNode);
-  GameNumberNode(Range* r);
-  vnode children(){return vnode{};};
-  bool match_game(Game*game);
-  void print();
-};
-
-class OriginNode:public SetBase{
- public:
-  OriginNode(TagVariable*);
-  TagVariable*variable{NULL};
-  SquareMask getSquares(Game*game);
-  CVV(OriginNode);
-  vnode children(){return vnode{};}
-  void print();
-};
-
-class CountSquaresNode:public MFilter, public Countable{
- private:
-  int count{0};
- public:
-  int getCount(){return count;}
-  Range* range{NULL};
-  SetBase* set{NULL};
-  CVV(CountSquaresNode);
-  bool match_count(Game*game, NumValue* value);
-  void print();
-  CountSquaresNode(SetBase* s,Range*r);
-  vnode children() {return vnode{set};}
-  virtual bool match_position(Game*game);
-  void deepify(){set=set->clone();}
-};
-
-
-class AttackNode : public SetBase, public Countable{
- private:
-  int count{0};
-  void addcounts(pieceT piece, pieceT*board, squareT square);
-  void addslidingcounts(directionT direction, pieceT*board, squareT square);
-  void addknightcounts(pieceT*board,squareT square);
-  void addkingcounts(pieceT*board,squareT square);
-  void addpawncounts(pieceT pawn,pieceT*board,squareT square);
-  void addnonsliding(int fileoff,int rankoff,pieceT*board,squareT square);
-  int squarecounts[64]; //tmp
-
- public:
-  SetBase* attacking{NULL};
-  SetBase* attacked{NULL};
-  Range* range{NULL};
-  void print();
-  int getCount(){return count;}
-  bool match_position(Game*game);
-  SquareMask getSquares(Game*game);
-  vnode children();
-  CVV(AttackNode);
-  AttackNode(SetBase*s, SetBase*t, Range*r);
-  void deepify(){attacking=attacking->clone();attacked=attacked->clone();}
-  bool match_count(Game*game, NumValue* value);
-  virtual bool isSet();
-  virtual bool isCountable();
-};
-
-class OrNode: public SetBase{
- public:
-  MFilter* clause1{NULL};
-  MFilter* clause2{NULL};
-  bool match_position(Game*g);
-  OrNode(MFilter*c1, MFilter*c2);
-  vnode children(){return vnode{clause1,clause2};}
-  void print();
-  CVV(OrNode);
-  void deepify(){clause1=clause1->clone();clause2=clause2->clone();}
-  SquareMask getSquares(Game*g);
-  bool isSet();
-};
-
-class OnNode: public SetBase{
- public:
-  SetBase* clause1{NULL};
-  SetBase* clause2{NULL};
-  SquareMask getSquares(Game*g);
-  OnNode(SetBase* s1, SetBase* s2);
-  vnode children(){return vnode{clause1,clause2};}
-  void print();
-  CVV(OnNode);
-  void deepify(){clause1=clause1->clone();clause2=clause2->clone();}
-};
-
-
-class ExistsNode: public SetBase{
- private:
-  bool match_filters(squareT,Game*);
- public:
-  SquareVariable*variable{NULL};
-  vector<MFilter*> filters;
-  SetBase*target{NULL};
-  CVV(ExistsNode);
-  vnode children();
-  SquareMask getSquares(Game*game);
-  void print();
-  ExistsNode(SquareVariable*v, SetBase*target, vector<Node*> nodes);
-  void deepify(){clonevec(filters);if(target)target=target->clone();}
-};
-
-
-class ForallNode: public MFilter{
- public:
-  SquareVariable*variable{NULL};
-  SetBase*target{NULL};
-  vector<MFilter*>filters;
-  CVV(ForallNode);
-  vnode children();
-  bool match_position(Game*game);
-  ForallNode(SquareVariable*v,SetBase*target,vector<Node*>nodes);
-  void print();
-  void deepify(){if(target)target=target->clone();clonevec(filters);}
-};
-
-class RayNode: public SetBase, public Countable{
- private:
-  bool match_starting(squareT square, Direction direction, Game*game);
-  int count{0};
-  SquareMask matchedSoFar;
-  vector<SquareMask> designatorMasks;
- public:
-  vector<SetBase*> designators;
-  vector<Direction>directions;
-  bool isAttack{false};
-  bool match_position(Game*game);
-  RayNode(vector<Direction>directions,
-	  vector<SetBase*> ds,
-	  bool isattack,
-	  Range*r);
-  CVV(RayNode);
-  void print();
-  vnode children();
-  Range*range{NULL};
-  void deepify(){clonevec(designators);}
-  void transform_members(Transform*t);
- bool match_count(Game*game, NumValue* value);
- SquareMask getSquares(Game*game);
- bool isSet();
- bool isCountable();
-};
-
-
-class AssignNode: public MFilter{
- public:
-  NumericVariable* variable{NULL};
-  Countable* node{NULL};
-  bool match_position(Game*game);
-  CVV(AssignNode);
-  vnode children();
-  void print();
-  AssignNode(NumericVariable*, Node*);
-  void deepify(){node=node->clone();}
-};
-  
-  
-class MoveBase:public SetBase, public VariationFlags{
- public:
-  virtual vector<simpleMoveT*> getMoves(Game*game)=0;
-  SetBase* from{NULL};
-  SetBase* to{NULL};
-  PieceLoc* promote{NULL};
-  SetBase* enpassantsquare{NULL};
-  bool primaryMove{false};
-  bool secondaryMove{false};
-  MoveBase(SetBase*from, SetBase* to, PieceLoc* promote,SetBase* enpassant,bool nullmove,bool mainline, bool variation);
-  bool nullMove{false};
-  void print();
-  vnode children();
-  bool match_position(Game*game);
-  SquareMask getSquares(Game*game);
-  bool match_move(simpleMoveT*move, Game* game);
-  void deepify(){if(from) from=from->clone();if(to)to=to->clone();if(promote)promote=promote->clone();if(enpassantsquare)enpassantsquare=enpassantsquare->clone();}
-};
-  
-class MovePastNode:public MoveBase{
- public:
-  CVV(MovePastNode);
-  vector<simpleMoveT*>getMoves(Game*game);
-  MovePastNode(SetBase*from, SetBase*to, PieceLoc* promote, SetBase* enpassant,bool nullmove,bool mainline, bool variation);
-};
-
-class MoveFutureNode:public MoveBase{
- public:
-  CVV(MoveFutureNode);
-  MoveFutureNode(SetBase*from, SetBase*to, PieceLoc* promote, SetBase* enpassant,bool nullmove, bool mainline, bool variation);
-  vector<simpleMoveT*>getMoves(Game*game);
-  int requiredIndex=-1 ; // used by FutureNode: only examine this child
-  simpleMoveT* requiredMove=NULL; // used by Future Node
-};
-
-class MoveLegalNode:public MoveBase{
- public:
-  CVV(MoveLegalNode);
-  MoveLegalNode(SetBase*from, SetBase*to, PieceLoc* promote, SetBase* enpassant,bool nullmove, bool mainline, bool variation);
-  vector<simpleMoveT*>getMoves(Game*game);
-};
-
-class MoveNumberNode: public MFilter, public Countable {
- public:
-  Range*range{NULL};
-  CVV(MoveNumberNode);
-  MoveNumberNode(Range*r);
-  vnode children(){return vnode{};}
-  bool match_position(Game*game);
-  bool match_count(Game*game, NumValue*n);
-  void print();
-};
-
-    
-
-class CqlNode : public Node,public VariationFlags, public CommentFlags{
- public:
-  MFilter* filter{NULL};
-  vector<GameFilter*> gamefilters;
-  vector<NumericVariable*> sortfields;
-  int currentGameNumber{0};
-  bool usemarks{false};
-  const char* inputfile{NULL};
-  const char* outputfile{NULL};
-  FILE*outputstream{NULL};
-  Range* nmatchesrange{NULL};
-  Range* gamenumberrange{NULL};
-  Range* matchCountRange{NULL};
-  void setChildVariations(); //must be called after variationflags is set
-  void match();
-  bool match_game(Game*game);
-  void do_match(MFilter*p, Game*game);
-  void print();
-  CVV(CqlNode);
-  vnode children();
-  CqlNode(vector<Node*> features,Node* node);
-  virtual ~CqlNode() {}
-  void run();
-  void setUseMarks();
-  void deepify(){filter=filter->clone();clonevec(gamefilters);}
-  void setFirstComment(Game*game);
-  void annotateEchoes(Game*game);
-  GameSortInfo makeInfo(Game*game);
-  static const char * outputFileFromCqlFile(const char* cqlfile);
-};
-
-class FutureStarNode : public MFilter, public Countable, public VariationFlags, public CommentFlags{
- private:
-  int count{0};
-  int depthMax{-1};
-  void compute_counts(Game*game,vector<moveT*>&, int depth);
- public:
-  MFilter* filter{NULL};
-  Range* range{NULL};
-  CVV(FutureStarNode);
-  void print();
-  int getCount(){return count;}
-  bool match_count(Game*game, NumValue* value);
-  vnode children(){return vnode{filter};}
-  void deepify(){filter=filter->clone();}
-  bool match_position(Game*game);
-  FutureStarNode(Node*,Range*, int maxdepth);
-};
-
-class PastStarNode : public MFilter, public Countable, public CommentFlags{
- private:
-  int count{0};
-  void compute_counts(Game*game,vector<moveT*>&,int depth);
-  int depthMax{-1};
- public:
-  MFilter* filter{NULL};
-  Range* range{NULL};
-  CVV(PastStarNode);
-  void print();
-  int getCount(){return count;}
-  bool match_count(Game*game, NumValue* value);
-  vnode children(){return vnode{filter};}
-  void deepify(){filter=filter->clone();}
-  bool match_position(Game*game);
-  PastStarNode(Node*,Range*,int depth);
-};
-
-
-class PieceIdNode : public SetBase{
- public:
-  TagVariable*variable{NULL};
-  SetBase* set{NULL};
-  vector<MFilter*>filters;
-  SquareMask getSquares(Game*game);
-  CVV(PieceIdNode);
-  void print();
-  PieceIdNode(TagVariable *v, SetBase* set,vector<Node*>fs);
-  vnode children();
-  void deepify(){if(set)set=set->clone();clonevec(filters);}
-};
-
-
-class VectorNode : public SetBase{
- public:
-  DirectionParameter parameter;
-  SetBase* source{NULL};
-  CVV(VectorNode);
-  void print();
-  vnode children();
-  bool match_position(Game*game);
-  SquareMask getSquares(Game*game);
-  VectorNode(DirectionParameter dp,SetBase* source);
-  void deepify(){source=source->clone();}
-  void transform_members(Transform*);
- private:
-  SquareMask neighborhoods[64];
-  bool neighborhoodsvalid{false};
-  void makeNeighborhoods();
-  
-};
-
-class TransformNode: public SetBase, public Countable{
- private:
-  TransformNode(vector<Transform*> ts,MFilter*f,Range*range);
- public:
-  vector<Transform*> transforms;
-  static TransformNode* create(vector<Transform*>, Node*, Range*);
-  MFilter* filter{NULL};
-  int count{0};
-  Range*range{NULL};
-  vector<MFilter*> transformedFilters;
-  void print();
-  vnode children();
-  void expand();
-  void deepify();
-  void transform_in_place(Transform*t);
-  bool expanded();
-  SquareMask getSquares(Game*game);
-  virtual bool isSet();
-  virtual bool isCountable();
-  CVV(TransformNode);
-  vector<Transform*> getTransforms(){return transforms;}
-  MFilter* getSource(){return filter;}
-  bool match_position(Game*game);
-  bool match_count(Game*game, NumValue*value);
-};
-
-
-class BetweenNode: public SetBase {
- public:
-  SetBase* source{NULL};
-  SetBase* target{NULL};
-  void print();
-  //  bool match_square(squareT square, Game*game);
-  SquareMask getSquares(Game*game);
-  CVV(BetweenNode);
-  void deepify(){source=source->clone();target=target->clone();}
-  vnode children(){return vnode{source,target};}
-  BetweenNode(SetBase*s,SetBase*t);
-};
-
-class ExtensionNode:public MFilter{
- public:
-  CVV(ExtensionNode);
-  bool match_position(Game*game);
-  vnode children(){return vnode{};}
-  void print();
-  ExtensionNode(){};
-};
-
-class PowerNode: public MFilter, public Countable {
- public:
-  SetBase* set{NULL};
-  Range*range{NULL};
-  int power{-1000};
-  void print();
-  bool match_count(Game*game, NumValue*value);
-  CVV(PowerNode);
-  void deepify(){set=set->clone();}
-  vnode children(){return vnode{set};}
-  PowerNode(SetBase*s,Range*r);
-  bool match_position(Game*game);
-  static int pieceValue(pieceT p);
-};
-
-class PowerDifferenceNode: public MFilter, public Countable {
- public:
-  PowerNode* power1{NULL};
-  PowerNode* power2{NULL};
-  Range*range{NULL};
-  int powerdifference{-1000};
-  void print();
-  bool match_count(Game*game, NumValue*value);
-  CVV(PowerDifferenceNode);
-  void deepify(){power1=power1->clone();power2=power2->clone();}
-  vnode children(){return vnode{power1,power2};}
-  PowerDifferenceNode(SetBase*,SetBase*,Range*);
-  bool match_position(Game*game);
-  static int pieceValue(pieceT p);
-};
-
-class MatchCommentNode: public MFilter{
- public:
-  const char* value{NULL};
-  MatchCommentNode(const char* v);
-  CVV(MatchCommentNode);
-  void print();
-  vnode children(){return vnode{};}
-  bool match_position(Game*game);
-};
-
-class CommentBase: public MFilter{
- public:
-  bool match_position(Game*game);
-  virtual void printBuffer(Game*g,char*buffer)=0;
-  static const int maxLen=200;
-};
-
-class CommentString:public CommentBase{
- public:
-  void printBuffer(Game*g, char*buffer);
-  const char*str;
-  CommentString(const char*s);
-  CVV(CommentString);
-  vnode children(){return vnode{};}
-  void print();
-};
-
-class CommentSet:public CommentBase{
- public:
-  CommentSet(SetBase*);
-  void printBuffer(Game*g,char*buffer);
-  SetBase*set{NULL};
-  CVV(CommentSet);
-  void deepify(){set=set->clone();}
-  vnode children(){return vnode{set};}
-  void print();
-};
-
-
-#include "transform.h"
-#include "seqconstituent.h"
-#include "sequence.h"
-class EchoNode;
-class EchoSpec;
-class EchoLcaSpec;
-class EchoDistanceSpec;
-class EchoSquareSpec;
-class EchoMaxDistanceSpec;
-class EchoSumDistanceSpec;
-class EchoSourceDistanceSpec;
-class EchoTargetDistanceSpec;
-class EchoLongestSubstringSpec;
-#include "echomatchinfo.h"
-#include "echonode.h"
-#include "echospec.h"
-#undef CVV
Index: src/cql/nodematch.cpp
===================================================================
--- src/cql/nodematch.cpp	(revision 2842)
+++ src/cql/nodematch.cpp	(working copy)
@@ -1,1021 +1 @@
-#include "node.h"
-#include "tokenstream.h"
 
-Node* Tokens::match_basicnode(){
-  Node * node=match_basicnode_no_suffix();
-  if(!node) return NULL;
-  OrNode*ornode=match_ornode(node);
-  if(ornode) return ornode;
-
-  OnNode*onnode=match_onnode(node);
-  if(onnode) return onnode;
-
-  return node;
-}
-
-OrNode* Tokens::match_ornode(Node*prefix){
-  uassert(prefix,"match_ornode internal");
-  if(!match_keyword("or"))return NULL;
-  Node*suffix=match_basicnode();
-  if(!suffix)
-    show_error("expecting a filter following 'or'");
-  MFilter*clause1=dynamic_cast<MFilter*>(prefix);
-  MFilter*clause2=dynamic_cast<MFilter*>(suffix);
-  if(!clause1||!clause2)
-    show_error("invalid form of 'or' clause: illegal left or right clause");
-  return new OrNode(clause1,clause2);
-}
-
-OnNode* Tokens::match_onnode(Node*prefix){
-  if(!match_keyword("on"))return NULL;
-  uassert(prefix,"unexpected OnNode arg");
-  SetBase* s1=dynamic_cast<SetBase*>(prefix);
-  if(!s1||!s1->isSet())
-    show_error("left argument to 'on' is not a set filter");
-  Node* suffix=match_set();
-  if(!suffix)
-    show_error("missing right argument to 'on'");
-  SetBase* s2=dynamic_cast<SetBase*>(suffix);
-  if(!s2||!s2->isSet())
-    show_error("right argument to 'on' is not a set filter");
-  return new OnNode(s1,s2);
-}
-
-Node* Tokens::match_basicnode_no_suffix(){
-  Node*n=NULL;
-  if(!n) n=match_simplenode();
-  if(!n) n=match_compoundnode();
-  return n;
-}
-
-
-Node* Tokens::match_compoundnode(){
-  Node*n=NULL;
-  if(!n) n=match_anynode();
-  if(!n) n=match_attacknode();
-  if(!n) n=match_betweennode();
-  if(!n) n=match_commentbase();
-  if(!n) n=match_countsquaresnode();
-  if(!n) n=match_echonode();
-  if(!n) n=match_elonode();
-  if(!n) n=match_eventnode();
-  if(!n) n=match_existsnode();
-  if(!n) n=match_extensionnode();
-  if(!n) n=match_forallnode();
-  if(!n) n=match_futurestarnode();
-  if(!n) n=match_matchcommentnode();
-  if(!n) n=match_movebase();
-  if(!n) n=match_movenumbernode();
-  if(!n) n=match_notnode();
-  if(!n) n=match_originnode();
-  if(!n) n=match_paststarnode();
-  if(!n) n=match_pieceidnode();
-  if(!n) n=match_pieceloc();
-  if(!n) n=match_playernode();
-  if(!n) n=match_positionnode();
-  if(!n) n=match_powerdifferencenode();
-  if(!n) n=match_powernode();
-  if(!n) n=match_raynode();
-  if(!n) n=match_resultnode();
-  if(!n) n=match_sequencenode();
-  if(!n) n=match_silent();
-  if(!n) n=match_sitenode();
-  if(!n) n=match_sortbodynode();
-  if(!n) n=match_transformnode();
-  if(!n) n=match_yearnode();
-  if(!n)n=match_vectornode();
-  return n;
-}
-Node* Tokens::match_silent(){
-  if(!match_keyword("silent")) return NULL;
-  Node* n = match_basicnode();
-  if(!n)
-    show_error("silent keyword must be followed by a filter to make silent (relation, next, next*, previous, previous*");
-  CommentFlags*cf=dynamic_cast<CommentFlags*>(n);
-  if(!cf)
-    show_error("silent keyword must be followed by one of: relation, next, next*, previous, previous*");
-  cf->makeSilent();
-  return n;
-}
-
-SilentFeatureNode* Tokens::match_silentfeature(){
-  if (match_keyword("silent"))return new SilentFeatureNode();
-  return NULL;
-}
-
-Node* Tokens::match_cqlfeature(){
-  Node*n=NULL;
-  if(!n)n=match_pgnnode();
-  if(!n)n=match_resultnode();
-  if(!n)n=match_gamenumbernode();
-  if(!n) n=match_outputnode();
-  if(!n) n=match_variationsnode();
-  if(!n) n=match_matchcountnode();
-  if(!n) n=match_silentfeature();
-  if(!n)n=match_playernode();
-  if(!n)n=match_elonode();
-  if(!n)n=match_yearnode();
-  if(!n)n=match_sitenode();
-  if(!n)n=match_eventnode();
-  return n;
-}
-
-MoveNumberNode* Tokens::match_movenumbernode(){
-  KeywordToken* k=match_keyword(":movenumber");
-  if(!k) return NULL;
-  Range* r=match_range();
-  if(!r) show_error(":movenumber expected range but got: ");
-  return new MoveNumberNode(r);
-}
-
-GameNumberNode* Tokens::match_gamenumbernode(){
-  int x=save();
-  if(match_keyword(":gamenumber")){
-    Range* r=match_range();
-    if(r) return new GameNumberNode(r);
-  }
-  restore(x);
-  return NULL;
-}
-
-CqlNode* Tokens::match_cqlnode(){
-  if(!match_keyword("cql")) 
-    show_error("Expected 'cql' word to start :cql specification but got: ");
-  if(!match_lparen())
-    show_error("Expected left paren following the 'cql' keyword");
-  vector<Node*> features=match_some_cqlfeatures();
-  //if(features.empty())
-    //show_error("Empty CQL specification");
-  
-  if(!match_rparen())
-    show_error("Syntax error while parsing the CQL specification. Expected right paren.");
-  vector<Node*> nodes=match_some_basicnodes();
-  if(nodes.empty())
-    show_error("Expected one or more filters following CQL specification, got none");
-  if(!eof())
-    show_error("Extra text following the filters after the CQL specification, or unspecified syntax error");
-  Node*node=NULL;
-  if(nodes.size()>1)
-    node=new PositionNode(nodes);
-  else
-    node=nodes.at(0);
-  CqlNode*n=new CqlNode(features,node);
-  return n;
-}
-
-
-//match_positionnode returns the contents of {x} if x is just one form
-Node* Tokens::match_positionnode(){
-  vector<Node*> nodes;
-  int x=save();
-  if (match_repeat_range()){
-    restore(x);
-    return NULL;
-  }
-  if(!match_lbrace()) return NULL;
-  nodes=match_some_basicnodes();
-  if(nodes.size()==0)
-    show_error("syntax error following a '{' : expected a filter");
-  bool rp=match_rbrace();
-  if(!rp)
-    show_error("Syntax error while trying to parse list of filters, expecting right brace");
-  if(nodes.size()==1)
-    return nodes.at(0);
-  return new PositionNode(nodes);
-}
-
-
-
-NotNode* Tokens::match_notnode(){
-  if(!match_keyword(":not")) return NULL;
-  Node*node=match_basicnode();
-  return new NotNode(node);
-}
-
-RayNode* Tokens::match_raynode(){
-  if(!match_keyword("ray")) return NULL;
-  bool isattack=false;
-  Range* range=match_range();
-  vector<Direction> directions=match_raydirections(&isattack);
-  if (directions.empty())
-    directions=Direction::allDirections();
-  if(!match_lparen())
-    show_error("Expecting '(' character after list of directions in the ray");
-  vector<Node*>nodes=match_some_basicnodes();
-  vector<SetBase*>constituents;
-  for(auto node:nodes)
-    constituents.push_back(dynamic_cast<SetBase*>(node));
-  for(auto set:constituents)
-    if(!set||!set->isSet())
-      show_error("All parameters to ray must be sets");
-  if(!match_rparen())
-    show_error("Expected ')' character after arguments to ray");
-  uassert(constituents.size()>1,"Must have at least two arguments to a ray");
-  return new RayNode(directions,
-		     constituents,
-		     isattack,
-		     range);
-}
-
-vector<Direction> Tokens::match_raydirections(bool*isattack){
-  vector<Direction> directions;
-  if (match_keyword("attack")||match_keyword("attacks")){
-    directions=Direction::allDirections();
-    *isattack=true;
-    return directions;
-  }
-  *isattack=false;
-  while(true){
-    StringToken *token=dynamic_cast<StringToken*>(current());
-    if(!token) break;
-    vector<Direction> these=Direction::directionsFromString(token->value);
-    if(these.empty()) break;
-    forward();
-    for(auto d:these){
-      for(auto seen:directions)
-	uassert(!d.eq(seen),"Duplicate directions in ray specification");
-      directions.push_back(d);
-    }
-  }
-  return directions;
-}
-
-      
-vector<directionT>Tokens::directionsFromRayKeyword(KeywordToken *k){
-  uassert(k);
-  if(k->eq(":rayorthogonal"))
-    return vector<directionT>{UP, DOWN, LEFT, RIGHT};
-  else if (k->eq(":raydiagonal"))
-    return vector<directionT>{UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT};
-  else if (k->eq(":rayattack")||k->eq(":ray"))
-    return vector<directionT>{
-      UP, DOWN, LEFT, RIGHT,
-	UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT};
-  uassert(false, "Unknown ray keyword: ", k->value);
-  return vector<directionT>{};
-}
-    
-AttackNode* Tokens::match_attacknode(){
-  bool keyword=(match_keyword(":attack")||match_keyword(":attacks"));
-  if(!keyword) return NULL;
-  Range *r=match_range();
-  if(!match_lparen())
-    show_error("'attack' expects left paren before the attacker and the attacked specifictions");
-  SetBase *p1=match_set();
-  if (!p1)
-    show_error("missing set filter following 'attack' after the '('");
-  SetBase*p2=match_set();
-  uassert(p2&&p2->isSet(),"Two set specifiers must follow :attack but only one was found");
-  if(!match_rparen())
-    show_error("'attack' expects right paren following the attacker and attacked specifications");
-  return new AttackNode(p1,p2,r);
-}
-
-Node* Tokens::match_simplenode(){
-  if(match_keyword(":check"))
-    return new CheckNode();
-  if(match_keyword(":stalemate"))
-    return new StalemateNode();
-  if(match_keyword(":mate"))
-    return new MateNode();
-  if(match_keyword(":wtm"))
-    return new ColorNode(WHITE);
-  if(match_keyword(":btm"))
-    return new ColorNode(BLACK);
-  if(match_keyword(":initial"))
-    return new InitialNode();
-  if(match_keyword("variation"))
-    return new InVariationNode();
-  if(match_keyword("beginvariation"))
-    return new BeginVariationNode();
-  if(match_keyword("mainline"))
-    return new InMainlineNode();
-  if(match_keyword("terminal"))
-    return new TerminalNode();
-  return NULL;
-}
-
-VariationsNode* Tokens::match_variationsnode(){
-  if(match_keyword(":variations"))
-    return new VariationsNode();
-  return NULL;
-}
-
-KeywordToken*Tokens::match_raykeyword(){
-  int x=save();
-  char*keys[]={":ray",":rayorthogonal",":raydiagonal",":rayattack"};
-  size_t nkeys = sizeof(keys)/sizeof(char*);
-  KeywordToken *t=match_keyword();
-  if(!t)return NULL;
-  for(int i=0;i<nkeys;++i)
-    if(t->eq(keys[i]))return t;
-  restore(x);
-  return NULL;
-}
-
-
-TransformNode* Tokens::match_transformnode(){
-  TransformNode*t=NULL;
-  if(!t) t=match_fliptransform();
-  if(!t) t=match_shifttransform();
-  return t;
-}
-
-NumericVariable* Tokens::match_optionalnumericvariable(bool ismax){
-  const char*name=match_quotedstring();
-  if(!name){
-  int nextid=Tokens_match_optional_numericvariable_nextid++; // this is a global variable
-  char buffer[100];
-  sprintf(buffer,"CQL ID-%d",nextid);
-  name=util::copy(buffer);
-  }
-  uassert(name,"internal monv");
-  return Variable::getNumericVariable(name,ismax);
-}
-
-NumericVariable* Tokens::match_sortheader(){
-  if(!match_keyword("sort"))return NULL;
-  bool ismax=true;
-  if (match_keyword("max"))
-    ismax=true;
-  else if (match_keyword("min"))
-    ismax=false;
-  NumericVariable* var=match_optionalnumericvariable(ismax);
-  uassert(var,"Unable to form numeric variable");
-  return var;
-}
-
-Node* Tokens::match_sortbodynode(){
-  NumericVariable* var=match_sortheader();
-  if(!var)return NULL;
-  Node*node=match_basicnode();
-  if(!node)
-    show_error("'sort' must be followed by optional 'max' or 'min'; then by an optional quoted string; and last by countable filter. The countable filter is missing");
-  if(!node->isCountable())
-    show_error("'sort' must be followed by optional 'max' or 'min'; then by an optional quoted string; and last by countable filter. The final filter is not a countable filter");
-  return new AssignNode(var,node);
-}
-
-  
-MatchCountNode* Tokens::match_matchcountnode(){
-  bool sort=false;
-  if (match_keywords("sort","matchcount"))
-    sort=true;
-  else if(!match_keyword("matchcount"))
-    return NULL;
-  Range * range= match_range();
-  if(!range)
-    show_error("missing range, eg. '1 20', following 'matchcount' keyword");
-  return new MatchCountNode(range,sort);
-}
-  
-PgnNode* Tokens::match_pgnnode(){
-  if(match_keyword("pgn")||match_keyword("input")){
-    StringToken*name=match_string();
-    if(!name)show_error("Missing filename in :pgn specification");
-    const char* filename= name->value;
-    if(CqlPgnFilename){
-#ifdef STANDALONE
-      printf("Using command line argument pgn filename: %s\n",CqlPgnFilename);
-#endif
-      filename=CqlPgnFilename;
-    }
-    uassert(filename);
-    if(!filename_is_pgn(filename)){
-      fprintf(stderr,"Invalid pgn filename (must end in .pgn or .PGN): %s\n",filename);
-      show_error("bad pgn filename");
-    }
-    return new PgnNode(filename);
-  }
-  return NULL;
-}
-
-OutputNode* Tokens::match_outputnode(){
-  if(match_keyword(":output") || match_keyword(":out")){
-    StringToken*name=match_string();
-    if(!name)show_error("Missing filename in :output specification");
-    const char* filename=name->value;
-    uassert(filename);
-    if(CqlOutputFilename){
-      printf("Using command line argument for filename: %s\n",CqlOutputFilename);
-      filename=CqlOutputFilename;
-    }
-    uassert(filename);
-    if(!filename_is_pgn(filename)){
-      fprintf(stderr,"Invalid pgn filename (must end in .pgn or .PGN): %s\n",filename);
-      show_error("bad output filename");
-    }
-    return new OutputNode(filename);
-  }
-  return NULL;
-}
-
-
-PlayerNode* Tokens::match_playernode(){
-  if(!match_keyword("player"))
-    return NULL;
-  colorT color=match_color();
-  const char* name=match_quotedstring();
-  if(!name)
-    show_error("'player' must be followed by a quoted string");
-  return new PlayerNode(name,color);
-}
-
-EventNode* Tokens::match_eventnode(){
-  if(!match_keyword("event"))
-    return NULL;
-  const char* name=match_quotedstring();
-  if(!name)
-    show_error("'event' must be followed by a quoted string");
-  return new EventNode(name);
-}
-
-SiteNode* Tokens::match_sitenode(){
-  if(!match_keyword("site"))
-    return NULL;
-  const char* name=match_quotedstring();
-  if(!name)
-    show_error("'site' must be followed by a quoted string");
-  return new SiteNode(name);
-}
-
-EloNode* Tokens::match_elonode(){
-  if(!match_keyword("elo"))
-    return NULL;
-  colorT color=match_color();
-  Range*range=match_range();
-  if(!range)
-    show_error("'elo' must be followed by an optional color and a range");
-  return new EloNode(range,color);
-}
-
-YearNode* Tokens::match_yearnode(){
-  if(!match_keyword("year"))
-    return NULL;
-  Range*range=match_range();
-  if(!range)
-    show_error("'year' must be followed by a range");
-  return new YearNode(range);
-}
-
-ResultNode* Tokens::match_resultnode(){
-  if(!match_keyword(":result"))
-    return NULL;
-  StringToken*name=NULL;
-  if(!name ) name=match_string("1-0");
-  if(!name) name=match_string("0-1");
-  if(!name) name=match_string ("1/2-1/2");
-  uassert(name,"expecting 1-0 or 0-1 or 1/2-1/2 following :result");
-  return new ResultNode(name->value);
-}
-
-
-StringToken* Tokens::match_string(char* v){
-  uassert(v!=NULL);
-  int x=save();
-  StringToken*n=match_string();
-  if(n && n->eq(v))
-    return n;
-  restore(x);
-  return NULL;
-}
-    
-StringToken*Tokens::match_string(){
-  StringToken*n=dynamic_cast<StringToken*>(current());
-  if(n)forward();
-  return n;
-}
-
-vector<Node*> Tokens::match_some_cqlfeatures(){
-  vector<Node*>v;
-  while(true){
-    Node* n=match_cqlfeature();
-    if(!n) break;
-    v.push_back(n);
-  }
-  return v;
-}
-
-vector<Node*> Tokens::match_some_basicnodes(){
-  vector<Node*>v;
-  while(true){
-    Node* n=match_basicnode();
-    if(!n) break;
-    v.push_back(n);
-  }
-  return v;
-}
-
-ForallNode*Tokens::match_forallnode(){
-  if(!match_keywords("square", "all"))
-    return NULL;
-  SquareVariable*sv=match_squarevariable();
-  uassert(sv,"Expecting a square variable in 'forall' keyword specification");
-  SetBase* target=match_inexpr();
-  vector<Node*>nodes=match_some_basicnodes();
-  return new ForallNode(sv,target,nodes);
-}
-
-
-      
-
-KeywordToken* Tokens::match_keyword(const char *v){
-  KeywordToken* t=dynamic_cast<KeywordToken*>(current());
-  if(!t)return NULL;
-  if( !t->eq(v)) return NULL;
-  forward();
-  return t;
-}
-
-bool Tokens::match_keywordstar(const char *name){
-  int x=save();
-  if (match_keyword(name)&&match_star())
-    return true;
-  restore(x);
-  return false;
-}
-
-bool Tokens::match_keywords(const char *v1, const char*v2){
-  int x=save();
-  if(match_keyword(v1)&&match_keyword(v2)) return true;
-  restore(x);
-  return false;
-}
-
-
-KeywordToken* Tokens::match_keyword(){
-  KeywordToken* t=dynamic_cast<KeywordToken*>(current());
-  if(t) forward();
-  return t;
-}
-
-bool Tokens::match_bar(){
-  BarToken* t=dynamic_cast<BarToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-bool Tokens::match_lparen(){
-  LParenToken* t=dynamic_cast<LParenToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-bool Tokens::match_star(){
-  StarToken* t=dynamic_cast<StarToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-bool Tokens::match_questionmark(){
-  QuestionMarkToken* t=dynamic_cast<QuestionMarkToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-bool Tokens::match_plus(){
-  PlusToken* t=dynamic_cast<PlusToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-bool Tokens::match_lbrace(){
-  LBraceToken* t=dynamic_cast<LBraceToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-bool Tokens::match_rparen(){
-  RParenToken* t=dynamic_cast<RParenToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-bool Tokens::match_rbrace(){
-  RBraceToken* t=dynamic_cast<RBraceToken*>(current());
-  if(!t)return false;
-  forward();
-  return true;
-}
-
-
-PieceLoc* Tokens::match_pieceloc(){
-  PieceDesignatorToken* t =
-    dynamic_cast<PDT*>(current());
-  if(!t) return NULL;
-  else
-    forward();
-  if(t->pieceloc) return t->pieceloc;
-  PieceLoc*p=new PieceLoc(t->pieces,
-			  t->squares,
-			  t->variables);
-  t->pieceloc=p;
-  return p;
-}
-
-Range* Tokens::match_range(){
-  Range* r=match_compoundrange();
-  if(r) return r;
-  IntToken*ip=match_int();
-  if(!ip) return NULL;
-  return new Range(ip->value);
-}
-
-Range* Tokens::match_compoundrange(){
-  int x=save();
-  IntToken* minp=match_int();
-  if(minp){
-    IntToken* maxp=match_int();
-    if(maxp)
-      return new Range(minp->value,maxp->value);
-  }
-  restore(x);
-  return NULL;
-}
-
-IntToken* Tokens::match_int(){
-  IntToken *ip=dynamic_cast<IntToken*>(current());
-  if(ip) forward();
-  return ip;
-}
-
-MoveBase* Tokens::match_movebase(){
-  bool past=false;
-  bool future=false;
-  past=match_keywords("move", "previous");
-  if(!past)
-    future=match_keyword("move");
-  if (!past&&!future)return NULL;
-  uassert (past||future,"match_movebase internal pf");
-
-  bool legal=false;
-  bool nullmove=false;
-  bool primaryMove=false;
-  bool secondaryMove=false;
-  SetBase* from=NULL;
-  SetBase* to=NULL;
-  PieceLoc* promote=NULL;
-  SetBase* epcapture=NULL;
-  while(true)
-    if (match_keyword("null"))
-      nullmove=true;
-    else if (match_keyword("primary"))
-      primaryMove=true;
-    else if (match_keyword("secondary"))
-      secondaryMove=true;
-    else if (from==NULL &&
-	     ((from=match_fromexp())!=NULL));
-    else if (to==NULL &&
-	     ((to=match_toexp())!=NULL));
-    else if (promote==NULL&&
-	     ((promote=match_promoteexp())!=NULL));
-    else if (epcapture==NULL&&
-	     ((epcapture=match_enpassantexp())!=NULL));
-    else break;
-  if (nullmove&&(from||to||promote||epcapture))
-      show_error("cannot use null with 'from', 'to', 'promote', or 'enpassant'");
-  if(epcapture&&promote)
-    show_error("cannot have a move that is both an en passant capture and a promotion");
-  if (past)
-    return new MovePastNode(from,to,promote,epcapture,nullmove,primaryMove,secondaryMove);
-  else if(future)
-    return new MoveFutureNode(from,to,promote,epcapture,nullmove,primaryMove,secondaryMove);
-  else if (legal)
-    return new MoveLegalNode(from,to,promote,epcapture,nullmove,primaryMove,secondaryMove);
-  else uassert(false,"match_movebase");
-  return NULL;
-}
-  
-  
-SetBase* Tokens::match_enpassantexp(){
-  if (match_keyword("enpassant"))
-    return new AnyNode();
-  if (match_keyword("enpassantsquare")){
-    SetBase*s=match_set();
-    if(!s)
-      show_error("expecting a set specifier following 'enpassantsquare' in 'move'");
-    return s;
-  }
-  return NULL;
-}
-
-SetBase* Tokens::match_fromexp(){
-  if(!match_keyword("from"))
-    return NULL;
-  SetBase* s=match_set();
-  if(!s)
-    show_error("missing set specifier in move from");
-  return s;
-}
-
-SetBase* Tokens::match_toexp(){
-  if(!match_keyword("to"))
-    return NULL;
-  SetBase* s=match_set();
-  if(!s)
-    show_error("missing set specifier in move to");
-  return s;
-}
-
-PieceLoc* Tokens::match_promoteexp(){
-  if(!match_keyword(":promote"))
-    return NULL;
-  PieceLoc* p=match_pieceloc();
-  if(!p) show_error("missing set specifier in :move :promote");
-  if(!p->isPurePiece())
-    show_error("The promoted piece must be just a piece or set of pieces without square designators, e.g. 'promote R' or 'promote [RN]' ");
-  return p;
-}
-
-
-    
-SquareVariable*Tokens::match_squarevariable(){
-  PDT* t=
-    dynamic_cast<PDT*>(current());
-  if(!t)return NULL;
-  VariableToken*vt=t->getAsVariableToken();
-  if(!vt)return NULL;
-  const char *name=vt->value;
-  uassert(vt);
-  SquareVariable*sv=Variable::getSquareVariable(name);
-  uassert(sv,"match_squarevariable, internal",name);
-  forward();
-  return sv;
-}
-
-TagVariable*Tokens::match_tagvariable(){
-  PDT* t=
-    dynamic_cast<PDT*>(current());
-  if(!t)return NULL;
-  VariableToken*vt=t->getAsVariableToken();
-  if(!vt)return NULL;
-  const char *name=vt->value;
-  uassert(vt);
-  TagVariable*tv=Variable::getTagVariable(name);
-  uassert(tv,"match_tagvariable, internal",name);
-  forward();
-  return tv;
-}
-
-
-void Tokens::show_error(const char* message){
-  printf("\n**SYNTAX ERROR** %s\n",message);
-  if(eof())printf("unexpected end of file\n");
-  else {
-    printf ("Unable to parse the following token: ");
-    current()->print();
-    printf("\n");
-  }
-  uassert(false, message);
-}
-
-VectorNode* Tokens::match_vectornode(){
-  DirectionParameter*p=match_directionparameter();
-  if(!p)return NULL;
-  SetBase*source=match_set();
-  if(!source)
-    show_error("expecting a set specifier following the direction parameter");
-  return new VectorNode(*p,source);
-}
-
-vector<Direction>Tokens::match_direction(){
-  StringToken*token=dynamic_cast<StringToken*>(current());
-  if(!token)return vector<Direction>{};
-  const char* v=token->value;
-  uassert(v,"internal match_directionparameter");
-  vector<Direction> directions=Direction::directionsFromString(v);
-  if(directions.empty()){
-    return directions;
-  }
-  forward();
-  return directions;
-}
-  
-DirectionParameter* Tokens::match_directionparameter(){
-  vector<Direction> directions=match_direction();
-  if(directions.empty())return NULL;
-  Range *range=match_range();
-  if (!range) range= new Range(1,7);
-  DirectionParameter*p=new DirectionParameter(directions,range);
-  return p;
-}
-
-FutureStarNode* Tokens::match_futurestarnode(){
-  int depth=-1;
-  if(!match_keywordstar("next")) return NULL;
-  Range*range=match_range();
-  if(match_keyword("depth")){
-    Range*depthrange=match_range();
-    if(!depthrange)
-      show_error("the 'depth' keyword must be followed by a single nonnegative integer");
-    depth=depthrange->min;
-    if (depth<0||depth!=depthrange->max)
-      show_error("the 'depth' keyword must be followed by a single nonnegative integer");
-  }
-  Node*node=match_basicnode();
-  if(!node)
-    show_error("expecting a valid filter following 'next*'");
-  return new FutureStarNode(node,range,depth);
-}
-
-PastStarNode* Tokens::match_paststarnode(){
-  int depth=-1;
-  if(!match_keywordstar("previous")) return NULL;
-  Range*range=match_range();
-  if(match_keyword("depth")){
-    Range*depthrange=match_range();
-    if(!depthrange)
-      show_error("the 'depth' keyword must be followed by a single nonnegative integer");
-    depth=depthrange->min;
-    if (depth<0||depth!=depthrange->max)
-      show_error("the 'depth' keyword must be followed by a single nonnegative integer");
-  }
-  Node*node=match_basicnode();
-  if(!node)
-    show_error("expecting a valid filter following 'previous*' ");
-  return new PastStarNode(node,range,depth);
-}
-
-
-CountSquaresNode* Tokens::match_countsquaresnode(){
-  if(!match_keyword("countsquares")) return NULL;
-  Range*r=match_range();
-  if(!r)
-    show_error("The 'countsquares' keyword must be followed by a range");
-  SetBase*s=match_set();
-  if(!s)
-    show_error("Expected a set filter following 'countsquares range'");
-  return new CountSquaresNode(s,r);
-}
-  
-SetBase* Tokens::match_set(){
-  int x=save();
-  Node*n=match_basicnode();
-  if(!n)return NULL;
-  SetBase*set=dynamic_cast<SetBase*>(n);
-  if(!set||!set->isSet()){
-    restore(x);
-    return NULL;}
-  return set;
-}
-
-SetBase* Tokens::match_inexpr(){
-  if(!match_keyword("in"))
-    return NULL;
-  SetBase*ret=match_set();
-  if(!ret)
-    show_error("Expecting a set expression following the 'in' keyword in 'square' expression");
-  return ret;
-}
-
-BetweenNode* Tokens::match_betweennode(){
-  if(!match_keyword("between"))
-    return NULL;
-  if(!match_lparen())
-    show_error("arguments to 'between' should be enclosed in parens: missing '('");
-  SetBase* source=match_set();
-  if(!source)
-    show_error("Expected a source set following 'between'");
-  SetBase* target=match_set();
-  if(!target)
-    show_error("Expected a target set following 'between' and the source");
-  if(!match_rparen())
-    show_error("arguments to 'between' should be enclosed in parens: missing ')'");
-
-  return new BetweenNode(source,target);
-}
-
-ExtensionNode* Tokens::match_extensionnode(){
-  if(!match_keyword("extension"))
-    return NULL;
-  return new ExtensionNode();
-}
-
-AnyNode* Tokens::match_anynode(){
-  if(match_keyword("any"))
-    show_error("The 'any' keyword has been replaced by the '.' character since version 5.2. Use '_' instead of '.' to denote an empty square");
-  if(match_keyword("."))
-    return new AnyNode();
-  return NULL;
-}
-
-PowerNode* Tokens::match_powernode(){
-  if(!match_keyword("power"))
-    return NULL;
-  Range*range=match_range();
-  if(!range)
-    show_error("Expected a range following 'power' ");
-  SetBase*set=match_set();
-  if(!set)
-    show_error("Expected a set following 'power' and the range");
-  return new PowerNode(set,range);
-}
-
-PowerDifferenceNode* Tokens::match_powerdifferencenode(){
-  if(!match_keyword("powerdifference"))
-    return NULL;
-  Range*range=match_range();
-  if(!range)
-    show_error("Expected a range following 'powerdifference' ");
-  if(!match_lparen())
-    show_error("Expected '(' following 'powerdifference' and range");
-  SetBase*set1=match_set();
-  if(!set1)
-    show_error("Expected a set following 'powerdifference range <'");
-  SetBase*set2=match_set();
-  if(!set2)
-    show_error("Expected another set following 'powerdifference range < set1 '");
-  if(!match_rparen())
-    show_error("Expected ')' following 'powerdifference range < set1 set2'");
-  return new PowerDifferenceNode(set1,set2,range);
-}
-
-Node* Tokens::match_existsnode(){
-  int x=save();
-  if(match_keywords("square","all")){
-    restore(x);
-    return NULL;}
-  
-  if(!match_keyword("square")) return NULL;
-  Range*range=match_range();
-  SquareVariable*sv=match_squarevariable();
-  if(!sv) show_error("Expecting a square variable in 'square' keyword specification");
-  SetBase*target=match_inexpr();
-  if(!target)
-    show_error ("Missing 'in' following the variable name in 'square' expression");
-  vector<Node*>nodes=match_some_basicnodes();
-  if(!nodes.size())
-    show_error("expected a nonzero number of nodes to test in square filter");
-  ExistsNode* existsnode=new ExistsNode(sv,target,nodes);
-  if (!range) return existsnode;
-  return new CountSquaresNode(existsnode,range);
-}
-
-Node* Tokens::match_pieceidnode(){
-  if(!match_keyword("piece"))
-    return NULL;
-  Range*range=match_range();
-  TagVariable*tv=match_tagvariable();
-  if(!tv) show_error("Expecting an id variable in 'piece' keyword specification");
-  SetBase*target=match_inexpr();
-  if(!target)
-    show_error("Expecting 'in', followed by a set, after  'piece' or 'piece' range");
-  vector<Node*>nodes=match_some_basicnodes();
-  if(!nodes.size())
-    show_error("expected a nonzero number of filters following 'in set'  in piece filter");
-  PieceIdNode* pieceidnode=new PieceIdNode(tv,target,nodes);
-  if (!range) return pieceidnode;
-  return new CountSquaresNode(pieceidnode,range);
-}
-
-OriginNode* Tokens::match_originnode(){
-  if(!match_keyword("origin"))
-    return NULL;
-  TagVariable*tag=match_tagvariable();
-  if(!tag)
-    show_error("expected a piece id following 'origin'");
-  return new OriginNode(tag);
-}
-
-MatchCommentNode* Tokens::match_matchcommentnode(){
-  if(!match_keyword("hascomment"))
-    return NULL;
-  const char * name=match_quotedstring();
-  if(!name)
-    show_error("Expected a quoted string folllowing 'hascomment'");
-  return new MatchCommentNode(name);
-}
-
-const char* Tokens::match_quotedstring(){
-  QuotedStringToken*q=dynamic_cast<QuotedStringToken*>(current());
-  if(!q) return NULL;
-  forward();
-  return q->value;
-}
-
-CommentBase* Tokens::match_commentbase(){
-  if(!match_keyword("comment"))return NULL;
-  const char* s=match_quotedstring();
-  if(s){
-    if(strlen(s)>=CommentBase::maxLen)
-      show_error("comment too long");
-    return new CommentString(s);
-  }
-  SetBase*set=match_set();
-  if(set)
-    return new CommentSet(set);
-  show_error("'comment' must be followed by either a quoted string or a set filter");
-  return NULL;
-}
-
-colorT Tokens::match_color(){
-  if (match_keyword("white"))return WHITE;
-  if (match_keyword("black"))return BLACK;
-  return NOCOLOR;
-}
Index: src/cql/nodetransform.cpp
===================================================================
--- src/cql/nodetransform.cpp	(revision 2842)
+++ src/cql/nodetransform.cpp	(working copy)
@@ -1,21 +1 @@
-#include "node.h"
-Node* Node::transform(Transform* t){
-  uassert(t);
-  Node* newfilter=clone();
-  newfilter->transform_in_place(t);
-  return newfilter;
-}
 
-void Node::transform_in_place(Transform* t){
-  for (Node* child : children())
-    child->transform_in_place(t);
-  transform_members(t);
-}
-  
-void Node::expand(){
-  for(Node* child:children()){
-    uassert(child,"null child expand");
-    child->expand();
-  }
-}
-
Index: src/cql/notnode.cpp
===================================================================
--- src/cql/notnode.cpp	(revision 2842)
+++ src/cql/notnode.cpp	(working copy)
@@ -1,33 +1 @@
-#include "node.h"
 
-NotNode::NotNode(Node*np){
-  filter=dynamic_cast<MFilter*>(np);
-  uassert(filter,"Missing or illegal argument to :not specification");
-}
-
-void NotNode::print(){
-  printf("\n");
-  tab();
-  printf("<not ");
-  indent();
-  filter->print();
-  printf(" not>");
-  unindent();
-}
-
-bool NotNode::match_position(Game*game){
-  return !filter->match_position(game);
-}
-
-
-SquareMask NotNode::getSquares(Game*game){
-  SetBase*set=dynamic_cast<SetBase*>(filter);
-  uassert(set,"NotNode: attempt to use a non-set as a set");
-  uassert(set->isSet(),"NotNode: attempt to use a non-set-filter in this instance as set filter");
-  return ~(set->getSquares(game));
-}
-
-bool NotNode::isSet(){
-  return filter->isSet();
-};
-
Index: src/cql/numericvariable.cpp
===================================================================
--- src/cql/numericvariable.cpp	(revision 2842)
+++ src/cql/numericvariable.cpp	(working copy)
@@ -1,105 +1 @@
-#include "node.h"
 
-// bool operator< (const NumericVariable& lhs, const NumericVariable& rhs)
-// {
-//   return lhs.getValue()<rhs.getValue();
-// }
-
-NumericVariable* Variable::getNumericVariable(const char*nm,bool ismax){
-  NumericVariable* ret=NULL;   
-  Variable*v=find(nm);
-  if(v) {
-    ret=dynamic_cast<NumericVariable*>(v);
-    uassert(ret,"cannot make square variable from tag variable",nm);
-    if(ret->isMax()!=ismax){
-      fprintf(stderr,"\nERROR: Attempt to locate field %s with a different max/min orientation than existing field\n",nm);
-      uassert(false,"sort field max/min inconsistency");
-    }
-    return ret;
-  }
-  return createNumericVariable(nm,ismax);
-}
-
-bool  NumericVariable::getSquare(squareT*s){
-  uassert(false,"Cannot get the square of numeric variable",name);
-  return false;
-}
-
-NumericVariable* Variable::createNumericVariable(const char*nm,bool ismax){
-  uassert(nm,"invalid null variable name");
-  uassert(!find(nm),"internal variable");
-  NumericVariable*s=new NumericVariable(nm,ismax);
-  getVariables()->push_back(s);
-  return s;
-}
-
-void NumericVariable::bindNumeric(NumValue v){
-  value=v;
-  if(isMax()){
-    extremalValue=std::max(v,extremalValue);
-    uassert(v>=extremeValue(),"bindNumeric low v");
-  }
-    else if (isMin()){
-    extremalValue=std::min(v,extremalValue);
-    uassert(v<=extremeValue(),"bindNumeric high v");
-    }
-  else
-    uassert(false,"bindNumeric internal");
-};
-
-void NumericVariable::print(){
-  printf("<%s %s %d %d %d>",thisclass(),name, getValue(),getExtremalValue(),isMax());
-}
-
-NumValue NumericVariable::getValue()const{
-  return value;
-}
-
-NumValue NumericVariable::getExtremalValue(){
-  return extremalValue;
-}
-
-void NumericVariable::clear(){
-  bindNumeric(extremeValue());
-}
-
-NumValue NumericVariable::extremeValue()const{
-  if (isMax())
-    return -100000;
-  else if (isMin())
-    return 100000;
-  else
-    uassert(false,"nvev");
-  return 0;
-}
-
-NumericVariable::NumericVariable(const char*nm, bool ismax){
-  uassert(nm);
-  name=nm;
-  theIsMax=ismax;
-  reset();
-}
-
-void NumericVariable::resetAll(){
-  vector<Variable*>* vars=Variable::getVariables();
-  for(Variable* vp : *vars){
-    NumericVariable * var=dynamic_cast<NumericVariable*>(vp);
-    if(var) var->reset();
-  }
-}
-
-void NumericVariable::reset(){
-  value=extremeValue();
-  extremalValue=extremeValue();
-}
-
-NumericVariable* Variable::matchCountVariable(){
-  NumericVariable* var=getNumericVariable("matchcount",true);
-  uassert(var&&var->isMax(),"matchcountvar");
-  return var;
-}
-
-void NumericVariable::increment(){
-  uassert(isMax(),"increment min");
-  bindNumeric(getValue()+1);
-}
Index: src/cql/onnode.cpp
===================================================================
--- src/cql/onnode.cpp	(revision 2842)
+++ src/cql/onnode.cpp	(working copy)
@@ -1,29 +1 @@
-#include "node.h"
-OnNode::OnNode(SetBase*s1, SetBase*s2){
-  clause1=s1;
-  clause2=s2;
-  uassert(clause1&&clause2&&clause1->isSet()&&clause2->isSet(),"OnNode constructor: invalid args");
-}
 
-
-void OnNode::print(){
-  printf("<%s",thisclass());
-  printf("\n");indent();tab();
-  printf("clause1: ");
-  clause1->print();
-  printf("clause1: ");
-  printf("\n");tab();
-  clause2->print();
-  printf(" %s>",thisclass());
-  unindent();
-}
-
-SquareMask OnNode::getSquares(Game*game){
-  SquareMask ret1=clause1->getSquares(game);
-  SquareMask ret2=clause2->getSquares(game);
-  SquareMask ret=ret1&ret2;
-  return ret;
-}
-
-
-
Index: src/cql/optionalconstituent.cpp
===================================================================
--- src/cql/optionalconstituent.cpp	(revision 2842)
+++ src/cql/optionalconstituent.cpp	(working copy)
@@ -1,20 +1 @@
-#include "node.h"
-OptionalConstituent::OptionalConstituent(SeqConstituent*c){
-  uassert(c,"oc");
-  constituent=c;
-}
 
-void OptionalConstituent::print(){
-  printf("<%s ",thisclass());
-  constituent->print();
-  printf(">");
-}
-
-void OptionalConstituent::setOffsets(int i){
-  setOffset(i);
-  constituent->setOffsets(i);
-}
-
-bool OptionalConstituent::matchesNull(){
-  return true;
-}
Index: src/cql/origChanges.cpp
===================================================================
--- src/cql/origChanges.cpp	(revision 2842)
+++ src/cql/origChanges.cpp	(working copy)
@@ -1,270 +1 @@
-#include "common.h"
-#include "error.h"
-#include "game.h"
-#include "position.h"
 
-#include "bytebuf.h"
-#include "textbuf.h"
-#include "stored.h"
-#include "util.h"
-
-//changes game::writetopgn...
-
-//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// Game::WritePGN():
-//      Write a game in PGN to a textbuffer.  If stopLocation is
-//      non-zero, it indicates a byte count at which the output should
-//      stop, leaving the game at that position. If it is zero, the
-//      entire game is printed and the game position prior to the
-//      WritePGN() call is restored.  So a nonzero stopLocation is used
-//      to move to a position in the game.
-//
-errorT
-Game::WritePGN_CQL (TextBuffer * tb, uint stopLocation)
-{
-    char temp [255];
-    char dateStr [20];
-    const char * newline = "\n";
-    tb->NewlinesToSpaces (false);
-    if (IsHtmlFormat()) { newline = "<br>\n"; }
-    if (IsLatexFormat()) {
-        newline = "\\\\\n";
-        tb->AddTranslation ('#', "\\#");
-        tb->AddTranslation ('%', "\\%");
-        tb->AddTranslation ('&', "\\&");
-        tb->AddTranslation ('<', "$<$");
-        tb->AddTranslation ('>', "$>$");
-        tb->AddTranslation ('_', "\\_");
-        // tb->AddTranslation ('[', "$[$");
-        // tb->AddTranslation (']', "$]$");
-    }
-    if (IsColorFormat()) {
-        newline = "<br>";
-    }
-
-    if (PgnStyle & PGN_STYLE_COLUMN) {
-        PgnStyle |= PGN_STYLE_INDENT_COMMENTS;
-        PgnStyle |= PGN_STYLE_INDENT_VARS;
-    }
-
-
-    date_DecodeToString (Date, dateStr);
-    if (IsHtmlFormat()) { tb->PrintLine("<p><b>"); }
-    if (IsLatexFormat()) { tb->PrintLine ("{\\bf"); }
-
-    if (PgnStyle & PGN_STYLE_SHORT_HEADER) {
-        // Print tags in short, 3-line format:
-
-        //if (IsHtmlFormat()) { tb->PrintString ("<font size=+1>"); }
-        if (IsLatexFormat()) { tb->PrintString ("$\\circ$ "); }
-        tb->PrintString (WhiteStr);
-        if (WhiteElo > 0) {
-            sprintf (temp, "  (%u)", WhiteElo);
-            tb->PrintString (temp);
-        }
-        switch (PgnFormat) {
-        case PGN_FORMAT_HTML:
-            tb->PrintString (" &nbsp;&nbsp; -- &nbsp;&nbsp; ");
-            break;
-        case PGN_FORMAT_Latex:
-            tb->PrintString (newline);
-            tb->PrintString ("$\\bullet$ ");
-            break;
-        default:
-            tb->PrintString ("   --   ");
-            break;
-        }
-        tb->PrintString (BlackStr);
-        if (BlackElo > 0) {
-            sprintf (temp, "  (%u)", BlackElo);
-            tb->PrintString (temp);
-        }
-        //if (IsHtmlFormat()) { tb->PrintString ("</font>"); }
-        tb->PrintString (newline);
-
-        tb->PrintString (EventStr);
-        if (!strEqual (RoundStr, "")  &&  !strEqual (RoundStr, "?")) {
-            tb->PrintString (IsHtmlFormat() ? " &nbsp;(" : " (");
-            tb->PrintString (RoundStr);
-            tb->PrintString (")");
-        }
-        tb->PrintString (IsHtmlFormat() ? "&nbsp;&nbsp; " : "  ");
-        if (IsLatexFormat()) { tb->PrintString (newline); }
-        if (!strEqual (SiteStr, "")  &&  !strEqual (SiteStr, "?")) {
-            tb->PrintString (SiteStr);
-            tb->PrintString (newline);
-        }
-
-        // Remove ".??" or ".??.??" from end of dateStr, then print it:
-        if (dateStr[4] == '.'  &&  dateStr[5] == '?') { dateStr[4] = 0; }
-        if (dateStr[7] == '.'  &&  dateStr[8] == '?') { dateStr[7] = 0; }
-        tb->PrintString (dateStr);
-
-        // Print ECO code:
-        tb->PrintString (IsHtmlFormat() ? " &nbsp; &nbsp; " : "  ");
-        if (IsLatexFormat()) { tb->PrintString ("\\hfill "); }
-        tb->PrintString (RESULT_LONGSTR[Result]);
-        if (EcoCode != 0) {
-            tb->PrintString (IsHtmlFormat() ? " &nbsp; &nbsp; " : "  ");
-            if (IsLatexFormat()) { tb->PrintString ("\\hfill "); }
-            ecoStringT ecoStr;
-            eco_ToExtendedString (EcoCode, ecoStr);
-            tb->PrintString (ecoStr);
-        }
-        tb->PrintString (newline);
-
-        // Print FEN if non-standard start:
-        if (NonStandardStart) {
-            if (IsLatexFormat()) {
-                tb->PrintString ("\n\\begin{diagram}\n");
-                DString dstr;
-                StartPos->DumpLatexBoard (&dstr);
-                tb->PrintString (dstr.Data());
-                tb->PrintString ("\n\\end{diagram}\n");
-            } else if (IsHtmlFormat()) {
-                DString dstr;
-                StartPos->DumpHtmlBoard (&dstr, HtmlStyle, NULL);
-                tb->PrintString (dstr.Data());
-            } else {
-                char fenStr [256];
-                StartPos->PrintFEN (fenStr, FEN_ALL_FIELDS);
-                sprintf (temp, "Position: %s%s", fenStr, newline);
-                tb->PrintString (temp);
-            }
-        }
-
-    } else {
-        // Print tags in standard PGN format, one per line:
-        // Note: we want no line-wrapping when printing PGN tags
-        // so set it to a huge value for now:
-        uint wrapColumn = tb->GetWrapColumn();
-        tb->SetWrapColumn (99999);
-        if (IsColorFormat()) { tb->PrintString ("<tag>"); }
-        sprintf (temp, "[Event \"%s\"]%s", EventStr, newline);
-        tb->PrintString (temp);
-        sprintf (temp, "[Site \"%s\"]%s", SiteStr, newline);
-        tb->PrintString (temp);
-        sprintf (temp, "[Date \"%s\"]%s", dateStr, newline);
-        tb->PrintString (temp);
-        sprintf (temp, "[Round \"%s\"]%s", RoundStr, newline);
-        tb->PrintString (temp);
-        sprintf (temp, "[White \"%s\"]%s", WhiteStr, newline);
-        tb->PrintString (temp);
-        sprintf (temp, "[Black \"%s\"]%s", BlackStr, newline);
-        tb->PrintString (temp);
-        sprintf (temp, "[Result \"%s\"]%s", RESULT_LONGSTR[Result], newline);
-        tb->PrintString (temp);
-
-        // Print all tags, not just the standard seven, if applicable:
-        if (PgnStyle & PGN_STYLE_TAGS) {
-            if (WhiteElo > 0) {
-                sprintf (temp, "[White%s \"%u\"]%s",
-                         ratingTypeNames [WhiteRatingType], WhiteElo, newline);
-                tb->PrintString (temp);
-            }
-            if (BlackElo > 0) {
-                sprintf (temp, "[Black%s \"%u\"]%s",
-                         ratingTypeNames [BlackRatingType], BlackElo, newline);
-                tb->PrintString (temp);
-            }
-            if (EcoCode != 0) {
-                ecoStringT ecoStr;
-                eco_ToExtendedString (EcoCode, ecoStr);
-                sprintf (temp, "[ECO \"%s\"]%s", ecoStr, newline);
-                tb->PrintString (temp);
-            }
-            if (EventDate != ZERO_DATE) {
-                char edateStr [20];
-                date_DecodeToString (EventDate, edateStr);
-                sprintf (temp, "[EventDate \"%s\"]%s", edateStr, newline);
-                tb->PrintString (temp);
-            }
-
-            if (PgnStyle & PGN_STYLE_SCIDFLAGS  &&  *ScidFlags != 0) {
-                sprintf (temp, "[ScidFlags \"%s\"]%s", ScidFlags, newline);
-                tb->PrintString (temp);
-            }
-
-            // Now print other tags
-            for (uint i=0; i < NumTags; i++) {
-                sprintf (temp, "[%s \"%s\"]%s",
-                         TagList[i].tag, TagList[i].value, newline);
-                tb->PrintString (temp);
-            }
-        }
-        // Finally, write the FEN tag if necessary:
-        if (NonStandardStart) {
-            char fenStr [256];
-            StartPos->PrintFEN (fenStr, FEN_ALL_FIELDS);
-            sprintf (temp, "[FEN \"%s\"]%s", fenStr, newline);
-            tb->PrintString (temp);
-        }
-        if (IsColorFormat()) { tb->PrintString ("</tag>"); }
-        // Now restore the linewrap column:
-        tb->SetWrapColumn (wrapColumn);
-    }
-    if (IsHtmlFormat()) { tb->PrintLine("</b></p>"); }
-    if (IsLatexFormat()) { 
-        tb->PrintLine ("}\n\\begin{chess}{\\bf "); 
-    } else {
-        tb->PrintString (newline);
-    }
-
-    // Now print the move list. First, we note the current position and
-    // move, so we can reconstruct the game state afterwards:
-    moveT * oldCurrentMove = CurrentMove;
-    if (stopLocation == 0) { SaveState(); }
-    MoveToPly(0);
-    PgnLastMovePos = PgnNextMovePos = 1;
-
-    if (IsHtmlFormat()) { tb->PrintString ("<p>"); }
-    NumMovesPrinted = 1;
-    StopLocation = stopLocation;
-    handleinitialcomment_CQL(tb);
-    WriteMoveList (tb, StartPlyCount, oldCurrentMove, true, false);
-    if (IsHtmlFormat()) { tb->PrintString ("<b>"); }
-    if (IsLatexFormat()) { tb->PrintString ("\n}\\end{chess}\n{\\bf "); }
-    if (IsColorFormat()) { tb->PrintString ("<tag>"); }
-    tb->PrintWord (RESULT_LONGSTR [Result]);
-    if (IsLatexFormat()) {
-        tb->PrintString ("}\n\\begin{center} \\hrule \\end{center}");
-    }
-    if (IsHtmlFormat()) { tb->PrintString ("</b><hr></p>"); }
-    if (IsColorFormat()) { tb->PrintString ("</tag>"); }
-    tb->NewLine();
-
-    // Now reset the current position and move:
-    if (stopLocation == 0) { RestoreState(); }
-    return OK;
-}
-
-void Game::handleinitialcomment_CQL(TextBuffer * tb){
-  if(FirstMove->comment==NULL) return;
-  tb->PrintString("{");
-  tb->PrintString(" ");
-  tb->PrintString(FirstMove->comment);
-  tb->PrintLine("}");
-}
-
-errorT
-Game::WriteToPGN_CQL(TextBuffer * tb){
-  return WritePGN_CQL(tb,0);
-}
-
-void MFile::skipNonAscii(){
-  uassert(Handle&&Location==0);
-  int c;
-  while(true){
-    c=fgetc(Handle);
-    uassert(c>0,"Unexpected end of file in skipNonAscii: possibly not valid PGN file");
-    if(c>127)
-      Location++;
-    else{
-      int u=ungetc(c,Handle);
-      uassert(u>=0,"ungetc failed skipNonAscii: file problem reading PGN file");
-      if(0&&Location)
-	printf("skipNonAscii: skipped %d characters\n",(int)Location);
-      return;
-    }
-  }
-}
Index: src/cql/originnode.cpp
===================================================================
--- src/cql/originnode.cpp	(revision 2842)
+++ src/cql/originnode.cpp	(working copy)
@@ -1,21 +1 @@
-#include "node.h"
-OriginNode::OriginNode(TagVariable* v){
-  uassert(v);
-  variable=v;
-}
 
-SquareMask OriginNode::getSquares(Game*game){
-  uassert(variable->isBound(),"Attempt to access unbound ID variable: ",variable->name);
-  squareT origin=variable->getOrigin();
-  uassert(square_valid(origin),"originnode origin");
-  SquareMask ret;
-  ret.insert(origin);
-  return ret;
-}
-
-void OriginNode::print(){
-  printf("<%s ",thisclass());
-  variable->print();
-  printf(">");
-}
-  
Index: src/cql/ornode.cpp
===================================================================
--- src/cql/ornode.cpp	(revision 2842)
+++ src/cql/ornode.cpp	(working copy)
@@ -1,39 +1 @@
-#include "node.h"
-OrNode::OrNode(MFilter*c1,MFilter*c2){
-  uassert(c1&&c2,"internal OrNode, null args to constructor");
-  clause1=c1;
-  clause2=c2;
-}
 
-bool OrNode::isSet(){
-  return clause1->isSet()&&clause2->isSet();
-}
-
-void OrNode::print(){
-  printf("<%s",thisclass());
-  printf("\n");indent();tab();
-  printf("clause1: ");
-  clause1->print();
-  printf("clause1: ");
-  printf("\n");tab();
-  clause2->print();
-  printf(" %s>",thisclass());
-  unindent();
-}
-
-bool OrNode::match_position(Game*game){
-  if(clause1->match_position(game)) return true;
-  return clause2->match_position(game);
-}
-
-SquareMask OrNode::getSquares(Game*game){
-  uassert(isSet(),"attempt to get squares from and Or Node that is not a Set Filter");
-  SetBase*s1=dynamic_cast<SetBase*>(clause1);
-  SetBase*s2=dynamic_cast<SetBase*>(clause2);
-  uassert(s1&&s2,"OrNode internal: expected sets here");
-  uassert(s1->isSet()&&s2->isSet(), "OrNode internal: expected actual sets");
-  SquareMask m1=s1->getSquares(game);
-  SquareMask m2=s2->getSquares(game);
-  return m1|m2;
-}
-
Index: src/cql/parser.cpp
===================================================================
--- src/cql/parser.cpp	(revision 2842)
+++ src/cql/parser.cpp	(working copy)
@@ -1,97 +1 @@
-#include "parser.h"
-#include "lexer.h"
-#include "cql.h"
-#include "tokenstream.h"
 
-#ifdef STANDALONE
-CqlNode* parseFile(const char* filename){
-  if(CqlDebug)printf("Parser: lexing file: %s\n",filename);
-  vector<Token*> tokens;
-  bool ret=lexFile(filename,&tokens);
-  if(CqlShowLex)
-    printf("Got return of: %d and ntokens: %lu\n",ret,tokens.size());
-  Tokens * ts=new Tokens(tokens);
-  CqlGlobalTokens=ts;
-  if(CqlShowLex){
-    printf("Printing the token stream for file: %s:\n",filename);
-    ts->print();
-  }
-  Variable::createNumericVariable("matchcount",true);
-  uassert(!CqlParseRoot,"parser: expecting a null CqlParseRoot");
-  CqlNode* n=ts->match_cqlnode();
-  CqlParseRoot=n;
-  uassert(n!=NULL,"CQL: Unable to parse file: %s",filename);
-  n->setChildVariations();
-  n->setUseMarks();
-  if(n->isSilent()) n->makeSilentRecursively();
-  n->makeNotNodeSilentRecursively(); // Not sure why this is here
-  n->expand();
-  n->addSortFields(n->sortfields);
-  return n;
-}
-#endif
-
-#ifdef INTEGRATED
-CqlNode* parseBuffer(char* buffer){
-  static bool pbDoOnce = true;
-  if(CqlDebug)printf("Parser: lexing buffer:\n");
-  vector<Token*> tokens;
-  bool ret=lexStream(NULL,buffer,&tokens);
-  if(CqlShowLex)
-    printf("Got return of: %d and ntokens: %lu\n",ret,tokens.size());
-  Tokens * ts=new Tokens(tokens);
-  CqlGlobalTokens=ts;
-  if(CqlShowLex){
-    printf("Printing the token stream:\n");
-    ts->print();
-  }
-  if (pbDoOnce) {
-    Variable::createNumericVariable("matchcount",true);
-    pbDoOnce = false;
-  }
-  uassert(!CqlParseRoot,"parser: expecting a null CqlParseRoot");
-  CqlNode* n=ts->match_cqlnode();
-  CqlParseRoot=n;
-  uassert(n!=NULL,"CQL: Unable to parse buffer");
-  n->setChildVariations();
-  n->setUseMarks();
-  if(n->isSilent()) n->makeSilentRecursively();
-  n->makeNotNodeSilentRecursively();
-  n->expand();
-  n->addSortFields(n->sortfields);
-  return n;
-}
-#endif
-
-void showTokens(){
-  if(!CqlGlobalTokens)
-    printf("No global tokens\n");
-  CqlGlobalTokens->print();
-}
-
-
-// Everything below this line is kludgeville... necessary because any inclusion
-// of a header from this directory in tkscid.cpp descends into include-file-hell.
-
-#ifdef INTEGRATED
-
-bool CqlParseBuffer(char *buffer) {
-
-  parseBuffer(buffer);
-
-  // If there's a problem, we'll longjmp() our way out of it before we reach this point.
-  return true;
-}
-
-// Reset initialised statics and free mem resources.
-void CqlReset() {
-
-  //if (MarkBoard::globalMarkBoard) {
-    //delete MarkBoard::globalMarkBoard;
-    //MarkBoard::globalMarkBoard=NULL;
-  //}
-
-  cql_initialize();
-
-}
-#endif
Index: src/cql/parser.h
===================================================================
--- src/cql/parser.h	(revision 2842)
+++ src/cql/parser.h	(working copy)
@@ -1,10 +1 @@
-#pragma once
-#include "util.h"
-#include "node.h"
-#include "token.h"
-#include "tokenstream.h"
 
-CqlNode* parseFile(const char* filename);
-CqlNode* parseBuffer(char* buffer);
-void showTokens();
-
Index: src/cql/pastnode.cpp
===================================================================
--- src/cql/pastnode.cpp	(revision 2842)
+++ src/cql/pastnode.cpp	(working copy)
@@ -1,63 +1 @@
-#include "node.h"
 
-PastNode::PastNode(vector<SeqConstituent*>cs,Range*r,bool isskip, bool allownest):SequenceBase(cs,r,isskip,allownest){
-}
-
-SeqRet PastNode::compute(HolderConstituent*holder,SeqStack&stack){
-  size_t stacklen=stack.size();
-  uassert(holder,"fncholdererr");
-  MFilter*filter=holder->filter;
-  uassert(filter,"fncfilter");
-  if(!filter->match_position(game))
-    return SeqRet(false);
-  if(stack.empty())return SeqRet(game,holder->getOffset());
-  auto me=MarkBoard::identity(game);
-  SeqRet best(false);
-  if(game->GetCurrentPly()!=0){
-    MarkBoard::gameBackup(game);
-    best=SequenceBase::compute(stack);
-    MarkBoard::gameToChild(me,game,getSearchVariations());
-  }
-  else
-    best=computeNull(stack);
-  uassert(me==MarkBoard::identity(game),"id fail check sequence");
-  if(best.isFalse())return best;
-  best.addParent(game,holder->getOffset());
-  uassert(stack.size()==stacklen,"fnch size");
-  return best;
-}
-
-void PastNode::notate(SeqRet& ret){
-  if(isSilent())return;
-  uassert(ret.isTrue(),"notate rist");
-  int len=ret.getLength();
-  if(!len)return;
-  moveT*me=MarkBoard::identity(game);
-  moveT*previousid=NULL;
-  uassert(me==ret.getId(0),"notate bad back");
-  char buffer[1000];
-  int positionsseen=0;
-  int positionsexpected=len;
-  if(isSkip()) positionsexpected=(len+1)/2;
-  for(int index=0;index<len;++index){
-    if(previousid){
-      uassert(previousid==MarkBoard::identity(game),"idcheck fail notateoop");
-      moveT*nextid=ret.getId(index);
-      uassert(nextid&&nextid!=previousid,"pastnode notate next next");
-      MarkBoard::gameBackup(game);
-      uassert(nextid==MarkBoard::identity(game),"pastnode notate id check fail");
-    }
-    moveT*thisid=MarkBoard::identity(game);
-    uassert(thisid==ret.getId(index),"idcheck fail notate");
-    int offset=ret.getOffset(index);
-    if (offset>=0){
-      ++positionsseen;
-      sprintf(buffer,"PREVIOUS %d (position %d of %d)",offset+1,positionsseen,positionsexpected);
-      MarkBoard::gameAppendComment(game,buffer);
-    }
-    previousid=thisid;
-  }
-  uassert(MarkBoard::identity(game)==ret.getId(len-1),"bad id check notate");
-  MarkBoard::gameToIdentity(me,game,getSearchVariations());
-}
-
Index: src/cql/paststarnode.cpp
===================================================================
--- src/cql/paststarnode.cpp	(revision 2842)
+++ src/cql/paststarnode.cpp	(working copy)
@@ -1,78 +1 @@
-#include "node.h"
-PastStarNode::PastStarNode(Node*node,Range*r,int depth){
-  uassert(node);
-  filter=dynamic_cast<MFilter*>(node);
-  uassert(filter,"unexpected nonmfilter to paststarnode");
-  range=r;
-  depthMax=depth;
-}
 
-void PastStarNode::print(){
-  printf("<%s ",thisclass());
-  if(isSilent())printf("silent ");
-  if(range)range->print();
-  if(depthMax>=0) printf("depthMax: %d",depthMax);
-  printf("\n");indent();tab();
-  filter->print();
-  unindent();
-  printf(">");
-}
-
-bool PastStarNode::match_count(Game*game,NumValue*value){
-  uassert(range,"If previous* is sorted, it requires an explicit range: missing range");
-  if(match_position(game)){
-    *value=(NumValue)(getCount());
-    return true;
-  }
-  return false;
-}
-
-
-
-bool PastStarNode::match_position(Game*game){
-  count=0;
-  bool variation=MarkBoard::inVariation(game);
-  auto pid=MarkBoard::identity(game);
-  vector<moveT*> ids;
-  compute_counts(game,ids,0);
-  uassert(count==(int)(ids.size()));
-  uassert(pid==MarkBoard::identity(game));
-  if(!range&&!count)return false;
-  if(range&&!range->valid(count)) return false;
-  if(isSilent())return true;
-  for(int idindex=0;idindex<count;++idindex){
-    MarkBoard::gameToIdentity(ids[idindex],
-			      game,
-			      variation);
-    char buffer[100];
-    sprintf(buffer,"previous* %d of %d",idindex+1,count);
-    if(!isSilent())MarkBoard::gameAppendComment(game,buffer);
-  }
-  MarkBoard::gameToIdentity(pid,game,variation);
-  return true;
-}
-
-void PastStarNode::compute_counts(Game*game,vector<moveT*>&ids,int depth){
-  if (depthMax>=0 && depth>depthMax) return;
-  if(!range&&count)return;
-  moveT* me=MarkBoard::identity(game);
-  bool variation=MarkBoard::inVariation(game);
-  if(filter->match_position(game)){
-    ++count;
-    ids.push_back(me);
-    if(!range)return;
-  }
-  if(game->GetCurrentPly()==0) return;
-  MarkBoard::gameBackup(game);
-  compute_counts(game,ids,depth+1);
-  MarkBoard::gameToChild(me,game,variation);
-}
-
-
-
-
-
-  
-
-					  
-  
Index: src/cql/pieceidnode.cpp
===================================================================
--- src/cql/pieceidnode.cpp	(revision 2842)
+++ src/cql/pieceidnode.cpp	(working copy)
@@ -1,61 +1 @@
-#include "node.h"
-void PieceIdNode::print(){
-  printf("<%s variable: ",thisclass());
-  variable->print();
-  printf(" %lu filters: ",filters.size());
-  printf("\n");indent();tab();
-  printf("PieceId Set: ");
-  set->print();
-  unindent();
-  for(int i=0;i<filters.size();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("<%d of %lu: ",i,filters.size());
-    filters[i]->print();
-    unindent();
-  }
-  printf(" %s> ",thisclass());
-}
 
-PieceIdNode::PieceIdNode(TagVariable*v, SetBase*s,vector<Node*>nodes){
-  uassert(v,"pieceidnode internal v");
-  variable=v;
-  uassert(s,"pieceidnode internal s");
-  set=s;
-  for(Node*np: nodes){
-    uassert(np,"internal pieceidnode");
-    MFilter * mf=dynamic_cast<MFilter*>(np);
-    uassert(mf,"PieceIdNode: unexpected non-mfilter");
-    filters.push_back(mf);
-  }
-  uassert(filters.size()==nodes.size());
-}
-
-SquareMask PieceIdNode::getSquares(Game*game){
-  SquareMask ret;
-  SquareMask setmask=set->getSquares(game);
-  uassert(variable->isUnbound(),"PieceID expected unbound variable", variable->name);
-  for(int square=0;square<64;++square)
-    if(setmask.member(square)){
-      int t=MarkBoard::getMark(square);
-      if(!mark_valid(t))continue;
-      uassert(MarkBoard::getSquare(t)==square);
-      variable->bindTag(t);
-      bool refuted=false;
-      for (auto mfilter : filters)
-	if (!mfilter->match_position(game)){
-	  refuted=true;
-	  break;
-	}
-      variable->unbind();
-      if(!refuted) ret.insert(square);
-    }
-  return ret;
-}
-    
-vnode PieceIdNode::children(){
-  vnode ret{set};
-  ret.insert(ret.end(),filters.begin(),filters.end());
-  return ret;
-}
Index: src/cql/pieceloc.cpp
===================================================================
--- src/cql/pieceloc.cpp	(revision 2842)
+++ src/cql/pieceloc.cpp	(working copy)
@@ -1,116 +1 @@
-#include "node.h"
- 
-PieceLoc::PieceLoc(vector<PieceToken*>pts,
-		   vector<SquareToken*>sts,
-		   vector<VariableToken*>vartokens){
-  vector<squareT> squares;
-  uassert(pts.size()&&sts.size());
-  for (PieceToken* pt : pts){
-    uassert(pt);
-    vector<pieceT> v=piecesFromChar(pt->value);
-    for (pieceT p : v){
-      uassert(piece_valid(p));
-      pieces.insert((squareT)p);
-    }
-  }
 
-  for(SquareToken* st : sts){
-    uassert(st);
-    for (int file=st->minfile; file<=st->maxfile;++file)
-      for(int rank=st->minrank;rank<=st->maxrank;++rank){
-	uassert(file_valid(file)&&rank_valid(rank));
-	squareT square=square_make(file,rank);
-	uassert(square_file(square)==file&&square_rank(square)==rank);
-	uassert(square_valid(square));
-	squares.push_back(square); 
-      }// for file..//for rank
-  }//for each squaretoken
-  squaremask=SquareMask(squares);
-  for(VariableToken*vt: vartokens){
-    uassert(vt,"internal pieceloc");
-    const char*name=vt->value;
-    uassert(name,"internal name pieceloc");
-    Variable* v=Variable::find(name);
-    if(!v) v=Variable::getSquareVariable(name);
-    uassert(v,"internal pieceloc var");
-    variables.push_back(v);
-  }
-}
-    
-void PieceLoc::print(){
-  // if(1){
-  //   printf("print called on pieceloc %p with variables size: %lu\n",this,variables.size());
-  // }
-  uassert(pieces.nonempty());
-  if(pieces.size()>1)
-    printf("[");
-  for(int p =0;p<64;++p) if(pieces.member(p)){
-      uassert(piece_valid((pieceT)p));
-      printf("%c", piece_to_char((pieceT)p));
-    }
-  if(pieces.size()>1)
-    printf("]");
-  squaremask.print();
-  for(Variable* v:variables){
-    //    printf("pl::print has got a variable at: %p\n",v);
-    //    printf("its class is: %s\n",v->thisclass());
-    v->print();
-  }
-}
-
-vector<pieceT> PieceLoc::piecesFromChar(char c){
-  vector<pieceT> r{BR};
-  vector<pieceT> n{BN};
-  vector<pieceT> b{BB};
-  vector<pieceT> q{BQ};
-  vector<pieceT> k{BK};
-  vector<pieceT> p{BP};
-  vector<pieceT> R{WR};
-  vector<pieceT> N{WN};
-  vector<pieceT> B{WB};
-  vector<pieceT> Q{WQ};
-  vector<pieceT> K{WK};
-  vector<pieceT> P{WP};
-  vector<pieceT> A{WR,WN,WB,WQ,WK,WP};
-  vector<pieceT> a{BR,BN,BB,BQ,BK,BP};
-  vector<pieceT> dot{EMPTY};
-  vector<pieceT> U;
-  U.insert(U.end(),A.begin(),A.end());
-  U.insert(U.end(),a.begin(),a.end());
-  vector<pieceT> questionmark{U};
-  questionmark.push_back(EMPTY);
-
-  switch(c){
-  case 'r': return r;
-  case 'R': return R;
-  case 'n': return n;
-  case 'N': return N;
-  case 'b': return b;
-  case 'B': return B;
-  case 'q': return q;
-  case 'Q': return Q;
-  case 'k': return k;
-  case 'K': return K;
-  case 'p': return p;
-  case 'P': return P;
-  case 'A': return A;
-  case 'a': return a;
-  case 'U': return U;
-  case '_': return dot;
-  case '?': return questionmark;
-  };
-  uassert(false,"invalid piece character");
-  return U;
-};
-
-bool PieceLoc::isPurePiece(){
-  if (pieces.size()==0 ||
-      variables.size()>0||
-      squaremask.size()<64)
-    return false;
-  return true;
-}
-
-bool PieceLoc::hasEmptySquareMask(){
-  return squaremask.empty();
-}
Index: src/cql/piecelocmatch.cpp
===================================================================
--- src/cql/piecelocmatch.cpp	(revision 2842)
+++ src/cql/piecelocmatch.cpp	(working copy)
@@ -1,39 +1 @@
-#include "node.h"
 
-SquareMask PieceLoc::getSquares(Game*game){
-  SquareMask ret=SquareMask::all();
-  for(Variable*v:variables){
-    uassert(v->isBound(),"Unexpected unbound variable: may be undeclared: ",v->name);
-    squareT s=65;
-    bool b=v->getSquare(&s);
-    if(!b) return SquareMask();
-    uassert(square_valid(s));
-    ret&=SquareMask::fromSquare(s);
-  }
-  ret&=squaremask;
-  if(ret.empty())return ret;
-  return ret&getPieceMask(game);
-}
-
-SquareMask PieceLoc::getPieceMask(Game*game){
-  int gamenumber=game->GetNumber();
-  auto me=MarkBoard::identity(game);
-  if(lastid==me&&lastgamenumber==gamenumber)
-    return lastmask;
-  lastmask.clear();
-  lastid=me;
-  Position*position=game->GetCurrentPos();
-  pieceT*board=position->GetBoard();
-  for(squareT sq=0;sq<64;++sq){
-    pieceT piece=board[sq];
-    if (match_piece(piece))
-      lastmask.insert(sq);
-  }
-  return lastmask;
-}
-
-bool PieceLoc::match_piece(pieceT piece){
-  //  uassert(piece_valid(piece));
-  return pieces.member(piece);
-}
-
Index: src/cql/piecelocparse.cpp
===================================================================
--- src/cql/piecelocparse.cpp	(revision 2842)
+++ src/cql/piecelocparse.cpp	(working copy)
@@ -1,284 +1 @@
-#include "util.h"
-#include <ctype.h>
-#include "lexer.h"
 
-//piecedesignator= squarespecifier | piecespecifier squarespecifier?
-PieceDesignatorToken* match_piecedesignator(char* input){
-  if(!strcmp(input,"darksquares"))
-    return match_piecedesignator("[a1,a3,a5,a7,b2,b4,b6,b8,c1,c3,c5,c7,d2,d4,d6,d8,e1,e3,e5,e7,f2,f4,f6,f8,g1,g3,g5,g7,h2,h4,h6,h8]");
-  else if(!strcmp(input,"lightsquares"))
-    return match_piecedesignator("[a2,a4,a6,a8,b1,b3,b5,b7,c2,c4,c6,c8,d1,d3,d5,d7,e2,e4,e6,e8,f1,f3,f5,f7,g2,g4,g6,g8,h1,h3,h5,h7]");
-  vector<PieceToken*>pieces; //disjunctive
-  vector<SquareToken*>squares; //disjunctive
-  vector<VariableToken*>variables; //conjunctive
-  char* current=input;
-  bool seeninitialsquare=match_squarespecifier(&current,&squares);
-  // printf("mpd: input: %s\n",input);
-  // printf("mpd: seeninitialsquare: %d\n",seeninitialsquare);
-  if(!seeninitialsquare){
-    match_piecespecifier(&current,&pieces);
-    // printf("mpd: current after match_ps: %s and npieces: %lu\n",current,pieces.size());
-    match_squarespecifier(&current,&squares); //a failed match is taken as an empty string
-    // printf("mpd: current after match_ss: %s and nsquares: %lu\n",current,squares.size());
-  }
-  match_variables(&current,&variables);
-  // printf("mpd: current after match_vs: %s and nvars: %lu\n",current,variables.size());
-  if(*current) return NULL; // expect end of string in a piece designator here
-  if(pieces.empty()&&squares.empty()&&variables.empty()) return NULL;
-  if(pieces.empty()) pieces.push_back(new PieceToken('?'));
-  if(squares.empty())squares.push_back(new SquareToken(0,7,0,7));
-  // printf("mpd: calling pdt with sizes: pieces: %lu, squares: %lu, vars: %lu\n",
-  // 	 pieces.size(),
-  // 	 squares.size(),
-  // 	 variables.size());
-  return new PieceDesignatorToken(pieces,squares,variables);
-}
-
-void match_variables(char**inputp,vector<VariableToken*>*varsp){
-  char* current=*inputp;
-  while(true){
-    VariableToken* t=match_variable(&current);
-    if(!t) return;
-    varsp->push_back(t);
-    *inputp=current;
-  }
-}
-//piecespecifer= singlepiecespecifier |  compoundpiecespecifier 
-bool match_piecespecifier(char**inputp,vector<PieceToken*>*pieces){
-  PieceToken*t=match_singlepiecespecifier(inputp);
-  if(t) {
-    pieces->push_back(t);
-    return true;
-  }
-  if(match_compoundpiecespecifier(inputp,pieces))
-    return true;
-  return false;
-}
-
-//singlepiecespecifier= simplepiecespecifier | tagname
-PieceToken* match_singlepiecespecifier(char**inputp){
-  return match_simplepiecespecifier(inputp);
-}
-
-//simplepiecespecifier= R | N | ... | '?' | '_'
-PieceToken* match_simplepiecespecifier(char**inputp){
-  char*input= *inputp;
-  uassert(input);
-  char c=input[0];
-  PieceToken* st=PieceToken::create(c);
-  if(!st)return NULL;
-  *inputp=*inputp + 1;
-  return st;
-}
-
-bool match_singlepiecespecifierplus(char**inputp,vector<PieceToken*>*piecesp){
-  char*current=*inputp;
-  vector<PieceToken*>pieces;
-  PieceToken*t=match_singlepiecespecifier(&current);
-  if(!t)return false;
-  pieces.push_back(t);
-  match_singlepiecespecifierplus(&current,&pieces);
-  *inputp=current;
-  for(auto p: pieces) piecesp->push_back(p);
-  return true;
-}
-  
-//compoundpiecespecifier = '[' singlepiecespecifier+ ']'
-bool match_compoundpiecespecifier(char**inputp,vector<PieceToken*>*piecesp){
-  vector<PieceToken*>pieces;
-  char*current=*inputp;
-  if(!(match_char(&current,'['))) return false;
-  if(!match_singlepiecespecifierplus(&current,&pieces))
-    return false;
-  if(!match_char(&current,']')) return false;
-  *inputp=current;
-  for(auto p:pieces) piecesp->push_back(p);
-  return true;
-}
-
-
-bool match_alphanums(char**inputp, char* result, int maxlength){
-  char*current=*inputp;
-  int len=0;
-  while(isalnum(current[len])){
-    if(len>=maxlength){
-      printf("error\n");
-      uassert(false,"matchalphanums");
-    }
-    ++len;
-  }
-  if(len==0) return false;
-  uassert(len<maxlength);
-  for(int i=0;i<len;++i)
-    result[i]=current[i];
-  result[len]=0;
-  *inputp=current+len;
-  return true;
-}
-
-bool match_char(char**inputp,char c){
-  char*current=*inputp;
-  uassert(current);
-  if(current[0]==c){
-    *inputp= *inputp+1;
-    return true;}
-  return false;
-}
-
-//squarespecifier= blocksquarespecifier | compoundsquarespecifier
-bool match_squarespecifier(char**inputp, vector<SquareToken*>*squaresp){
-  SquareToken* t=match_blocksquarespecifier(inputp);
-  if(t){
-    squaresp->push_back(t);
-    return true;}
-
-  if(match_compoundsquarespecifier(inputp,squaresp))
-    return true;
-
-  return false;
-}
-
-//file = [a-h]
-bool match_file(char**inputp,int * result){
-  char*current=*inputp;
-  uassert(current);
-  char f=current[0];
-  if(f>='a'&&f<='h'){
-    *result=f-'a';
-    *inputp=current+1;
-    return true;
-  }
-  return false;
-}
-
-//rank= [1-8]
-bool match_rank(char**inputp,int * result){
-  char*current=*inputp;
-  uassert(current);
-  char r=current[0];
-  if(r>='1'&&r<='8'){
-    *result=r-'1';
-    *inputp=current+1;
-    return true;
-  }
-  return false;
-}
-  
-//simplesquarespecifer=files ranks
-SquareToken* match_simplesquarespecifier(char**inputp){
-  int minf=-1,maxf=-1,minr=-1,maxr=-1;
-  char*current=*inputp;
-  if(match_files(&current,&minf,&maxf))
-    if(match_ranks(&current,&minr,&maxr)){
-      *inputp=current;
-      return new SquareToken(minf,maxf,minr,maxr);
-    }
-  return NULL;
-}
-	
-// blocksquarespecifier= bindingsquarespecifier  | simplesquarespecifier
-SquareToken* match_blocksquarespecifier(char**inputp){
-  return match_simplesquarespecifier(inputp);
- }
-
-//compoundsquarespecifier= '[' blocksquarespecifier commasquares ']'
-bool match_compoundsquarespecifier(char**inputp,vector<SquareToken*>*squaresp){
-  char*current=*inputp;
-  if(!match_char(&current,'[')) return false;
-  vector<SquareToken*>squares;
-  SquareToken* t=match_blocksquarespecifier(&current);
-  if(!t)return false;
-  squares.push_back(t);
-  if(!match_commasquares(&current,&squares)) return false;
-  if(!match_char(&current,']')) return false;
-  for(auto s:squares) squaresp->push_back(s);
-  *inputp=current;
-  return true;
-}
-
-//commasquares= ',' blocksquarespecifier commasquares
-bool match_commasquares(char**input,vector<SquareToken*>*squaresp){
-  char*current=*input;
-  vector<SquareToken*> squares;
-  if(!match_char(&current,',')) return true;
-  SquareToken *t=match_blocksquarespecifier(&current);
-  if(!t) return true;
-  squares.push_back(t);
-  match_commasquares(&current,&squares);
-  for(auto s:squares)squaresp->push_back(s);
-  *input=current;
-  return true;
-}
-  
-
-//files=	filerange | file
-bool match_files(char**inputp,int*min,int *max){
-  if(match_filerange(inputp,min,max))
-    return true;
-  if(match_file(inputp,min)){
-    *max=*min;
-    return true;
-  }
-  return false;
-}
-
-//filerange= file '-' file
-bool match_filerange(char**inputp,int*min,int*max){
-  char*current=*inputp;
-  int lmin=-1,lmax=-1;
-  if(!match_file(&current,&lmin))return false;
-  if(!match_char(&current,'-')) return false;
-  if(!match_file(&current,&lmax))return false;
-  *min=lmin;
-  *max=lmax;
-  *inputp=current;
-  uassert(lmin<=lmax,"Unexpected filerange",*inputp);
-  return true;
-}
-
-bool match_ranks(char**inputp,int*min,int *max){
-  if(match_rankrange(inputp,min,max))
-    return true;
-  if(match_rank(inputp,min)){
-    *max=*min;
-    return true;
-  }
-  return false;
-}
-
-//rankrange= rank '-' rank
-bool match_rankrange(char**inputp,int*min,int*max){
-  char*current=*inputp;
-  int lmin=-1,lmax=-1;
-  if(!match_rank(&current,&lmin))return false;
-  if(!match_char(&current,'-')) return false;
-  if(!match_rank(&current,&lmax))return false;
-  *min=lmin;
-  *max=lmax;
-  *inputp=current;
-  uassert(lmin<=lmax,"Unexpected rankrange",*inputp);
-  return true;
-}
-
-		 
-VariableToken* match_variable(char**inputp){
-  char*current=*inputp;
-  char*name=new char[42];
-  uassert(current);
-  if(!match_char(&current,'$')) return NULL;
-  name[0]='$';
-  if(!match_alphanums(&current,name+1,40))
-    return NULL;
-  *inputp=current;
-  return new VariableToken(name);
-}
-  
-VariableToken* match_variable(char*input){
-  char*current=input;
-  VariableToken *t=match_variable(&current);
-  if(t==NULL||*current) return NULL;
-  return t;
-}
-
-
-
Index: src/cql/piover4transform.cpp
===================================================================
--- src/cql/piover4transform.cpp	(revision 2842)
+++ src/cql/piover4transform.cpp	(working copy)
@@ -1,54 +1 @@
-#include "node.h"
 
-squareT PiOver4Transform::transform(squareT s){
-  uassert(false,"An attempt to transform a particular square by 45 degrees was made. The rotate45 filter cannnot be used on individual squares");
-  return 0;
-}
-
-PiOver4Transform::PiOver4Transform(int t):times{t}{
-  uassert(times>=0&&times<8,"PiOver4transform arg");
-}
-
-vector<Transform*>PiOver4Transform::rotations(){
-  vector<Transform*> v;
-  for (int t=1;t<8;++t)
-    v.push_back(new PiOver4Transform(t));
-  return v;
-}
-
-Direction PiOver4Transform::transform(Direction d){
-  Direction ret=d;
-  for (int i=0;i<times;++i)
-    ret=rotate45(ret);
-  return ret;
-}
-
-Direction PiOver4Transform::rotate45(Direction d){
-  static vector<Direction> directions{
-      Direction (1,0),
-      Direction (1,1),
-      Direction (0,1),
-      Direction (-1,1),
-      Direction (-1,0),
-      Direction (-1,-1),
-      Direction (0,-1),
-      Direction (1,-1),
-      };
-  uassert(directions.size()==8);
-  for(int i=0;i<8;++i)
-    if (d.eq(directions[i]))
-      return directions[(i+1)%8];
-  uassert(false,"rotate45 internal loop");
-  return Direction(0,1);
-}
-void PiOver4Transform::print(){
-  printf("<%s times: %d>",thisclass(),times);
-}
-
-SquareMask PiOver4Transform::transform(SquareMask mask){
-  if (mask.full()) return mask;
-  if (mask.empty())return mask;
-  uassert(false,"rotate45 cannot be applied to a particular square");
-  return mask;
-}
-
Index: src/cql/playernode.cpp
===================================================================
--- src/cql/playernode.cpp	(revision 2842)
+++ src/cql/playernode.cpp	(working copy)
@@ -1,22 +1 @@
-#include "node.h"
-PlayerNode::PlayerNode(const char* n,colorT c):name{n},color{c}{
-  uassert(n&&name,"playernode internal");
-  uassert(color==WHITE||color==BLACK||color==NOCOLOR,"playernode color");
-}
 
-bool PlayerNode::match_game(Game*game){
-  char* whiteplayer=game->GetWhiteStr();
-  char* blackplayer=game->GetBlackStr();
-  if( (whiteplayer&&strstr(whiteplayer,name)
-       &&(color==WHITE||color==NOCOLOR))
-      ||
-      (blackplayer&&strstr(blackplayer,name)
-       &&(color==BLACK||color==NOCOLOR)))
-    return true;
-  return false;
-}
-  
-void PlayerNode::print(){
-  printf("<%s %s %s>",thisclass(),color_string(color),name);
-}
-  
Index: src/cql/plusconstituent.cpp
===================================================================
--- src/cql/plusconstituent.cpp	(revision 2842)
+++ src/cql/plusconstituent.cpp	(working copy)
@@ -1,26 +1 @@
-#include "node.h"
-PlusConstituent::PlusConstituent(SeqConstituent*c){
-  uassert(c,"nullscsc");
-  theStarConstituent=new StarConstituent(c);
-}
 
-void PlusConstituent::print(){
-  printf("<%s ",thisclass());
-  getConstituent()->print();
-  printf(">");
-}
-
-void PlusConstituent::setOffsets(int i){
-  setOffset(i);
-  theStarConstituent->setOffsets(i);
-}
-
-bool PlusConstituent::matchesNull(){
-  return getConstituent()->matchesNull();
-}
-
-SeqConstituent* PlusConstituent::getConstituent(){
-  return theStarConstituent->constituent;
-}
-
-
Index: src/cql/positionnode.cpp
===================================================================
--- src/cql/positionnode.cpp	(revision 2842)
+++ src/cql/positionnode.cpp	(working copy)
@@ -1,29 +1 @@
-#include "node.h"
-vnode PositionNode::children(){
-  return vnode{specs.begin(),specs.end()};
-}
 
-PositionNode::PositionNode(vector<Node*> ss){
-  for(auto s: ss){
-    uassert(s,"null input to positionnode");
-    MFilter* mf=dynamic_cast<MFilter*>(s);
-    uassert(s,"PositionNode was passed a feature that is not an MFilter");
-    specs.push_back(mf);
-  }
-}
-
-void PositionNode::print(){
-  printf("<%s at %p: %lu specs:",thisclass(),this,specs.size());
-  for(int i=0;i<specs.size();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("<%d of %lu: ",i,specs.size());
-    specs[i]->print();
-    unindent();
-  }
-  printf(" %s> ",thisclass());
-}
-
-
-    
Index: src/cql/powerdifferencenode.cpp
===================================================================
--- src/cql/powerdifferencenode.cpp	(revision 2842)
+++ src/cql/powerdifferencenode.cpp	(working copy)
@@ -1,38 +1 @@
-#include "node.h"
-PowerDifferenceNode::PowerDifferenceNode(SetBase*s1,SetBase*s2,Range*r){
-  uassert(s1&&s2&&r);
-  power1=new PowerNode(s1,new Range(0,1000));
-  power2=new PowerNode(s2,new Range(0,1000));
-  range=r;
-}
 
-void PowerDifferenceNode::print(){
-  printf("\n");tab();
-  printf("<%s Range: ",thisclass());
-  range->print();
-  indent();
-  printf("\n");tab();
-  printf("Power: ");
-  power1->print();
-  printf("\n");tab();
-  printf("Power: ");
-  power2->print();
-  printf(" >");
-}
-
-bool PowerDifferenceNode::match_count(Game*game,NumValue*value){
-  if (match_position(game)){
-    *value=(NumValue)powerdifference;
-    return true;
-  }
-  return false;
-}
-    
-  
-bool PowerDifferenceNode::match_position(Game*game){
-  power1->match_position(game);
-  power2->match_position(game);
-  powerdifference=power1->power-power2->power;
-  return range->valid(powerdifference);
-}
-
Index: src/cql/powernode.cpp
===================================================================
--- src/cql/powernode.cpp	(revision 2842)
+++ src/cql/powernode.cpp	(working copy)
@@ -1,54 +1 @@
-#include "node.h"
-PowerNode::PowerNode(SetBase*s,Range*r){
-  uassert(s&&r);
-  set=s;
-  range=r;
-}
 
-void PowerNode::print(){
-  printf("\n");tab();
-  printf("<%s Set: ",thisclass());
-  set->print();
-  printf(" Range:");
-  range->print();
-  printf(" >");
-}
-
-bool PowerNode::match_count(Game*game,NumValue*value){
-  if (match_position(game)){
-    *value=(NumValue)power;
-    return true;
-  }
-  return false;
-}
-    
-  
-bool PowerNode::match_position(Game*game){
-  SquareMask mask=set->getSquares(game);
-  power=0;
-  pieceT*board=game->GetCurrentPos()->GetBoard();
-  for (int square=0;square<64;++square)
-    if(mask.member(square))
-      power+= pieceValue(board[square]);
-  return range->valid(power);
-}
-
-int PowerNode::pieceValue(pieceT p){
-  switch (p){
-  case BR: case WR: return 5;
-  case BN: case WN: return 3;
-  case BB: case WB: return 3;
-  case BQ: case WQ: return 9;
-  case BK: case WK: return 0;
-  case BP: case WP: return 1;
-  case EMPTY: return 0;
-  }
-  uassert(false,"piecevalue");
-  return 0;
-}
-
-    
-      
-  
-
-  
Index: src/cql/range.h
===================================================================
--- src/cql/range.h	(revision 2842)
+++ src/cql/range.h	(working copy)
@@ -1,14 +1 @@
-#pragma once
-#include "deleteable.h"
-class Range: public Deleteable{
- public:
-  int min;
-  int max;
-  const char* thisclass(){return "Range";}
-  void print();
-  Range(int m);
-  Range(int mi,int ma);
-  bool valid(int i){return min<=i&&i<=max;}
 
-};
-
Index: src/cql/raynode.cpp
===================================================================
--- src/cql/raynode.cpp	(revision 2842)
+++ src/cql/raynode.cpp	(working copy)
@@ -1,127 +1 @@
-#include "node.h"
-bool RayNode::isSet(){
-  return range==NULL;
-}
 
-bool RayNode::isCountable(){
-  return range!=NULL;
-}
-
-void RayNode::print(){
-  printf("\n");tab();
-  printf("<%s ",thisclass());
-  if(isAttack) printf(" isAttack ");
-  if(range) {
-    printf(" Range: ");
-    range->print();
-  }
-  for(auto d:directions){
-    printf(" ");
-    d.print();
-  }
-  printf("\n");
-  indent();
-  int nds=(int)(designators.size());
-  for(int i=0;i<nds;++i){
-    tab();
-    printf("Ray designator %d of %d: ",i,nds);
-    designators[i]->print();
-    printf("\n");
-  }
-  tab();
-  printf(" %s>",thisclass());
-  unindent();
-}
-
-RayNode::RayNode(vector<Direction>dirs,
-		 vector<SetBase*> sets,
-		 bool isattack,
-		 Range*r){
-  uassert(dirs.size()>0);
-  uassert(sets.size()>=2);
-  directions=dirs;
-  for(auto s:sets) uassert(s);
-  designators=sets;
-  for (int i=0;i<designators.size();++i)
-    designatorMasks.push_back(SquareMask());
-  uassert(designatorMasks.size()==designators.size());
-  isAttack=isattack;
-  if(isAttack) uassert(dirs.size()==Direction::allDirections().size(),"raynode constructor internal");
-  range=r;
-}
-
-bool RayNode::match_position(Game * game){
-  //  printf("rn:mcp: called\n");
-  Position * p=game->GetCurrentPos();
-  pieceT * board=p->GetBoard();
-  int nmatches=0;
-  matchedSoFar.clear();
-  uassert(designators.size()>1);
-  uassert(designatorMasks.size()==designators.size());
-  for (int i=0;i<designators.size();++i){
-    SetBase*designator=designators.at(i);
-    uassert(designator);
-    designatorMasks[i]=designator->getSquares(game);
-  }
-  SquareMask startmask=designatorMasks[0];
-  for (squareT sq=0;sq<64;++sq)
-    if(startmask.member(sq))
-      for (Direction direction:directions){
-	if (isAttack&&
-	    !direction.isCompatible(board[sq]))
-	  continue;
-	if (match_starting(sq,direction,game))
-	  { ++nmatches;
-	    if (range&&nmatches>range->max) return false;
-	  }
-      } //for each direction
-  if(range) {
-      count=nmatches;
-      return range->valid(nmatches);}
-  return matchedSoFar.nonempty();
-}
-
-bool RayNode::match_count(Game*game, NumValue*value){
-  uassert(range,"No range: must include a range when counting rays");
-  if(match_position(game)){
-    *value=(NumValue)(count);
-    return true;
-  }
-  return false;
-}
-
-bool RayNode::match_starting(squareT square, Direction direction, Game*game){
-  uassert(square_valid(square));
-  int ndesignators=(int)(designators.size());
-  uassert(ndesignators>1,"internal match_starting");
-  int current=square;
-  int nmatched=0;
-  nmatched=1;
-  while(true){
-    uassert(nmatched<ndesignators,"RayNode::match_starting: internal error");
-    current=direction.apply(current);
-    if (!square_valid(current)) break;
-    SquareMask nextmask=designatorMasks.at(nmatched);
-    if (nextmask.member(current)){
-      nmatched++;
-      if(nmatched==ndesignators){
-	matchedSoFar.insert(current);
-	return true;
-      }
-    }
-    else {
-      pieceT piece=MarkBoard::piece_at_square((squareT)current,game);
-      if(piece!=EMPTY)return false;
-    }
-  }
-  uassert(nmatched<ndesignators,"match_starting, internal");
-  return false;
-}
-
-SquareMask RayNode::getSquares(Game*game){
-  uassert(!isSet(),
-	  "A ray can only be used as a set filter when it does not have a range");
-  match_position(game);
-  return matchedSoFar;
-}
-  
Index: src/cql/repeatconstituent.cpp
===================================================================
--- src/cql/repeatconstituent.cpp	(revision 2842)
+++ src/cql/repeatconstituent.cpp	(working copy)
@@ -1,25 +1 @@
-#include "node.h"
-RepeatConstituent::RepeatConstituent(SeqConstituent*c,int tmin, int tmax){
-  uassert(c,"nullscsc");
-  constituent=c;
-  uassert (tmin>=0 && tmax >=0);
-  min=tmin;
-  max=tmax;
-}
 
-void RepeatConstituent::print(){
-  printf("<%s ",thisclass());
-  constituent->print();
-  printf("{%d %d}",min,max);
-  printf(">");
-}
-
-void RepeatConstituent::setOffsets(int i){
-  setOffset(i);
-  constituent->setOffsets(i);
-}
-
-bool RepeatConstituent::matchesNull(){
-  return min==0 ||
-    constituent->matchesNull();
-}
Index: src/cql/scripts/regress.sh
===================================================================
--- src/cql/scripts/regress.sh	(revision 2842)
+++ src/cql/scripts/regress.sh	(working copy)
@@ -1,31 +1 @@
-#!/bin/bash
-#
-# Given a collection of CQL syntax files, run the two standalone cql apps
-# with each of those files against a common PDN DB and redirect the output
-# to their respective log files.
-#
-# Run diff against the log files to verify that the two standalone execs
-# flag the same games.
 
-EXECS="cql pcql"
-EXAMPLES=../examples/*.cql
-#EXAMPLES=$HOME/git-svn/scidvspc-code/src/cql/examples/*stalemate*.cql
-PGN_IN=$HOME/tmp/cql_test.pgn
-OUT_DIR=/tmp/cql
-
-rm -rf $OUT_DIR
-mkdir -p $OUT_DIR
-
-for exec in $EXECS ; do 
-  LOG=$OUT_DIR/$exec.log
-  for script in $EXAMPLES ; do
-    PGN_OUT=$OUT_DIR/out_${exec}_$(basename $script cql)pgn
-    echo $exec -i $PGN_IN -o $PGN_OUT $script 
-    $exec -i $PGN_IN -o $PGN_OUT $script  >>  $LOG
-  done
-done
-
-diff ${OUT_DIR}/*.log | grep CQL:
-
-exit 0
-
Index: src/cql/seqconstituent.cpp
===================================================================
--- src/cql/seqconstituent.cpp	(revision 2842)
+++ src/cql/seqconstituent.cpp	(working copy)
@@ -1,7 +1 @@
-#include "node.h"
 
-void SeqConstituent::setOffset(int off){
-  uassert(off>=0&&theOffset<0,"offset setoffset internal");
-  theOffset=off;
-}
-
Index: src/cql/seqconstituent.h
===================================================================
--- src/cql/seqconstituent.h	(revision 2842)
+++ src/cql/seqconstituent.h	(working copy)
@@ -1,107 +1 @@
-#pragma once
-class SeqConstituent : public Node{
- public:
-  virtual void print()=0;
-  virtual SeqConstituent* clone()=0;
-  virtual bool matchesNull()=0;
-  int getOffset(){return theOffset;}
-  void setOffset(int);
-  virtual void setOffsets(int)=0;
- private:
-  int theOffset{-1};
-};
 
-class RepeatConstituent : public SeqConstituent{
- public:
-  SeqConstituent* constituent{NULL};
-  RepeatConstituent(SeqConstituent*,int, int);
-  CVV(RepeatConstituent);
-  int min= -1;
-  int max= -1;
-  bool matchesNull();
-  void print();
-  vnode children(){return vnode{constituent};}
-  void deepify(){constituent=constituent->clone();}
-  void setOffsets(int i);
-};
-
-class StarConstituent : public SeqConstituent{
- public:
-  SeqConstituent*constituent{NULL};
-  //  StarConstituent(vector<SeqConstituent*>);
-  StarConstituent(SeqConstituent*);
-  CVV(StarConstituent);
-  bool matchesNull(){return true;}
-  void print();
-  vnode children(){return vnode{constituent};}
-  void deepify(){constituent=constituent->clone();}
-  void setOffsets(int i);
-};
-
-class HolderConstituent : public SeqConstituent{
- public:
-  HolderConstituent(MFilter*);
-  MFilter*filter{NULL};
-  CVV(HolderConstituent);
-  void print();
-  vnode children(){return vnode{filter};}
-  void deepify(){filter=filter->clone();}
-  bool matchesNull();
-  void setOffsets(int i);
-};
-
-class VectorConstituent : public SeqConstituent{
- public:
-  vector<SeqConstituent*>constituents;
-  VectorConstituent(vector<SeqConstituent*>& cs);
-  void print();
-  CVV(VectorConstituent);
-  vnode children();
-  void deepify(){clonevec(constituents);}
-  bool matchesNull();
-  void setOffsets(int);
-};
-
-class PlusConstituent : public SeqConstituent{
- public:
-  StarConstituent* getStarConstituent(){return theStarConstituent;}
-  SeqConstituent* getConstituent();
-  PlusConstituent(SeqConstituent*c);
-  CVV(PlusConstituent);
-  vnode children(){return vnode{theStarConstituent};}
-  void deepify(){theStarConstituent=theStarConstituent->clone();}
-  bool matchesNull();
-  void print();
-  void setOffsets(int);
- private:
-  StarConstituent* theStarConstituent{NULL};
-};
-
-class OptionalConstituent : public SeqConstituent{
- public:
-  OptionalConstituent(SeqConstituent*);
-  SeqConstituent*constituent{NULL};
-  CVV(OptionalConstituent);
-  void print();
-  vnode children(){return vnode{constituent};}
-  void deepify(){constituent=constituent->clone();}
-  bool matchesNull();
-  void setOffsets(int);
-};
-
-/* class SkipConstituent : public MFilter{ */
-/*  public: */
-/*   bool match_position(Game*game); */
-/*   void setColor(color_t); */
-/*   color_t getColor(color_t); */
-/*   bool isValid(); */
-/*   void clear(); */
-/*   CVV(SkipConstituent); */
-/*   SkipConstituent(); */
-/*   vnode children(){return vnode{};} */
-/*   bool matchesNull(); */
-/*   void print(); */
-/*  private: */
-/*   color_t theColor{NOCOLOR}; */
-/* }; */
-
Index: src/cql/seqret.cpp
===================================================================
--- src/cql/seqret.cpp	(revision 2842)
+++ src/cql/seqret.cpp	(working copy)
@@ -1,68 +1 @@
-#include "node.h"
-SeqRet::SeqRet(bool b){
-  success=b;
-};
 
-SeqRet::SeqRet(Game*game,int offset){
-  uassert(offset>=0,"seqret");
-  success=true;
-  ids.push_back(MarkBoard::identity(game));
-  offsets.push_back(offset);
-}
-
-int SeqRet::getOffset(int index)const{
-  int trueindex=getTrueIndex(index);
-  return offsets.at(trueindex);
-}
-
-moveT* SeqRet::getId(int index)const{
-  int trueindex=getTrueIndex(index);
-  return ids.at(trueindex);
-}
-
-int SeqRet::getTrueIndex(int index)const{
-  int len=getLength();
-  uassert(index>=0&&index<len);
-  int ret=len-index-1;
-  uassert(ret>=0&&ret<len);
-  return ret;
-}
-  
-void SeqRet::print(){
-  printf("<%s %d",thisclass(),success);
-  indent();
-  for(int i=0;i<getLength();++i){
-    printf("\n");
-    tab();
-    printf("id/off %d of %d: %p %d",
-	   i,
-	   getLength(),
-	   getId(i),
-	   getOffset(i));
-  }
-  unindent();
-  printf("\n");
-}
-
-bool operator<(const SeqRet&a, const SeqRet&b){
-  if (a.isFalse()&&b.isFalse())return false;
-  if (a.isFalse()&&b.isTrue())return true;
-  if (a.isTrue()&&b.isFalse())return false;
-  uassert(a.isTrue()&&b.isTrue());
-  return a.getLength()<b.getLength();
-}
-
-void SeqRet::addParent(Game*game, int offset){
-  uassert(ids.size()==offsets.size());
-  uassert(isTrue(),"SeqRet::addParent false");
-  //  uassert(offsets.empty()||offset<0||offsets.back()>=offset,"SeqRet offset");
-  ids.push_back(MarkBoard::identity(game));
-  offsets.push_back(offset);
-}
-
-int SeqRet::getLength()const{
-  int len=(int)(ids.size());
-  uassert(len==(int)(offsets.size()));
-  uassert(len<10000,"Too long seqret");
-  return len;
-}
Index: src/cql/seqret.h
===================================================================
--- src/cql/seqret.h	(revision 2842)
+++ src/cql/seqret.h	(working copy)
@@ -1,20 +1 @@
-#pragma once
-class SeqRet{
- public:
-  bool success{false};
-  vector<moveT*>ids;
-  vector<int>offsets;
-  bool isTrue()const{return success;}
-  bool isFalse() const{return !success;}
-  void addParent(Game*game,int offset);
-  SeqRet(bool);
-  SeqRet(Game*game, int offset);
-  void print();
-  const char* thisclass(){return "SeqRet";}
-  moveT* getId(int index)const;
-  int getOffset(int index)const;
-  int getLength()const;
- private:
-  int getTrueIndex(int i)const;
-};
-bool operator<(const SeqRet&,const SeqRet&);
+
Index: src/cql/sequence.h
===================================================================
--- src/cql/sequence.h	(revision 2842)
+++ src/cql/sequence.h	(working copy)
@@ -1,74 +1 @@
-#pragma once
 
-typedef vector<SeqConstituent*>SeqStack;
-class SequenceBase : public MFilter, public Countable, public VariationFlags, public CommentFlags{ //abstract
- public:
-  bool match_position(Game*game);
-  bool isSkip()const;
-  colorT getSkipColor()const;
-  bool skipColor(colorT)const;
-  bool skipCurrentPosition()const;
-  void clearSkipColor();
-  void setSkipColor(colorT);
-  void initializeSkip();
-  void exitMatch();
-  
-  
-  SeqRet computeSkip(SeqStack&stack);
-  HolderConstituent* getSkipConstituent()const;
-  virtual SeqRet compute (SeqStack&);
-  virtual SeqRet compute(VectorConstituent*,SeqStack&);
-  virtual SeqRet compute(StarConstituent*,SeqStack&);
-  virtual SeqRet compute(RepeatConstituent*,SeqStack&);
-  virtual SeqRet compute(HolderConstituent*,SeqStack&)=0;
-  virtual SeqRet compute(PlusConstituent*,SeqStack&);
-  virtual SeqRet compute(OptionalConstituent*,SeqStack&);
-  virtual SeqRet computeNull(SeqStack&);
-  virtual void notate(SeqRet& ret)=0;
-  bool match_count(Game*game,NumValue*value);
-  vector<SeqConstituent*> constituents;
-  void print();
-  Range*range{NULL};
-  int count{-1};
-  void deepify();
-  SequenceBase(vector<SeqConstituent*> scs,Range*r, bool isskip,bool allownests);
-  vnode children();
-  int nconstituents()const;
-  bool valid_constituent (int offset)const;
-  Game*game{NULL};
-  SeqConstituent* getConstituent (int offset)const;
-  void setOffsets();
- private:
-  HolderConstituent* theWhiteHolder{NULL};
-  HolderConstituent* theBlackHolder{NULL};
-  colorT theSkipColor{NOCOLOR};
-
-  //nest members
- public:
-  static set<SequenceBase*>*nestGetSequenceFilters();
-  static void nestsClear(); // clear all positions that have been seen by all filters, called to start a game
-  bool nestBan{false}; //whether this bans nesting
-  void nestRegisterPosition(Game*game); //register current position as having matched
-  bool nestSeenPosition(Game*game); // query if this filter has seen current position
-  void nestClearPositions(); //clear all positions that have been seen by this
-  set<moveT*> nestIds; // the positions that have been matched by part of the current filter
-};
-
-class PastNode : public SequenceBase{
- public:
-  SeqRet compute(HolderConstituent*,SeqStack&);
-  CVV(PastNode);
-  void notate(SeqRet& ret);
-  PastNode(vector<SeqConstituent*>,Range*,bool isskip, bool nestban);
-};
-
-class FutureNode : public SequenceBase{
- public:
-  SeqRet computeLinearize(HolderConstituent*,SeqStack&);
-  SeqRet compute(HolderConstituent*,SeqStack&);
-  CVV(FutureNode);
-  void notate(SeqRet& ret);
-  FutureNode(vector<SeqConstituent*>,Range*,bool isskip, bool nestban);
-  vector<MoveFutureNode*>linearize(Node* node);
-};
-
Index: src/cql/sequencebase.cpp
===================================================================
--- src/cql/sequencebase.cpp	(revision 2842)
+++ src/cql/sequencebase.cpp	(working copy)
@@ -1,304 +1 @@
-#include "node.h"
-void SequenceBase::print(){
-  printf("<%s at %p: %d constituents: ",thisclass(),this,nconstituents());
-  printVariationFlags();
-  if(isSilent())printf("silent ");
-  if (isSkip()) getSkipConstituent()->print();
-  printf("nestBan: %d",nestBan);
-  for(int i=0;i<nconstituents();++i){
-    printf("\n");
-    indent();
-    tab();
-    printf("<%d of %d: ",i,nconstituents());
-    getConstituent(i)->print();
-    unindent();
-  }
-  printf(" %s> ",thisclass());
-}
 
-vnode SequenceBase::children(){
-  vnode v;
-  for (SeqConstituent* c:constituents)
-    for (Node* child:c->children()){
-      uassert(c);
-      uassert(myindex(v,child)<0,"unexpected duplicate child");
-      v.push_back(child);
-    }
-  // Do NOT include the skipholders here because they will transform under flipcolor, which we do NOT want
-  return v;
-}
-  
-SequenceBase::SequenceBase(vector<SeqConstituent*>cs,Range*r,bool isskip,bool nestbanparam){
-  range=r;
-  constituents=cs;
-  nestBan=nestbanparam;
-  for(auto c:constituents)uassert(c,"sbsb");
-  if (isskip) {
-    theWhiteHolder=new HolderConstituent(new ColorNode(WHITE));
-    theBlackHolder=new HolderConstituent(new ColorNode(BLACK));
-  }
-}
-
-bool SequenceBase::valid_constituent (int offset)const{
-  uassert(offset>=0,"vcsb");
-  return offset<nconstituents();
-}
-
-SeqConstituent* SequenceBase::getConstituent (int offset)const{
-  uassert(valid_constituent(offset),"internal in getConstituent");
-  return constituents.at(offset);
-};
-
-int SequenceBase::nconstituents()const{
-  return (int)(constituents.size());
-}
-
-void SequenceBase::setOffsets(){
-  for (int i=0;i<constituents.size();++i)
-    constituents[i]->setOffsets(i);
-}
-
-
-bool SequenceBase::match_position(Game*g){
-  uassert(game==NULL&&g,"fnmpg");
-  if (nestBan&&nestSeenPosition(g))
-    return false;
-  game=g;
-  if(isSkip()) initializeSkip();
-  auto me=MarkBoard::identity(game);
-  count=-1;
-  uassert(isVariationsSet(),"variations not yet set");
-  SeqStack stack=constituents;
-  std::reverse(stack.begin(),stack.end());
-  size_t len=stack.size();
-  SeqRet ret= compute(stack);
-  uassert(len=stack.size(),"fnmp mismatch");
-  uassert(MarkBoard::identity(game)==me,"fnmp me");
-  if(ret.isFalse()){exitMatch();return false;}
-  count=ret.getLength();
-  if (isSkip()) count=(count+1)/2;
-  if(range&&!range->valid(count)) {exitMatch();return false;}
-  notate(ret);
-  exitMatch();
-  return true;
-}
-
-void SequenceBase::exitMatch(){
-  uassert(game,"sbem g");
-  game=NULL;
-  if(isSkip()){
-    uassert(theSkipColor!=NOCOLOR,"sbem s");
-    theSkipColor=NOCOLOR;
-  }
-}
-
-SeqRet SequenceBase::compute(SeqStack &stack){
-  if(stack.empty())return SeqRet(true);
-  if(isSkip()&&skipCurrentPosition())
-    return computeSkip(stack);
-  size_t startlen=stack.size();
-  SeqConstituent*top=stack.back();
-  stack.pop_back();
-  StarConstituent*star=dynamic_cast<StarConstituent*>(top);
-  RepeatConstituent*repeat=dynamic_cast<RepeatConstituent*>(top);
-  HolderConstituent*holder=dynamic_cast<HolderConstituent*>(top);
-  VectorConstituent*vc=dynamic_cast<VectorConstituent*>(top);
-  PlusConstituent*plus=dynamic_cast<PlusConstituent*>(top);
-  OptionalConstituent*optional=dynamic_cast<OptionalConstituent*>(top);
-  SeqRet ret(false);
-  if(star)
-    ret=compute(star,stack);
-  else if (repeat)
-    ret=compute(repeat,stack);
-  else if(holder)
-    ret=compute(holder,stack);
-  else if (vc)
-    ret=compute(vc,stack);
-  else if (plus)
-    ret=compute(plus,stack);
-  else if (optional)
-    ret=compute(optional,stack);
-  else
-    uassert(false,"bad top fnc");
-  stack.push_back(top);
-  uassert(stack.size()==startlen,"bad stacksize fncmain");
-  return ret;
-}
-
-SeqRet SequenceBase::compute(RepeatConstituent*repeat,SeqStack&stack){
-  int nrepetitions=0;
-  SeqConstituent*c = repeat->constituent;
-  size_t stacklen=stack.size();
-  SeqRet best=SeqRet(false);
-  for (nrepetitions=repeat->min;
-       nrepetitions<=repeat->max;
-       ++nrepetitions){
-    uassert(stack.size()==stacklen);
-    for (int i=0;i<nrepetitions;++i)
-      stack.push_back(c);
-    uassert(stack.size()==stacklen+nrepetitions);
-    SeqRet ret=compute(stack);
-    uassert(stack.size()==stacklen+nrepetitions);
-    best=std::max(ret,best);
-    for (int i=0;i<nrepetitions;++i)
-      stack.pop_back();
-    uassert(stack.size()==stacklen);
-  }
-  uassert(stack.size()==stacklen);
-  return best;
-}
-
-    
-SeqRet SequenceBase::compute(StarConstituent*star,SeqStack&stack){
-  SeqRet unused=compute(stack);
-  SeqConstituent*c=star->constituent;
-  size_t stacklen=stack.size();
-  stack.push_back(star);
-  stack.push_back(c);
-  SeqRet used=compute(stack);
-  uassert(stack.size()==stacklen+2);
-  stack.pop_back();
-  stack.pop_back();
-  uassert(stack.size()==stacklen);
-  return std::max(used,unused);
-}
-
-SeqRet SequenceBase::compute(PlusConstituent*plus,SeqStack&stack){
-  StarConstituent*star=plus->getStarConstituent();
-  SeqConstituent*c=star->constituent;
-  size_t stacklen=stack.size();
-  stack.push_back(star);
-  stack.push_back(c);
-  SeqRet ret=compute(stack);
-  uassert(stack.size()==stacklen+2);
-  stack.pop_back();
-  stack.pop_back();
-  uassert(stack.size()==stacklen);
-  return ret;
-}
-
-SeqRet SequenceBase::compute(OptionalConstituent*optional,SeqStack&stack){
-  SeqConstituent*c=optional->constituent;
-  size_t stacklen=stack.size();
-  SeqRet unused=compute(stack);
-  uassert(stacklen==stack.size(),"fncoclen");
-  stack.push_back(c);
-  SeqRet used=compute(stack);
-  uassert(stack.size()==stacklen+1);
-  stack.pop_back();
-  uassert(stack.size()==stacklen);
-  return std::max(used,unused);
-}
-
-SeqRet SequenceBase::compute(VectorConstituent*vc,SeqStack&stack){
-  size_t stacklen=stack.size();
-  uassert(vc,"fncvc");
-  vector<SeqConstituent*>v=vc->constituents;
-  int nconstituents=(int)(v.size());
-  uassert(nconstituents,"fncvc");
-  for(int i=nconstituents-1;i>=0;--i)
-    stack.push_back(v.at(i));
-  uassert(stack.size()==stacklen+nconstituents,"fnclen");
-  SeqRet ret=compute(stack);
-  uassert(stack.size()==stacklen+nconstituents,"fnclen");
-  for(int i=0;i<nconstituents;++i)
-    stack.pop_back();
-  uassert(stack.size()==stacklen,"fnclen3");
-  return ret;
-}
-
-SeqRet SequenceBase::computeNull(SeqStack& stack){
-  size_t startsize=stack.size();
-  if(stack.empty()) return SeqRet(true);
-  SeqConstituent* top=stack.back();
-  if (!top->matchesNull())
-    return SeqRet(false);
-  stack.pop_back();
-  SeqRet ret=computeNull(stack);
-  stack.push_back(top);
-  uassert(stack.size()==startsize,"fncn size");
-  return ret;
-}
-
-void SequenceBase::deepify(){
-  clonevec(constituents); // VERY IMPORTANT!!!
-  // The next two lines are essentially optional but included for consistency
-  if(theWhiteHolder)theWhiteHolder=theWhiteHolder->clone();
-  if(theBlackHolder)theBlackHolder=theBlackHolder->clone();
-}
-/********SKIP METHODS**************/
-
-void SequenceBase::initializeSkip(){
-  uassert(game,"sbis");
-  colorT tomove=game->GetCurrentPos()->GetToMove();
-  uassert(tomove==WHITE||tomove==BLACK,"sbist");
-  if (tomove==WHITE)
-    setSkipColor(BLACK);
-  else if (tomove==BLACK)
-    setSkipColor(WHITE);
-}
-
-SeqRet SequenceBase::computeSkip(SeqStack &stack){
-  uassert(isSkip()&&skipCurrentPosition(),"computeSkip internal");
-  HolderConstituent*skipconstituent=getSkipConstituent();
-  return compute(skipconstituent,stack);
-}
-
-
-HolderConstituent*SequenceBase::getSkipConstituent()const{
-  colorT c=getSkipColor();
-  HolderConstituent* ret=NULL;
-  switch(c){
-  case WHITE:ret=theWhiteHolder;break;
-  case BLACK:ret=theBlackHolder;break;
-  default: uassert(false,"hcgsh: internal");
-  }
-  uassert(ret,"getskipholder: internal");
-  return ret;
-}
-
-bool SequenceBase::isSkip()const{
-  return theWhiteHolder!=NULL;
-}
-
-colorT SequenceBase::getSkipColor()const{
-  uassert(isSkip(),"sbgsc");
-  colorT ret=theSkipColor;
-  uassert(ret==WHITE||ret==BLACK);
-  return ret;
-}
-
-bool SequenceBase::skipColor(colorT c)const{
-  uassert(isSkip()&&c==WHITE||c==BLACK,"sbsc");
-  return getSkipColor()==c;
-}
-
-void SequenceBase::clearSkipColor(){
-  uassert(isSkip(),"sbcsc");
-  uassert(theSkipColor==WHITE||theSkipColor==BLACK,"sbcsc col");
-  theSkipColor=NOCOLOR;
-}
-
-void SequenceBase::setSkipColor(colorT c){
-  uassert(isSkip()&&(c==WHITE||c==BLACK),"sbssc");
-  uassert(theSkipColor==NOCOLOR,"sbssc nc");
-  theSkipColor=c;
-}
-
-bool SequenceBase::skipCurrentPosition()const{
-  uassert(isSkip()&&game!=NULL);
-  colorT tomove=game->GetCurrentPos()->GetToMove();
-  uassert(tomove==WHITE||tomove==BLACK,"sbscp");
-  return skipColor(tomove);
-}
-
-
-bool SequenceBase::match_count(Game*game, NumValue*value){
-  if (match_position(game)){
-    uassert (count>=0,"match_count");
-    *value=(NumValue)(count);
-    return true;
-  }
-  return false;
-}
-    
Index: src/cql/sequencematch.cpp
===================================================================
--- src/cql/sequencematch.cpp	(revision 2842)
+++ src/cql/sequencematch.cpp	(working copy)
@@ -1,115 +1 @@
-#include "node.h"
-#include "tokenstream.h"
-SequenceBase*Tokens::match_sequencenode(){
-  bool isfuture{false};
-  bool is2{false};
-  bool nestban{false};
-  if (match_keyword("next")){
-    isfuture=true;
-    is2=false;
-  }
-  else if (match_keyword("previous")){
-    isfuture=false;
-    is2=false;
-  }
-  else if (match_keyword("next2")){
-    isfuture=true;
-    is2=true;
-  }
-  else if (match_keyword("previous2")){
-    isfuture=false;
-    is2=true;
-  }
-  else return NULL;
-  Range*range=match_range();
-  if (match_keyword("nestban"))
-    nestban=true;
-  if (nestban&&!isfuture)
-    show_error("the 'nestban' keyword can only be used with 'next'");
-  VectorConstituent*argsv=match_vectorconstituent();
-  if(!argsv)
-    show_error("invalid or missing argument list in next/previous");
-  vector<SeqConstituent*>ps=argsv->constituents;
-  SequenceBase*ret=NULL;
-  if(isfuture) ret = new FutureNode(ps,range,is2,nestban);
-  else ret = new PastNode(ps,range,is2,nestban);
-  ret->setOffsets();
-  return ret;
-}
 
-vector<SeqConstituent*> Tokens::match_some_seqconstituents(){
-  vector<SeqConstituent*>v;
-  while(true){
-    SeqConstituent*c=match_seqconstituent();
-    if(!c)break;
-    v.push_back(c);
-  }
-  return v;
-}
-
-SeqConstituent* Tokens::match_seqconstituent(){
-  SeqConstituent*current=NULL;
-  if(!current)current=match_vectorconstituent();
-  if(!current)current=match_holderconstituent();
-  if(!current) return NULL;
-  return match_seqsuffix(current);
-}
-
-SeqConstituent* Tokens::match_seqsuffix(SeqConstituent*c){
-  uassert(c,"stms");
-  SeqConstituent*current=c;
-  while(true){
-    if(match_star())
-      current=new StarConstituent(current);
-    else if(match_plus())
-      current=new PlusConstituent(current);
-    else if (match_questionmark())
-      current=new OptionalConstituent(current);
-    else {
-      Range*range=match_repeat_range();
-      if(!range) break;
-      current=new RepeatConstituent(current,range->min,range->max);
-    }
-  }
-  return current;
-}
-  
-//This expects either a non-lparen start OR a valid paren contained nonempty list of seqconstituent
-VectorConstituent* Tokens::match_vectorconstituent(){
-  vector<SeqConstituent*>args;
-  if(!match_lparen())return NULL;
-  args=match_some_seqconstituents();
-  if(!match_rparen())
-    show_error("malformed expression inside next/previous: expected ')'");
-  if(args.empty())
-    show_error("unexpected null length sequence in next/previous");
-  return new VectorConstituent(args);
-}
-
-HolderConstituent* Tokens::match_holderconstituent(){
-  Node*n=match_basicnode();
-  if(!n)return NULL;
-  MFilter*filter=dynamic_cast<MFilter*>(n);
-  if(!filter)
-    show_error("Invalid and unexpected entry in next/previous");
-  return new HolderConstituent(filter);
-}
-
-Range* Tokens::match_repeat_range(){
-  int x=save();
-  if (!match_lbrace()){
-    restore(x);
-    return NULL;}
-  Range*range=match_range();
-  if(!range){
-    restore(x);
-    return NULL;}
-  if(!match_rbrace()){
-    restore(x);
-    return NULL;
-  }
-  if(range->min<0||range->max<range->min)
-    show_error("Invalid range to repeat expression: min must be nonnegative and smaller than max");
-  return range;
-}
-  
Index: src/cql/sequencenest.cpp
===================================================================
--- src/cql/sequencenest.cpp	(revision 2842)
+++ src/cql/sequencenest.cpp	(working copy)
@@ -1,38 +1 @@
-#include "node.h"
-void SequenceBase::nestsClear(){
-  for (SequenceBase* filterp: *nestGetSequenceFilters()){
-    uassert(filterp,"nestsClear:internal");
-    filterp->nestClearPositions();
-  }
-}
 
-void SequenceBase::nestRegisterPosition(Game*game){
-  moveT*me=MarkBoard::identity(game);
-  nestIds.insert(me);
-}
-
-bool SequenceBase::nestSeenPosition(Game*game){
-  uassert(nestBan,"nestSeenPosition: internal");
-  moveT*me=MarkBoard::identity(game);
-  if(nestIds.count(me)>0)return true;
-  return false;
-}
-
-void SequenceBase::nestClearPositions(){
-  nestIds.clear();
-}
-
-set<SequenceBase*>* SequenceBase::nestGetSequenceFilters(){
-  if (CqlAllSequences) return CqlAllSequences;
-  CqlAllSequences=new set<SequenceBase*>;
-  CqlNode*root=CqlParseRoot;
-  uassert(root,"nestGetSequenceFilters: internal");
-  auto descendants=root->descendants();
-  for(auto d : descendants){
-    uassert(d,"nestGetSequenceFilters: null descendant");
-    SequenceBase* s= dynamic_cast<SequenceBase*>(d);
-    if(s) CqlAllSequences->insert(s);
-  }
-  return CqlAllSequences;
-}
-
Index: src/cql/setbase.cpp
===================================================================
--- src/cql/setbase.cpp	(revision 2842)
+++ src/cql/setbase.cpp	(working copy)
@@ -1,12 +1 @@
-#include "node.h"
-bool SetBase::match_position(Game*game){
-  return getSquares(game).nonempty();
-}
 
-// SquareMask SetBase::getSquares(Game*game){
-//   SquareMask mask;
-//   for(squareT square=0;square<64;++square)
-//     if (match_square(square,game))
-//       mask.insert(square);
-//   return mask;
-// }
Index: src/cql/shifttransform.cpp
===================================================================
--- src/cql/shifttransform.cpp	(revision 2842)
+++ src/cql/shifttransform.cpp	(working copy)
@@ -1,88 +1 @@
-#include "node.h"
 
-squareT ShiftTransform::transform(squareT square){
-  uassert(square_valid(square));
-  int x=square_file(square);
-  int y=square_rank(square);
-  int nx=x+xoffset;
-  int ny=y+yoffset;
-  if(!file_valid(nx)||!rank_valid(ny))
-    return 65;
-  return square_make(nx,ny);
-}
-
-ShiftTransform::ShiftTransform(int xoff,int yoff):xoffset(xoff),yoffset(yoff){
-  uassert(xoff>=-7&&xoff<=7);
-  uassert(yoff>=-7&&yoff<=7);
-  uassert(xoff!=0 || yoff!=0);
-}
-
-void ShiftTransform::print(){
-  printf("<%s %d %d>",thisclass(),xoffset,yoffset);
-}
-
-vector<Transform*>ShiftTransform::allShift(){
-  vector<Transform*>v;
-  for(int xo=-7;xo<=7;++xo)
-      for(int yo=-7;yo<=7;++yo)
-	if(xo||yo)
-	  v.push_back(new ShiftTransform(xo,yo));
-  return v;
-}
-
-vector<Transform*>ShiftTransform::shiftHorizontal(){
-  vector<Transform*>v;
-  for(int xo=-7;xo<=7;++xo)
-    if(xo)
-      v.push_back(new ShiftTransform(xo,0));
-  return v;
-}
-
-vector<Transform*>ShiftTransform::shiftVertical(){
-  vector<Transform*>v;
-  for(int yo=-7;yo<=7;++yo)
-    if(yo)
-      v.push_back(new ShiftTransform(0,yo));
-  return v;
-}
-
-SquareMask ShiftTransform::transform(SquareMask mask){
-  DihedralTransform swap(false,false,true);
-  DihedralTransform vflip(true,false,false);
-  uassert(xoffset||yoffset);
-  if(xoffset&&yoffset){
-    ShiftTransform xt(xoffset,0);
-    ShiftTransform yt(0,yoffset);
-    return xt.transform(yt.transform(mask));
-  }
-  if(xoffset==0){
-    ShiftTransform newxt(yoffset,0);
-    return swap.transform(newxt.transform(swap.transform(mask)));
-  }
-  if(xoffset<0){
-    ShiftTransform newxt(-xoffset,0);
-    return vflip.transform(newxt.transform(vflip.transform(mask)));
-  }
-  uassert(xoffset>0&&yoffset==0);
-  if(xoffset>1){
-    ShiftTransform right(1,0);
-    SquareMask current=mask;
-    for(int i=0;i<xoffset;++i)
-      current=right.transform(current);
-    return current;
-  }
-  uassert(xoffset==1&&yoffset==0);
-  SquareMask ret;
-  for(int sq=0;sq<64;++sq){
-    int newsq=transform(sq);
-    if(square_valid(newsq)&&mask.member(sq))
-      ret.insert(newsq);
-  }
-  for(int rank=0;rank<8;++rank)
-    if (mask.rankCount(rank)==8){
-      int popin=square_make(0,rank);
-      if(mask.member(popin))
-	ret.insert(popin);
-    }
-  return ret;
-}
Index: src/cql/sitenode.cpp
===================================================================
--- src/cql/sitenode.cpp	(revision 2842)
+++ src/cql/sitenode.cpp	(working copy)
@@ -1,16 +1 @@
-#include "node.h"
-SiteNode::SiteNode(const char* n):name{n}{
-  uassert(n&&name,"sitenode internal");
-}
 
-bool SiteNode::match_game(Game*game){
-  char* site=game->GetSiteStr();
-  if(site&&strstr(site,name))
-    return true;
-  return false;
-}
-  
-void SiteNode::print(){
-  printf("<%s %s>",thisclass(),name);
-}
-  
Index: src/cql/sortvalue.cpp
===================================================================
--- src/cql/sortvalue.cpp	(revision 2842)
+++ src/cql/sortvalue.cpp	(working copy)
@@ -1,18 +1 @@
-#include "node.h"
-SortValue::SortValue(NumValue v, bool ismax){
-  theIsMax=ismax;
-  theValue=v;
-}
 
-void SortValue::print(){
-  printf("<%s value: %d ismax: %d>",thisclass(),getValue(),isMax());
-}
-bool operator< (const SortValue& a, const SortValue& b){
-  uassert(a.isMax()&&b.isMax()||a.isMin()&&b.isMin(),
-	  "< sortvalue internal");
-  if(a.isMax())
-    return a.getValue()<b.getValue();
-  else
-    return a.getValue()>b.getValue();
-}
-  
Index: src/cql/sortvalue.h
===================================================================
--- src/cql/sortvalue.h	(revision 2842)
+++ src/cql/sortvalue.h	(working copy)
@@ -1,18 +1 @@
-#pragma once
-class SortValue{
- public:
-  bool isMax()const{return theIsMax;}
-  bool isMin()const{return !theIsMax;}
-  NumValue getValue()const{return theValue;}
-  void print();
-  SortValue(NumValue v,bool ismax);
- private:
-  bool theIsMax{false};
-  NumValue theValue{0};
-  char*thisclass(){return "SortValue";}
-};
 
-bool operator< (const SortValue& a, const SortValue& b);
-
-  
-  
Index: src/cql/squaremask.cpp
===================================================================
--- src/cql/squaremask.cpp	(revision 2842)
+++ src/cql/squaremask.cpp	(working copy)
@@ -1,82 +1 @@
-#include "util.h"
-void SquareMask::print(){
-  if(full())
-    printf("<all>");
-  else if(empty())
-      printf("<none>");
-  else{
-      printf("[");
-      for(squareT s : getSquares())
-	square_print(s);
-      printf("]");
-  }
-}
 
-void SquareMask::boardprint(){
-  squareT s;
-  for (int rank=7; rank>=0; rank--) {
-    printf("%c: ",rank_to_char_cql(rank));
-    for (int file=0; file<=7; file++) {
-      s = square_make(file,rank);
-      char c=member(s)?'1': rank%2==file%2 ? '+' : '-';
-      printf("%c",c);
-    }
-    printf ("\n");
-  }
-  printf("   abcdefgh\n");
-}
-
-void SquareMask::boardprint(Mask m){
-  SquareMask(m).boardprint();
-}
-
-void SquareMask::printnl(){
-  print();
-  printf("\n");
-}
-
-void mask_print(Mask m){
-  SquareMask(m).printnl();
-}
-
-int SquareMask::size(){
-  int s=0;
-  Mask tmp=mask;
-  while(tmp){
-    s+=tmp%2;
-    tmp=tmp>>1;
-  }
-  return s;
-}
-
-
-vector<squareT> SquareMask::getSquares(){
-  vector<squareT> v;
-  for(int i=0;i<64;++i)
-    if(member(i)) v.push_back(i);
-  return v;
-}
-
-SquareMask::SquareMask(const vector<squareT>&squares){
-  mask=0;
-  for(auto sq:squares)
-    mask |= ((Mask)1<<sq);
-}
-
-int SquareMask::rankCount(int rank){
-  uassert(rank_valid(rank));
-  int count=0;
-  for(int file=0;file<8;++file){
-    squareT square=square_make(file,rank);
-    if (member(square))++count;
-  }
-  return count;
-}
-
-SquareMask SquareMask::all(){
-  Mask tmp=0;
-  tmp= ~tmp;
-  return SquareMask(tmp);
-}
-  
-    
Index: src/cql/squaremask.h
===================================================================
--- src/cql/squaremask.h	(revision 2842)
+++ src/cql/squaremask.h	(working copy)
@@ -1,33 +1 @@
-#pragma once
-typedef unsigned long long Mask;
-class SquareMask{
- public:
-  Mask mask{0};
-  SquareMask(Mask m){mask=m;}
-  SquareMask(int i); // must not be linked to
-  SquareMask(unsigned int i); // must not be linked to
-  static SquareMask fromSquare(squareT square){return SquareMask((Mask)1<<square);}
-  SquareMask(const vector<squareT>&);
-  SquareMask(){}
-  void print();
-  void boardprint();
-  static void boardprint(Mask m);
-  const char* thisclass(){return "SquareMask";}
-  void printnl();
-  int size();
-  void clear(){mask=0;}
-  bool empty(){return mask==0;}
-  static SquareMask all();
-  bool nonempty(){return !empty();}
-  bool full() {return (~mask)==0;}
-  bool member(int s){return (mask>>s)%2;}
-  void insert(int s){mask|=((Mask)1<<s);}
-  int rankCount(int rank);
-  vector<squareT> getSquares();
-  void operator|= (SquareMask o){mask|=o.mask;}
-  SquareMask operator|(SquareMask o){return SquareMask(mask|o.mask);}
-  void operator&= (SquareMask o){mask&=o.mask;}
-  SquareMask operator&(SquareMask o){return SquareMask(mask&o.mask);}
-  SquareMask operator~(){return SquareMask(~mask);}
-};
-  
+
Index: src/cql/squarevariable.cpp
===================================================================
--- src/cql/squarevariable.cpp	(revision 2842)
+++ src/cql/squarevariable.cpp	(working copy)
@@ -1,53 +1 @@
-#include "node.h"
-// SquareVariable Stuff ////////
 
-SquareVariable* Variable::getSquareVariable(const char*nm){
-  SquareVariable* ret=NULL;   
-  Variable*v=find(nm);
-  if(v) {
-    ret=dynamic_cast<SquareVariable*>(v);
-    uassert(ret,"cannot make square variable from tag variable",nm);
-    return ret;
-  }
-  return createSquareVariable(nm);
-}
-
-SquareVariable* Variable::createSquareVariable(const char*nm){
-  uassert(nm,"invalid null variable name");
-  uassert(!find(nm),"internal variable");
-  SquareVariable*s=new SquareVariable(nm);
-  getVariables()->push_back(s);
-  return s;
-}
-
-void SquareVariable::bindSquare(squareT s){
-  uassert(!bound,"attempt to bind variable already bound: ",name);
-  uassert(square_valid(s),"internal bad square argument to bindSquare");
-  square=s;
-  used=false;
-  bound=true;
-}
-
-void SquareVariable::print(){
-  //  if(1)printf("called print on variable\n");
-  printf("<%s %s used: %d ",thisclass(),name,used);
-  if(bound){
-    printf("square: ");
-    square_print(square);
-  }
-  else printf("unbound");
-  printf(">");
-}
-  
-bool SquareVariable::getSquare(squareT*s){
-  used=true;
-  uassert(bound,"internal, getsquare");
-  uassert(square_valid(square));
-  *s=square;
-  return true;
-}
-
-SquareVariable::SquareVariable(const char*nm){
-  name=nm; //not sure if necessary?
-}
-
Index: src/cql/starconstituent.cpp
===================================================================
--- src/cql/starconstituent.cpp	(revision 2842)
+++ src/cql/starconstituent.cpp	(working copy)
@@ -1,18 +1 @@
-#include "node.h"
-StarConstituent::StarConstituent(SeqConstituent*c){
-  uassert(c,"nullscsc");
-  constituent=c;
-}
 
-void StarConstituent::print(){
-  printf("<%s ",thisclass());
-  constituent->print();
-  printf(">");
-}
-
-void StarConstituent::setOffsets(int i){
-  setOffset(i);
-  constituent->setOffsets(i);
-}
-
-
Index: src/cql/tagvariable.cpp
===================================================================
--- src/cql/tagvariable.cpp	(revision 2842)
+++ src/cql/tagvariable.cpp	(working copy)
@@ -1,63 +1 @@
-#include "node.h"
 
-TagVariable* Variable::createTagVariable(const char*nm){
-  uassert(nm,"invalid null var name in tag create");
-  uassert(!find(nm),"internal variable tag");
-  TagVariable*t=new TagVariable(nm);
-  getVariables()->push_back(t);
-  return t;
-}
-
-TagVariable* Variable::getTagVariable(const char*nm){
-  TagVariable * ret=NULL;
-  Variable *v=find(nm);
-  if(v){
-    ret=dynamic_cast<TagVariable*>(v);
-    uassert(ret,"expected ID but got already declared square variable: ",nm);
-    return ret;
-  }
-  return createTagVariable(nm);
-}
-
-TagVariable::TagVariable(const char*nm){
-  name=nm;
-  uassert(nm);
-}
-
-bool TagVariable::getSquare(squareT*s){
-  uassert(MarkBoard::global(),"internal tags not turned on");
-  uassert(bound,"internal tag get");
-  uassert(mark_valid(tag));
-  int soption=MarkBoard::getSquare(tag);
-  if (!square_valid(soption)) return false;
-  *s=soption;
-  return true;
-}
-
-void TagVariable::bindTag(markT val){
-  uassert(mark_valid(val));
-  uassert(isUnbound(),"attempt to bind ID when it is already bound");
-  tag=val;
-  squareT neworigin=MarkBoard::getSquare(tag);
-  uassert(square_valid(neworigin),"TagVariable: binding failure: cannot find origin");
-  origin=neworigin;
-  bound=true;
-}
-
-squareT TagVariable::getOrigin(){
-  uassert(isBound(),"TagVariable: getOrigin: not bound");
-  uassert(square_valid(origin),"TagVariable: bad origin");
-  return origin;
-}
-
-void TagVariable::print(){
-  //  if(1)printf("called print on variable\n");
-  printf("<%s %s ",thisclass(),name);
-  if(bound){
-    printf("tag: %d",tag);
-  }
-  else printf("unbound");
-  printf(">");
-}
-
-
Index: src/cql/token.cpp
===================================================================
--- src/cql/token.cpp	(revision 2842)
+++ src/cql/token.cpp	(working copy)
@@ -1,139 +1 @@
-#include <stdio.h>
-#include "node.h"
-int Token::CurrentLine{0};
-int Token::CurrentChar{0};
 
-
-      
-char* Token::locationString(){
-  char buffer[100];
-  sprintf(buffer,"{Line %d, Character %d}",line,character);
-  return util::copy(buffer);
-}
-
-void Token::printLocation(){
-  printf("%s",locationString());
-}
-
-StringToken::StringToken(const char *c){
-  uassert(c);
-  value=c;
-}
-
-bool PieceToken::isAllowed(char c){
-  static char* allowed="RNBQKPrnbqkpAaU?_";
-  for (int i=0;i<strlen(allowed);++i)
-    if (c==allowed[i])return true;
-  return false;
-}
-
-PieceToken::PieceToken(char c){
-  uassert(isAllowed(c));
-  value=c;
-}
-
-PieceToken* PieceToken::create(char c){
-  if(isAllowed(c)) return new PieceToken(c);
-  return NULL;
-}
-
-SquareToken::SquareToken(int mif, int maf, int mir, int mar){
-  uassert(isAllowed(mif,maf,mir,mar),"Internal error: bad square arguments");
-  minfile=mif;
-  maxfile=maf;
-  minrank=mir;
-  maxrank=mar;
-}
-
-bool SquareToken::isAllowed(int mif, int maf, int mir, int mar){
-  return file_valid(mif)&&
-    file_valid(maf)&&
-    rank_valid(mir)&&
-    rank_valid(mar)&&
-    mif<=maf&&
-    mir<=mar;
-}
-
-bool StringToken::eq(const char*v){
-  uassert(v!=NULL);
-  return strcmp(v,value)==0;
-}
-
-void OneToken::print(){
-  printf("'%c' at %s\n",getChar(),locationString());
-}
-
-void SquareToken::print(){
-  //  printf("<%s %s ",thisclass(),locationString());
-  char mif=file_to_char_cql(minfile);
-  char maf=file_to_char_cql(maxfile);
-  char mir=rank_to_char_cql(minrank);
-  char mar=rank_to_char_cql(maxrank);
-  if(minfile==maxfile) printf("%c",mif);
-  else printf("%c-%c",mif,maf);
-  if(minrank==maxrank) printf("%c",mir);
-  else printf("%c-%c",mir,mar);
-  //  printf(">");
-}
-
-void StringToken::print(){
-  printf("<%s %s %s>",thisclass(),locationString(),value);
-}
-
-void IntToken::print(){
-  printf("<%s: %s %d>",thisclass(),locationString(),value);
-}
-  
-void PieceToken::print(){
-  //  printf("<%s: %s %c>",thisclass(),locationString(), value);
-  printf("%c",value);
-}
-
-
-PieceDesignatorToken::PieceDesignatorToken(vector<PieceToken*>ps,
-					   vector<SquareToken*>ss,
-					   vector<VariableToken*>vs){
-  pieces=ps;
-  squares=ss;
-  variables=vs;
-}
-
-void PieceDesignatorToken::print(){
-  printf("<%s %s",thisclass(),locationString());
-  printf(" pieces: ");
-  for(auto p : pieces) p->print();
-  printf(" squares: ");
-  for(auto s : squares) s->print();
-  if(variables.size()){
-    printf(" Vars: ");
-    for (auto v:variables) v->print();
-  }
-  printf(">");
-}
-
-VariableToken* PieceDesignatorToken::getAsVariableToken(){
-  if(pieces.size()!=1 || squares.size()!=1 || variables.size()!=1)
-    return NULL;
-  if(pieces[0]->value!='?')return NULL;
-  SquareToken*s=squares[0];
-  if(s->minfile!=0||
-     s->maxfile!=7||
-     s->minrank!=0||
-     s->maxrank!=7)return NULL;
-  return variables[0];
-}
-  
-  
-  // printf("<%s pieces: ",thisclass());
-  // for(int i=0;i<pieces.size();++i)
-  //   pieces[i]->print();
-  // printf(" squares: ");
-  // for(int i=0;i<squares.size();++i)
-  //   squares[i]->print();
-  // printf("> ");
-
-
-  void Token::print(){
-    printf("<%s %s>",thisclass(),locationString());
-}
-  
Index: src/cql/token.h
===================================================================
--- src/cql/token.h	(revision 2842)
+++ src/cql/token.h	(working copy)
@@ -1,177 +1 @@
-#pragma once
-#include "util.h"
-#include "deleteable.h"
-class PieceLoc;
-class SquareToken;
-class PieceToken;
 
-class Token:public Deleteable {
- public:
-  static int CurrentLine;
-  static int CurrentChar;
-  int line{CurrentLine};
-  int character{CurrentChar};
-  virtual int len()=0;
-
-  static void incrementLine(){++CurrentLine;CurrentChar=0;};
-  static void decrementLine(){--CurrentLine;uassert(CurrentLine>=1);}
-  static void incrementChar(){++CurrentChar;}
-  static void decrementChar(){--CurrentChar;uassert(CurrentChar>=0);}
-  void printLocation();
-  char* locationString();
-  virtual void print();
-  virtual const char* thisclass(){return "UnknownToken";}
-};
-
-class OneToken:public Token{
- public:
-  virtual char getChar()=0;
-  int len(){return 1;}
-  void print();
-};
-
-class BarToken:public OneToken{
- public:
-  virtual const char* thisclass(){return "BarToken";}
-  char getChar(){return '|';}
-};
-
-class StarToken:public OneToken{
- public:
-  virtual const char* thisclass(){return "StarToken";}
-  char getChar(){return '*';}
-};
-class PlusToken:public OneToken{
- public:
-  virtual const char* thisclass(){return "PlusToken";}
-  char getChar(){return '+';}
-};
-class QuestionMarkToken:public OneToken{
- public:
-  virtual const char* thisclass(){return "QuestionMarkToken";}
-  char getChar(){return '?';}
-};
-
-class LessThanToken:public OneToken{
- public:
-  const char* thisclass(){return "LessThanToken";}
-  char getChar(){return '<';}
-};
-
-class GreaterThanToken:public OneToken{
- public:
-  const char* thisclass(){return "GreaterThanToken";}
-  char getChar(){return '>';}
-};
-    
-class LParenToken:public OneToken{
- public:
-  virtual const char* thisclass(){return "LParenToken";}
-  char getChar(){return '(';}
-};
-
-class RParenToken: public OneToken{
- public:
-  virtual const char* thisclass(){return "RParenToken";}
-  char getChar(){return ')';}
-};
-
-class LBraceToken:public OneToken{
- public:
-  virtual const char* thisclass(){return "LBraceToken";}
-  char getChar(){return '{';}
-};
-
-class RBraceToken: public OneToken{
- public:
-  virtual const char* thisclass(){return "RBraceToken";}
-  char getChar(){return '}';}
-};
-
-class StringToken: public Token{
- public:
-  const char*value;
-  StringToken(const char*x);
-  void print();
-  virtual bool eq(const char*v);
-  virtual const char* thisclass(){return "StringToken";}
-  int len(){return strlen(value);}
-};
-
-class NameToken: public StringToken{
- public:
- NameToken(const char*x): StringToken(x){}
-  virtual const char* thisclass(){return "NameToken";}
-};
-
-class QuotedStringToken: public StringToken{
- public:
- QuotedStringToken(const char* x):StringToken(x){}
-  virtual const char* thisclass(){return "QuotedStringToken";}
-};
-
-class IntToken: public Token{
- public:
-  int value;
-  IntToken(int i){value=i;}
-  void print();
-  virtual const char* thisclass(){return "IntToken";}
-  int len(){return 1;}//not actually accurate
-};
-
-class KeywordToken:public Token{
- public:
-  const char*value;
- virtual const char* thisclass(){return "KeywordToken";}
- static bool isReserved(const char* s);
- bool eq(const char *v);
- KeywordToken(const char*v);
- void print();
- int len(){return strlen(value);}
-};
-
-class VariableToken: public StringToken{
- public:
- VariableToken(const char*x): StringToken(x){}
-  virtual const char* thisclass(){return "VariableToken";}
-};
-
-class PieceToken: public Token{
- public:
-  char value;
-  PieceToken(char v);
-  void print();
-  static PieceToken *create(char c);
-  static bool isAllowed(char c);
-  virtual const char* thisclass(){return "PieceToken";}
-  int len(){return 1;}
-};
-
-class PieceDesignatorToken:public Token{
- public:
-  PieceLoc* pieceloc{NULL};
-  vector<PieceToken*>pieces;
-  vector<SquareToken*> squares;
-  vector<VariableToken*> variables;
-  PieceDesignatorToken(vector<PieceToken*>,vector<SquareToken*>,vector<VariableToken*>);
-  VariableToken* getAsVariableToken();
-  void print();
-  virtual const char* thisclass(){return "PieceDesignatorToken";}
-  int len(){return 1;}//inaccurate
-  };
-typedef PieceDesignatorToken PDT;
-
-class SquareToken: public Token{
- public:
-  int minfile;
-  int maxfile;
-  int minrank;
-  int maxrank;
-  bool isAllowed(int mif, int maf, int mir, int mar);
-  SquareToken(int mif, int maf, int mir, int mar);
-  void print();
-  virtual const char* thisclass(){return "SquareToken";}
-  int len(){return 1;}
-};
-
-
Index: src/cql/tokenstream.cpp
===================================================================
--- src/cql/tokenstream.cpp	(revision 2842)
+++ src/cql/tokenstream.cpp	(working copy)
@@ -1,46 +1 @@
-#include "tokenstream.h"
-#include "util.h"
 
-void Tokens::print(){
-  printf("Tokens: Bottom: %d size: %lu Tokens:\n",bottom, tokens.size());
-  for(int i=0;i<tokens.size();++i){
-    printf("Token %d of %lu: ",i,tokens.size());
-    tokens[i]->print();
-    printf("\n");
-  }
-  printf("\n");
-}
-
-bool Tokens::eof(){
-  return bottom==(int)tokens.size();
-}
-
-Token* Tokens::current(){
-  if(eof())return NULL;
-  return tokens[bottom];
-}
-
-void Tokens::forward(){
-  uassert(!eof());
-  ++bottom;
-}
-
-Tokens::Tokens(vector<Token*>ts){
-  for(auto s:ts)
-    {uassert (s!=NULL);}
-  tokens=ts;
-  bottom=0;
-}
-
-int Tokens::save(){
-  return bottom;
-}
-
-void Tokens::restore(int x){
-  uassert(x<=bottom&&x>=0,"internal stack error");
-  bottom=x;
-}
-
-
-  
-  
Index: src/cql/tokenstream.h
===================================================================
--- src/cql/tokenstream.h	(revision 2842)
+++ src/cql/tokenstream.h	(working copy)
@@ -1,137 +1 @@
-#pragma once
-#include "util.h"
-#include "token.h"
-#include "node.h"
-    
-  
-class Tokens : public Deleteable{
- public:
-  void print();
-  int bottom;
-  vector<Token*>tokens;
-  bool eof();
-  Token* current();
-  int save();
-  void restore(int x);
-  void forward();
-  Tokens(vector<Token*> ts);
 
-  Node* match_cqlfeature();
-  StringToken* match_string();
-  StringToken* match_string(char*);
-  CqlNode* match_cqlnode();
-  PgnNode* match_pgnnode();
-  OutputNode* match_outputnode();
-  ResultNode* match_resultnode();
-  vector<Node*> match_some_cqlfeatures();
-  KeywordToken* match_keyword(const char*v);
-  bool match_lparen();
-  bool match_rparen();
-  bool match_bar();
-  Node* match_basicnode();
-  Node* match_basicnode_no_suffix();
-  Node* match_simplenode();
-  PieceLoc* match_pieceloc();
-  Node* match_compoundnode();
-  bool match_dot();
-  Node* match_tagnode();
-  Node* match_positionnode();
-  CountSquaresNode* match_countsquaresnode();
-  Token* match_variable();
-  vector<Node*> match_some_basicnodes();
-  ForallNode* match_forallnode();
-  Range* match_range();
-  Range* match_compoundrange();
-  IntToken* match_int();
-  VariationsNode* match_variationsnode();
-  GameNumberNode* match_gamenumbernode();
-  AttackNode* match_attacknode();
-  vector<SetBase*>* match_some_setbases();
-  RayNode* match_raynode();
-  KeywordToken* match_keyword();
-  MoveBase*match_movebase();
-  MoveNumberNode*match_movenumbernode();
-  NotNode*match_notnode();
-  KeywordToken*match_transformkeyword();
-  KeywordToken*match_raykeyword();
-  SetBase*match_set();
-  static vector<directionT> directionsFromRayKeyword(KeywordToken*);
-  //  bool match_lessthan();
-  //  bool match_greaterthan();
-  SequenceBase* match_sequencenode();
-  SquareVariable* match_squarevariable();
-  TagVariable* match_tagvariable();
-  SetBase* match_parenthesizedsetbase();
-  bool match_lbrace();
-  bool match_rbrace();
-  void show_error(const char* message);
-  VectorNode* match_vectornode();
-  vector<DirectionParameter> match_directionparameters();
-  DirectionParameter* match_directionparameter();
-  vector<Direction>match_direction();
-  vector<Direction> match_raydirections(bool * isattack);
-  TransformNode* match_transformnode();
-  TransformNode* match_shifttransform();
-  TransformNode* match_fliptransform();
-  NumericVariable* match_numericvariable();
-  Node* match_countable();
-  MatchCountNode* match_matchcountnode();
-  FutureStarNode* match_futurestarnode();
-  PastStarNode* match_paststarnode();
-  SetBase* match_inexpr();
-  AnyNode* match_anynode();
-  BetweenNode* match_betweennode();
-  ExtensionNode* match_extensionnode();
-  OnNode* match_onnode(Node* prefix);
-  SetBase*match_fromexp();
-  SetBase*match_toexp();
-  PieceLoc*match_promoteexp();
-  SetBase*match_enpassantexp();
-  EchoNode* match_echonode();
-  EchoSpec* match_echospec();
-  EchoSpec* match_echotransformspec();
-  vector<EchoSpec*> match_echospecs();
-  EchoMaxDistanceSpec* match_echomaxdistancespec();
-  EchoSumDistanceSpec* match_echosumdistancespec();
-  EchoTargetDistanceSpec* match_echotargetdistancespec();
-  EchoSourceDistanceSpec* match_echosourcedistancespec();
-  EchoLongestSubstringSpec* match_echolongestsubstringspec();
-  bool match_echoemptyspec();
-  EchoSquareSpec* match_echosquarespec();
-  EchoDistanceSpec* match_echoancestor();
-  EchoDistanceSpec* match_echodescendant();
-  PowerNode* match_powernode();
-  PowerDifferenceNode* match_powerdifferencenode();
-  Node* match_existsnode();
-  Node* match_pieceidnode();
-  vector<Transform*>match_echotransforms();
-  EchoSideToMoveSpec* match_echosidetomovespec();
-  OrNode* match_ornode(Node*prefix);
-  OriginNode* match_originnode();
-  MatchCommentNode* match_matchcommentnode();
-  const char* match_quotedstring();
-  bool match_keywords(const char *v1, const char*v2);
-  SilentFeatureNode* match_silentfeature();
-  Node* match_silent();
-  CommentBase* match_commentbase();
-  Node* match_parenthesizedcountable();
-  PlayerNode* match_playernode();
-  EloNode* match_elonode();
-  colorT match_color();
-  YearNode* match_yearnode();
-  EventNode* match_eventnode();
-  SiteNode* match_sitenode();
-  Node* match_sortbodynode();
-  NumericVariable* match_optionalnumericvariable(bool ismax);
-  SeqConstituent* match_seqconstituent();
-  vector<SeqConstituent*>match_some_seqconstituents();
-  bool match_star();
-  bool match_questionmark();
-  bool match_plus();
-  Range* match_repeat_range();
-  HolderConstituent*match_holderconstituent();
-  VectorConstituent*match_vectorconstituent();
-  SeqConstituent*match_seqsuffix(SeqConstituent*c);
-  bool match_keywordstar(const char* name);
-  NumericVariable*match_sortheader();
-};  
Index: src/cql/transform-parse.cpp
===================================================================
--- src/cql/transform-parse.cpp	(revision 2842)
+++ src/cql/transform-parse.cpp	(working copy)
@@ -1,63 +1 @@
-#include "node.h"
-#include "tokenstream.h"
-TransformNode* Tokens::match_shifttransform(){
-  KeywordToken *k=match_keyword("shift");
-  if(!k)k=match_keyword("shiftvertical");
-  if(!k)k=match_keyword("shifthorizontal");
-  if(!k) return NULL;
-  Range*range=match_range();
-  Node*node=match_basicnode();
-  if(!node)
-    show_error("After a shift keyword expecting a filter specification");
-  vector<Transform*>transforms;
-  transforms.push_back(new IdentityTransform());
-  if(k->eq("shift"))
-    for(auto t:ShiftTransform::allShift())
-      transforms.push_back(t);
-  else if (k->eq("shifthorizontal"))
-    for(auto t:ShiftTransform::shiftHorizontal())
-      transforms.push_back(t);
-  else if (k->eq("shiftvertical"))
-    for(auto t:ShiftTransform::shiftVertical())
-      transforms.push_back(t);
-  else uassert(false, "internal shift");
-  return TransformNode::create(transforms,node,range);
-}
-  
-    
-TransformNode* Tokens::match_fliptransform(){
-  KeywordToken *k=NULL;
-  if(!k) k=match_keyword("flip");
-  if(!k) k=match_keyword("flipvertical");
-  if(!k) k=match_keyword("fliphorizontal");
-  if(!k) k=match_keyword("flipcolor");
-  if(!k) k=match_keyword("rotate90");
-  if(!k) k=match_keyword("rotate45");
-  if(!k) k= match_keyword("flipdihedral");
-  if(!k) k=match_keyword("dihedral");
-  if(!k) return NULL;
-  Range*range=match_range();
-  Node*node=match_basicnode();
-  if(!node)
-    show_error("After a flip keyword, expecting a filter specification");
-  vector<Transform*> transforms;
-  transforms.push_back(new IdentityTransform());
-  if(k->eq("flip")||k->eq("flipdihedral")||k->eq("dihedral"))
-    for(auto t: DihedralTransform::allDihedral())
-      transforms.push_back(t);
-  else if (k->eq("rotate90"))
-    for(auto t:DihedralTransform::rotations())
-      transforms.push_back(t);
-  else if (k->eq("rotate45"))
-    for(auto t:PiOver4Transform::rotations())
-      transforms.push_back(t);
-  else if(k->eq("flipvertical"))
-    transforms.push_back(DihedralTransform::flipVertical());
-  else if(k->eq("fliphorizontal"))
-    transforms.push_back(DihedralTransform::flipHorizontal());
-  else if(k->eq("flipcolor"))
-    transforms.push_back(ColorTransform::flipColorTransform());
-  else
-    uassert(false,"internal fliptransform");
-  return TransformNode::create(transforms,node,range);
-}
+
Index: src/cql/transform.cpp
===================================================================
--- src/cql/transform.cpp	(revision 2842)
+++ src/cql/transform.cpp	(working copy)
@@ -1,60 +1 @@
-#include "node.h"
-#include <utility>
 
-Transform* Transform::transform(Transform*t){
-  uassert(t);
-  return new ComposeTransform(this,t);
-}
-
-Node* Transform::transform(Node*filter){
-  uassert(filter);
-  return filter->transform(this);
-}
-
-  
-DirectionParameter Transform::transform(DirectionParameter directionparameter){
-  vector<Direction>v;
-  for(auto d:directionparameter.directions)
-    v.push_back(transform(d));
-  return DirectionParameter(v,directionparameter.range);
-}
-
-
-pieceT Transform::transformPiece(pieceT piece){
-  uassert(piece_valid(piece));
-  pieceT ret=50;
-  if(flipsColor()) 
-    ret= PIECE_FLIP[piece]; //copied from egs/pieceLoc.cpp:385, cleaner ways exist
-  else
-    ret=piece;
-  uassert(piece_valid(ret));
-  return ret;
-}
-
-colorT Transform::transformColor(colorT color){
-  if(!flipsColor())return color;
-  if(color==WHITE)return BLACK;
-  if(color==BLACK) return WHITE;
-  if(color==NOCOLOR) return NOCOLOR;
-  uassert(false,"bad color transformcolor");
-  return NOCOLOR;
-}
-
-void Transform::print(){
-  printf("<%s>",thisclass());
-}
-
-Transform* Transform::compose(Transform * t){
-  uassert(t);
-  return new ComposeTransform(this,t);
-}
-
-vector<Transform*> Transform::nonidentity(const vector<Transform*>& transforms){
-  vector<Transform*> ret;
-  for(auto t:transforms)
-    if (!dynamic_cast<IdentityTransform*>(t))
-      ret.push_back(t);
-  return ret;
-}
-
-
Index: src/cql/transform.h
===================================================================
--- src/cql/transform.h	(revision 2842)
+++ src/cql/transform.h	(working copy)
@@ -1,100 +1 @@
-#pragma once
-#include "deleteable.h"
-class Transform {
- public:
-  virtual squareT transform(squareT s)=0;
-  static vector<Transform*>nonidentity(const vector<Transform*>&);
-  virtual void print();
-  virtual Direction transform(Direction)=0;
-  virtual SquareMask transform(SquareMask)=0;
-  virtual const char * thisclass()=0;
-  virtual Node* transform(Node* n);
-  virtual colorT transformColor(colorT color);
-  virtual pieceT transformPiece(pieceT piece);
-  DirectionParameter transform(DirectionParameter);
-  virtual bool flipsColor(){return false;}
-  Transform* transform(Transform*);
-  Transform* compose(Transform*);
-};
 
-class PiOver4Transform:public Transform{
- public:
-  const char* thisclass(){return "PiOver4Transform";}
-  int times{-1};
-  squareT transform(squareT);
-  Direction transform(Direction);
-  PiOver4Transform(int t);
-  Direction rotate45(Direction);
-  static vector<Transform*>rotations();
-  SquareMask transform(SquareMask m);
-  void print();
-};
-
-class DihedralTransform : public Transform{
- public:
-  const char* thisclass(){return "DihedralTransform";}
-  bool reflectx{false};
-  bool reflecty{false};
-  bool swap{false};
-  squareT transform(squareT);
-  Direction transform(Direction);
-  DihedralTransform(bool rx, bool ry, bool swap);
-  static DihedralTransform* flipVertical();
-  static DihedralTransform* flipHorizontal();
-  static vector<Transform*> rotations();
-  SquareMask transform(SquareMask m);
-  void print();
-  static vector<Transform*> allDihedral();
-  //  DihedralTransform* reflect(Direction);
-};
-
-class ShiftTransform : public Transform{
- public:
-  const char* thisclass(){return "ShiftTransform";}
-  int xoffset{0};
-  int yoffset{0};
-  squareT transform(squareT);
-  Direction transform(Direction d){return d;}
-  ShiftTransform(int xoff, int yoff);
-  virtual void print();
-  SquareMask transform(SquareMask);
-  static vector<Transform*>allShift();
-  static vector<Transform*>shiftHorizontal();
-  static vector<Transform*>shiftVertical();
-};
-
-class ColorTransform : public Transform{
- public:
-  squareT transform(squareT s){return s;}
-  Direction transform(Direction d) {return d;}
-  SquareMask transform(SquareMask m){return m;}
-  const char* thisclass(){return "ColorTransform";}
-  bool flipsColor(){return true;}
-  static Transform* flipColorTransform();
-};
-  
-class IdentityTransform : public Transform{
- public:
-  squareT transform(squareT s){return s;}
-  Direction transform(Direction d){return d;}
-  SquareMask transform(SquareMask m){return m;}
-  const char* thisclass(){return "IdentityTransform";}
-};
-
-class ComposeTransform: public Transform{
- public:
-  vector<Transform*> transforms;
-  squareT transform(squareT);
-  Direction transform(Direction);
-  void print();
-  ComposeTransform(vector<Transform*>);
-  ComposeTransform(Transform* t, Transform*s);
-  static vector<Transform*> composeVectors(vector<Transform*>, vector<Transform*>);
-  const char* thisclass(){return "ComposeTransform";}
-  SquareMask transform(SquareMask);
-  bool flipsColor();
-};
-
-
-
-  
Index: src/cql/transform_members.cpp
===================================================================
--- src/cql/transform_members.cpp	(revision 2842)
+++ src/cql/transform_members.cpp	(working copy)
@@ -1,54 +1 @@
-#include "node.h"
-void ResultNode::transform_members(Transform*t){
-  if(t->flipsColor()){
-    switch(result){
-    case RESULT_White: result=RESULT_Black; break;
-    case RESULT_Black: result=RESULT_White; break;
-    case RESULT_Draw: break;
-    default: uassert(false, "bad result");
-    }
-  }
-}
-    
 
-void PieceLoc::transform_members(Transform*t){
-  SquareMask newpieces;
-  for(int i=0;i<64;++i)if (pieces.member(i)){
-      pieceT p = (pieceT) i;
-      uassert (piece_valid(p));
-      pieceT newp=t->transformPiece(p);
-      newpieces.insert((int)newp);
-    }
-  pieces=newpieces;
-  squaremask=t->transform(squaremask);
-}
-
-void ColorNode::transform_members(Transform*t){
-  color=t->transformColor(color);
-}
-
-void PlayerNode::transform_members(Transform*t){
-  color=t->transformColor(color);
-}
-
-void EloNode::transform_members(Transform*t){
-  color=t->transformColor(color);
-}
-
-void RayNode::transform_members(Transform*t){
-  for(int i=0;i<directions.size();++i)
-    directions[i]=t->transform(directions[i]);
-}
-
-void VectorNode::transform_members(Transform*t){
-  parameter=t->transform(parameter);
-}
-
-void TransformNode::transform_in_place(Transform*t){
-  uassert(!expanded(),"transform_in_place on expanded node");
-  Node::transform_in_place(t);
-}
-
-
-      
-
Index: src/cql/transformnode.cpp
===================================================================
--- src/cql/transformnode.cpp	(revision 2842)
+++ src/cql/transformnode.cpp	(working copy)
@@ -1,165 +1 @@
-#include "node.h"
-// for TransformNode::transform_in_place(Transform*t) see the file transform_members.cpp
 
-TransformNode* TransformNode::create(vector<Transform*> ts,Node*n,Range*r){
-  uassert(n);
-  TransformNode* nbasenode=dynamic_cast<TransformNode*>(n);
-  Range*subrange=NULL;
-  if(nbasenode)subrange=nbasenode->range;
-  if(!r&&nbasenode&&!subrange){
-    uassert(!nbasenode->expanded());
-    vector<Transform*>basets=nbasenode->getTransforms();
-    vector<Transform*>composedts=
-      ComposeTransform::composeVectors(ts,basets);
-    Node* source=nbasenode->getSource();
-    return create(composedts,source,r);
-  }
-  MFilter* mf=dynamic_cast<MFilter*>(n);
-  uassert(mf, "tb::create: invalid node");
-  return new TransformNode(ts,mf,r);
-}
-
-bool TransformNode::isSet(){
-  if (range)return false;
-  if(expanded()){
-    uassert(filter==NULL,"TransformNode:isSet i1");
-    uassert(transformedFilters.size(),"TransformNode:isSet i2");
-    for (auto tf:transformedFilters) // We actually only need to check the 0'th element
-      if(!tf->isSet()) return false;
-    return true;
-  }
-  uassert(filter,"TransformNode::isSet i3");
-  return filter->isSet();
-}
-
-bool TransformNode::isCountable(){
-  return range!=NULL;
-}
-
-SquareMask TransformNode::getSquares(Game*game){
-  uassert(isSet(),"Attempt to use a transform node as a square set when its argument is not a set");
-    uassert(expanded(),"tsn not expanded");
-  SquareMask mask;
-  for(auto set : transformedFilters){
-    SetBase* converted=dynamic_cast<SetBase*>(set);
-    uassert(converted,"Internal error in transformnode.getSquares: a transformed filter is not a setbase");
-    uassert(converted->isSet(),"internal error in TransforNode::getSquares: converted transformed filter is not a set");
-    mask|=converted->getSquares(game);
-  }
-  return mask;
-}
-
-
-void TransformNode::expand(){
-  uassert(transformedFilters.empty()&&filter);
-  for(auto transform : transforms){
-    MFilter* transformednode=dynamic_cast<MFilter*>(filter->transform(transform));
-    uassert(transformednode,"null transform or wrong type in expand()");
-    if(!transformednode->hasEmptySquareMaskDescendant())
-      transformedFilters.push_back(transformednode);
-  }
-  for(auto transformedfilter : transformedFilters)
-    transformedfilter->expand();
-  filter=NULL;
-}
-
-
-vnode TransformNode::children(){
-  vnode v;
-  if(expanded())
-    v.insert(v.end(),transformedFilters.begin(),transformedFilters.end());
-  else
-    v.push_back(filter);
-  return v;
-}
-  
-TransformNode::TransformNode(vector<Transform*>ts,MFilter*f,Range*r){
-  uassert(f);
-  for(auto t:ts) uassert(t);
-  transforms=ts;
-  filter=f;
-  range=r;
-}
-
-void TransformNode::print(){
-  int ntransforms=transforms.size();
-  int nfilters=transformedFilters.size();
-  printf("<%s ntransforms: %d nfilters: %d",thisclass(),ntransforms,nfilters);
-  if(range) {
-    printf("range: ");
-    range->print();
-  }
-  for(int i=0;i<ntransforms;++i){
-    auto t=transforms[i];
-    printf("\n");indent();tab();
-    printf("Transform %d of %d: ",i,ntransforms);
-    t->print();
-    unindent();
-  }
-  if(filter){
-    uassert (!nfilters);
-    printf("\n");indent();tab();
-    printf("Filter: ");
-    filter->print();
-    unindent();
-  }
-  else{
-    uassert (nfilters);
-    for(int i=0;i<nfilters;++i){
-      auto tfilter=transformedFilters[i];
-      printf("\n");indent();tab();
-      printf("TransformedFilter %d of %d: ",i,nfilters);
-      tfilter->print();
-      unindent();
-    }
-  }
-  printf(" %s>",thisclass());
-}
-
-void TransformNode::deepify(){
-  uassert(!expanded(),"TransformNode: deepify: internal");
-  filter=filter->clone();
-}
-    
-bool TransformNode::expanded(){
-  uassert(!filter&&transformedFilters.size() ||
-	  filter&&transformedFilters.empty(),"TransformNode::expanded internal");
-  return filter==NULL;
-}
-
-TransformNode* TransformNode::clone(){
-  uassert(!expanded(),"cannot clone expanded transformnode");
-  TransformNode*ret=new TransformNode(*this);
-  ret->deepify();
-  cloneverify(this,ret);
-  return ret;
-}
-
-bool TransformNode::match_position(Game*game){
-  uassert(expanded(),"tn not expanded");
-  count=0;
-  for(auto f:transformedFilters){
-    if(f->match_position(game))++count;
-    if(count&& !range)return true;
-  }
-  if(!range)return false;
-  return range->valid(count);
-}
-
-bool TransformNode::match_count(Game*game,NumValue*value){
-  uassert(range,"Attempt to sort or count transform that lacks a range. Only transforms with ranges can be sorted or counted");
-  if(match_position(game)){
-    *value=(NumValue)count;
-    return true;
-  }
-  return false;
-}
-
-bool Node::hasEmptySquareMaskDescendant(){
-  vector<Node*>ds=descendants();
-  for(auto d:ds){
-    uassert(d);
-    if(d->hasEmptySquareMask()) return true;
-  }
-  return false;
-}
Index: src/cql/util.cpp
===================================================================
--- src/cql/util.cpp	(revision 2842)
+++ src/cql/util.cpp	(working copy)
@@ -1,145 +1 @@
-#include "util.h"
-#include <string.h>
-#include <ctype.h>
 
-static int indentlevel;
-
-void indent(){++indentlevel;};
-void tab(){
-  for(int i=0;i<indentlevel;++i) printf(" ");
-}
-
-void unindent(){
-  indentlevel--;
-  if(!indentlevel)indentlevel=0;
-}
-  
-
-bool util::signedIntValue(char*s,int*val){
-  if (s==NULL||s[0]==0) return false;
-  bool negate=false;
-  char*next=s;
-  if (next[0]=='-'){
-    next++;
-    negate=true;
-  }
-  if(!positiveIntValue(next,val))
-    return false;
-  if(negate) *val= -*val;
-  return true;
-}
-    
-  
-bool util::positiveIntValue(char * s,int*val){
-  if(!s||!*s)return false;
-  int sum=0;
-  char c;
-  while((c=*s++)!=0){
-    if (c>='0'&&c<='9'){
-      sum*=10;
-      sum+= c - '0';
-    }
-    else return false;
-  }
-  *val=sum;
-  return true;
-}
-
-
-string util::game_to_string(Game*game){
-  TextBuffer* tbuffer=new TextBuffer;
-  tbuffer->SetBufferSize(105000);
-  game->WriteToPGN_CQL(tbuffer);
-  char * buf=tbuffer->GetBuffer();
-  uassert(buf,"game_to_string internal");
-  string ret(buf); //Not absolutely certain is 0 terminated, hopefully it is
-  uassert(strlen(buf)==ret.size(),"game_to_string size");
-  tbuffer->Free();
-  return ret;
-}
-
-void util::printgame(FILE* stream,Game* game){
-  TextBuffer * tbuffer=new TextBuffer;
-  tbuffer->SetBufferSize(100000);
-  game->WriteToPGN_CQL(tbuffer);
-  tbuffer->DumpToFile(stream);
-  tbuffer->Free();
-}
-
-
-void util::my_dump_board(boardT board){
-  FILE * fp=stdout;
-  squareT s;
-  printf("Side To move is: %c\n",board[COLOR_SQUARE]);
-  for (int i=7; i>=0; i--) {
-    fputs ("   ", fp);
-    for (int j=0; j<8; j++) {
-      s = (i*8) + j;
-      char c=PIECE_CHAR[board[s]];
-      if (c=='.'){
-	if (i%2==j%2)
-	  putc('+',fp);
-	else
-	  putc('-',fp);
-      }
-      else 
-	putc (c, fp);
-      putc (' ', fp);
-    }
-    putc ('\n', fp);
-  }
-}
-
-int util::squareShiftDirection(int sq, directionT direction){
-  uassert(sq>=0&&sq<64&&direction<=DOWN_RIGHT);
-  int s=square_Move(sq,direction);
-  if (s>=64) s=-1;
-  return s;
-}
-
-bool util::directionCompatible(pieceT piece, directionT direction){
-  pieceT newp=piece_Type(piece);
-  if (newp==ROOK||newp==QUEEN) return directionOrthogonal(direction);
-  else if (newp==BISHOP||newp==QUEEN) return directionDiagonal(direction);
-  else return false;
-}
-bool util::directionOrthogonal(directionT direction){
-  return direction==UP||direction==DOWN||direction==LEFT||direction==RIGHT;
-}
-
-bool util::directionDiagonal(directionT direction){
-  return direction==UP_LEFT||direction==DOWN_LEFT||direction==UP_RIGHT||direction==DOWN_RIGHT;
-}
-
-void util::printgame(Game*g){
-  if(!g){printf("NULL GAME\n");}
-  my_dump_board(g->GetCurrentPos()->GetBoard());
-}
-    
-const char * util::string_append (const char* a, const char*b){
-  uassert(a&&b,"string_append args");
-  char buffer[500];
-  uassert(strlen(a)+strlen(b)<sizeof(buffer)-5,"too long string append");
-  sprintf(buffer,"%s%s",a,b);
-  return util::copy(buffer);
-}
-
-char * util::copy(const char * buffer){
-  int len=strlen(buffer);
-  if (len>100000){
-    fprintf(stderr,"Unfortunately, CQL cannot handle so many comments: game output of %d bytes\n",len);
-    fprintf(stderr,"Try modifying the .cql file to print fewer comments, for instance by using the 'silent' keyword.\n");
-    fprintf(stderr,"Typically these comments are automatically generated by next or previous.\n");
-    fprintf(stderr,"Try putting the keyword 'silent' in front of these keywords\n");
-    fprintf(stderr,"or see the documentation for 'silent' for more options\n\n");
-    fprintf(stderr,"Also consider the 'nestban' keyword if inside of a 'next' filter");
-    fprintf(stderr,"Unable to handle so many comments, exiting\n");
-    uassert(false);
-  }
-  char * nb=(char *) new char[len+1];
-  for (int i=0;i<len;++i){
-    nb[i]=buffer[i];
-    nb[len]=0;
-  }
-  return nb;
-}
Index: src/cql/util.h
===================================================================
--- src/cql/util.h	(revision 2842)
+++ src/cql/util.h	(working copy)
@@ -1,52 +1 @@
-#pragma once
-#include <stdio.h>
-#include <stdlib.h>
-#include <string>
-#include <ctype.h>
-#include <vector>
-#include <algorithm>
-#include "chesstypes.h"
-#include "gfile.h"
-#include "pgnparse.h"
-using std::vector;
-using std::string;
-#include "range.h"
-#include "squaremask.h"
-#include "direction.h"
-#include "myvector.h"
-#include "cqlassert.h"
-#include "cqlexit.h"
 
-
-#define CQL_ASSERT(x) {if(!(x)) { printf("Assert fails: %s: %d\n",__FILE__,__LINE__); uassert(false, "Internal CQL Error: assert fails"); }}
-
-void tab();
-void indent();
-void unindent();
-
-//Filename functions (in filename.cpp)
-
-bool filename_is_pgn(const char*filename);
-bool filename_is_cql(const char* filename);
-const char* filename_extension(const char* filename);
-const char* filename_stem(const char*name);
-const char* filename_trim_path_prefix(const char*name);
-const char* filename_trim_last(const char* name, char c);
-const char* filename_trim_extension(const char* name);
-
-class util{
- public:
-  static char * copy(const char * buffer);
-  static bool positiveIntValue(char * s, int*val);
-  static bool signedIntValue(char * s, int*val);
-  static void printgame(FILE* stream,Game* game);
-  static void my_dump_board(boardT board);
-  static int squareShiftDirection(int sq, directionT direction);
-  static bool directionCompatible(pieceT piecet, directionT direction);
-  static bool directionDiagonal(directionT direction);
-  static bool directionOrthogonal(directionT direction);
-  static void printgame(Game*game);
-  static string game_to_string(Game*game);
-  static const char* string_append(const char* a, const char* b);
-};
-
Index: src/cql/variable.cpp
===================================================================
--- src/cql/variable.cpp	(revision 2842)
+++ src/cql/variable.cpp	(working copy)
@@ -1,39 +1 @@
-#include "node.h"
-vector<Variable*>* Variable::theVariables;
 
-vector<Variable*>* Variable::getVariables(){
-  if(!theVariables)
-    theVariables=new vector<Variable*>;
-  return theVariables;
-}
-
-Variable* Variable::find(const char*nm){
-  for(Variable* v:*(getVariables()))
-    if (v->eq(nm))
-      return v;
-  return NULL;
-}
-
-void Variable::unbindTags(){
-  for(Variable* v : *(getVariables())){
-    TagVariable* tv=dynamic_cast<TagVariable*>(v);
-    if(tv&&tv->bound){
-      //     printf("variable: unbinding variable: ");
-      //      tv->print();
-      //      printf("\n");
-      tv->unbind();
-      uassert(!tv->isBound());
-    }
-  }
-}
-
-void Variable::unbind(){
-  uassert(bound,"attempt to unbind unbound variable: ",name);
-  bound=false;
-}
-
-bool Variable::eq(const char*n){
-  uassert(n,"bad arg to variable eq");
-  return strcmp(name,n)==0;
-}
-
Index: src/cql/variable.h
===================================================================
--- src/cql/variable.h	(revision 2842)
+++ src/cql/variable.h	(working copy)
@@ -1,87 +1 @@
-#pragma once
-class SquareVariable;
-class TagVariable;
-class NumericVariable;
-typedef int NumValue;
 
-class Variable{
- public:
-  const char*name{NULL};
-  bool eq(const char*name);
-  bool bound{false};
-  virtual bool isSquare()const {return false;}
-  virtual bool isTag()const {return false;}
-  virtual bool isNumeric() const{return false;}
-  bool isBound() const{return bound;}
-  bool isUnbound()const {return !isBound();}
-  virtual void print()=0;
-  virtual const char* thisclass()=0;;
-  static Variable* find(const char*name);
-  virtual bool getSquare(squareT*s)=0; // now that we have numerics this should be taken out
-  static vector<Variable*>* theVariables;
-  static vector<Variable*>*getVariables();
-  static SquareVariable* createSquareVariable(const char*n);
-  static TagVariable* createTagVariable(const char*n);
-  static NumericVariable* createNumericVariable(const char*n,bool ismax);
-  static SquareVariable* getSquareVariable(const char*n);
-  static TagVariable* getTagVariable(const char*n);
-  static NumericVariable* getNumericVariable(const char*n,bool ismax);
-  void unbind();
-  static void unbindTags();
-  static NumericVariable* matchCountVariable();
-  
-};
-
-class SquareVariable:public Variable{
- private:
-  squareT square{65};
-  bool used{false};
- 
- public:
-  bool isUsed()const {return used;}
-  bool isSquare() const {return true;}
-  void print();
-  const char*thisclass() {return "SquareVariable";}
-  SquareVariable(const char*nm);
-  bool getSquare(squareT*s);
-  void bindSquare(squareT s);
-};
-
-class TagVariable:public Variable{
- private: markT tag{-1};
- private: squareT origin{65};
- public:
-  bool isTag() const {return true;}
-  void print();
-  const char*thisclass(){return "TagVariable";}
-  TagVariable(const char* name);
-  bool getSquare(squareT*s);
-  squareT getOrigin();
-  void bindTag(int t);
-};
-  
-
-class NumericVariable:public Variable{
- private:
-  NumValue value{0};
-  NumValue extremalValue{0};
-  bool theIsMax{false};
- public:
-  void increment();
-  NumValue extremeValue()const;
-  bool getSquare(squareT*s); //for compilation, calls a stub
-  NumericVariable(const char* nm, bool ismax);
-  bool isNumeric()const {return true;}
-  bool isMax()const {return theIsMax;}
-  bool isMin()const {return !isMax();}
-  void print();
-  const char* thisclass(){return "NumericVariable";}
-  NumValue getValue()const;
-  virtual NumValue getExtremalValue();
-  void clear();
-  void bindNumeric(NumValue v);
-  static void resetAll();
-  void reset();
-};
-
-bool operator< (const NumericVariable& lhs, const NumericVariable& rhs);
Index: src/cql/variationflags.h
===================================================================
--- src/cql/variationflags.h	(revision 2842)
+++ src/cql/variationflags.h	(working copy)
@@ -1,12 +1 @@
-#pragma once
-class VariationFlags{
- public:
-  bool theisset{false};
-  bool thesearchvariations{false};
-  bool getSearchVariations();
-  bool isVariationsSet(){return theisset;}
-  void setSearchVariations(bool arg);
-  void printVariationFlags();
-  virtual void setVariations(bool arg);
-};
 
Index: src/cql/variations.cpp
===================================================================
--- src/cql/variations.cpp	(revision 2842)
+++ src/cql/variations.cpp	(working copy)
@@ -1,53 +1 @@
-#include "node.h"
-bool VariationFlags::getSearchVariations(){
-  uassert(theisset,"variations flags are not yet set on this node");
-  return thesearchvariations;
-}
 
-void VariationFlags::setSearchVariations(bool arg){
-  uassert(!theisset,"attempt to set variations on flag that was already set");
-  thesearchvariations=arg;
-  theisset=true;
-}
-
-void VariationFlags::printVariationFlags(){
-  if(theisset&&thesearchvariations)printf(" variations ");
-}
-
-void Node::setVariations(bool arg){
-  if(0)  printf("Node::setvariations called with arg: %d on \n",arg);
-  if(0) print();
-  if(0) printf("\n");
-  vector<Node*>c=children();
-  for(Node* n:c){
-    if(!n){
-      printf("Internal error in node: %s\n",thisclass());
-      printf("Got a null child among nchildren of: %lu\n",c.size());
-      printf("bad node is: ");
-      this->print();
-      uassert(false,"unexpected null child in setVariations");
-    }
-    VariationFlags*vf=dynamic_cast<VariationFlags*>(n);
-    if(vf){
-      uassert(!vf->isVariationsSet(),"unexpected set variation"); //change later when add features
-      vf->setSearchVariations(arg);
-    }
-    n->setVariations(arg);
-  }
-}
-
-void VariationFlags::setVariations(bool arg){
-  Node*n=dynamic_cast<Node*>(this);
-  if(0)printf("VariationsFlags::setVariations called with arg: %d on:\n",arg);
-  n->print();
-  setSearchVariations(arg);
-  if(0)printf("after calling, myisset is: %d\n",theisset);
-  uassert(n,"internal casting issue setVariations");
-  n->Node::setVariations(arg);
-}
-
-void CqlNode::setChildVariations(){
-  uassert(isVariationsSet(),"internal cqlnode variations");
-  bool varflag=getSearchVariations();
-  Node::setVariations(varflag);
-}
Index: src/cql/vectorconstituent.cpp
===================================================================
--- src/cql/vectorconstituent.cpp	(revision 2842)
+++ src/cql/vectorconstituent.cpp	(working copy)
@@ -1,40 +1 @@
-#include "node.h"
 
-VectorConstituent::VectorConstituent(vector<SeqConstituent*>&cs){
-  uassert(!cs.empty(),"invalid null size vector constituent");
-  constituents=cs;
-  for(auto c:constituents)
-    uassert(c,"vcvc");
-}
-
-vnode VectorConstituent::children(){
-  vnode v{constituents.begin(),constituents.end()};
-  return v;
-}
-
-void VectorConstituent::setOffsets(int i){
-  setOffset(i);
-  for(auto c:constituents)
-    c->setOffsets(i);
-}
-
-
-void VectorConstituent::print(){
-  printf("\n");tab();
-  printf("<%s %lu constituents: ",thisclass(),constituents.size());
-  indent();
-  for(int i=0;i<constituents.size();++i){
-    printf("\n");
-    tab();
-    printf("%s %d of %lu: ",thisclass(),i,constituents.size());
-    constituents[i]->print();
-  }
-  unindent();
-  printf(">");
-}
-
-bool VectorConstituent::matchesNull(){
-  for(auto c:constituents)
-    if(!c->matchesNull())return false;
-  return true;
-}
Index: src/cql/vectornode.cpp
===================================================================
--- src/cql/vectornode.cpp	(revision 2842)
+++ src/cql/vectornode.cpp	(working copy)
@@ -1,50 +1 @@
-#include "node.h"
 
-VectorNode::VectorNode(DirectionParameter dp, SetBase*s):parameter{dp}{
-  uassert(s);
-  source=s;
-}
-
-vnode VectorNode::children(){
-  vnode v{source};
-  return v;
-}
-
-void VectorNode::print(){
-  printf("<%s Parameter: ",thisclass());
-  parameter.print();
-  indent();
-  printf("\n");tab();
-  printf("source: ");
-  source->print();
-  printf("\n");tab();
-  printf(" %s>",thisclass());
-  unindent();
-}
-
-bool VectorNode::match_position(Game*game){
-  return getSquares(game).nonempty();
-}
-
-SquareMask VectorNode::getSquares(Game*game){
-  if(!neighborhoodsvalid){
-    makeNeighborhoods();
-    uassert(neighborhoodsvalid);}
-  SquareMask ret;
-  SquareMask sourcemask=source->getSquares(game);
-  for (int sq=0;sq<64;++sq)
-    if(sourcemask.member(sq))
-      ret|=neighborhoods[sq];
-  return ret;
-}
-  
-
-void VectorNode::makeNeighborhoods(){
-  uassert(!neighborhoodsvalid,"vector internal");
-  for (int sq=0;sq<64;++sq){
-    SquareMask mask=parameter.neighborhood(sq);
-    neighborhoods[sq]=mask;
-  }
-  neighborhoodsvalid=true;
-}
-    
Index: src/cql/version.cpp
===================================================================
--- src/cql/version.cpp	(revision 2842)
+++ src/cql/version.cpp	(working copy)
@@ -1,2 +1 @@
-const char* CqlBuild="8.80";
-const char* CqlVersion="5.2";
+
Index: src/cql/yearnode.cpp
===================================================================
--- src/cql/yearnode.cpp	(revision 2842)
+++ src/cql/yearnode.cpp	(working copy)
@@ -1,27 +1 @@
-#include "node.h"
-YearNode::YearNode(Range* r):range{r}{
-  uassert(r&&range,"yearnode internal");
-}
 
-bool YearNode::match_game(Game*game){
-  NumValue n= -1;
-  return match_count(game,&n);
-}
-
-bool YearNode::match_count(Game*game, NumValue*value){
-  int year=(int)(date_GetYear(game->GetDate()));
-  if (range->valid(year)){
-    *value=(NumValue)year;
-    return true;
-  }
-  return false;
-}
-  
-  
-void YearNode::print(){
-  printf("<%s ",thisclass());
-  range->print();
-  printf(">");
-}
-
-  
Index: src/game.h
===================================================================
--- src/game.h	(revision 2842)
+++ src/game.h	(working copy)
@@ -298,10 +298,6 @@
 
 
 public:
-    errorT WritePGN_CQL(TextBuffer * tb, uint stoplocation);
-    errorT WriteToPGN_CQL(TextBuffer * tb);
-    void handleinitialcomment_CQL(TextBuffer * tb);
-
     Game()      { Init(); }
 
     ~Game();
@@ -350,10 +346,6 @@
         return &(m->moveData);
     }
 
-    moveT * GetCurrentMoveCQL () {
-        return CurrentMove;
-    }
-
     inline void InitMove (moveT * m);
 
     void     SaveState ();
Index: src/mfile.h
===================================================================
--- src/mfile.h	(revision 2842)
+++ src/mfile.h	(working copy)
@@ -124,7 +124,6 @@
     uint          ReadFourBytes ();
 
     inline const char * GetFileName ();
-    void skipNonAscii(); // CQL
 };
 
 
Index: src/tkscid.cpp
===================================================================
--- src/tkscid.cpp	(revision 2842)
+++ src/tkscid.cpp	(working copy)
@@ -15006,9 +15006,9 @@
 sc_search (ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
 {
     static const char * options [] = {
-        "board", "moves", "cql", "header", "material", NULL
+        "board", "moves", "header", "material", NULL
     };
-    enum { OPT_BOARD, OPT_MOVES, OPT_CQL, OPT_HEADER, OPT_MATERIAL };
+    enum { OPT_BOARD, OPT_MOVES, OPT_HEADER, OPT_MATERIAL };
 
     int index = -1;
     if (argc > 1) { index = strUniqueMatch (argv[1], options); }
@@ -15027,10 +15027,6 @@
 	ret = sc_search_moves (cd, ti, argc, argv);
 	break;
 
-    case OPT_CQL:
-	ret = sc_search_cql (cd, ti, argc, argv);
-	break;
-
     case OPT_HEADER:
 	ret = sc_search_header (cd, ti, argc, argv);
 	break;
@@ -15458,233 +15454,6 @@
     return TCL_OK;
 }
 
-// Search on CQL syntax.
-// Lionel Hampton --  October 2017
-
-int
-sc_search_cql (ClientData cd, Tcl_Interp * ti, int argc, const char ** argv)
-{
-    uint gameNum;
-    const char * usageStr =
-      "Usage: sc_search cql <filterOp> <stripSwitch> <silentSwitch> <syntax>";
-    bool showProgress = startProgressBar();
-
-    if (argc != 6)
-      return errorResult (ti, usageStr);
-
-    if (!db->inUse)
-      return errorResult (ti, errMsgNotOpen(ti));
-
-    filterOpT filterOp = strGetFilterOp (argv[2]);
-
-    bool stripSwitch = (argv[3][0] == '1');
-
-    // This corresponds to the 'Allow Comments' user option.
-    bool silentSwitch = (argv[4][0] != '1');
-
-    // If the base is readonly, just run the query in silent mode.
-    if (db->fileMode==FMODE_ReadOnly) silentSwitch = true;
-    // This will let the engine run slightly more efficiently.
-    // The larger effect of silentSwitch is that we will simply not replace the game.
-    extern bool CqlSilent;
-    CqlSilent = silentSwitch;
-
-    // argv[5] is CQL syntax
-    // printf("CQL Syntax:\n%s\n", argv[5]);
-
-    // All cql based asserts leave an error msg in the cqlErrMsg global.
-    // However, the assert is not the only path to longjmp(), and the
-    // error msg is not always set. Hence, we null out the pointer before
-    // nesting our way down the call stack.
-    extern char *cqlErrMsg;
-    cqlErrMsg = NULL;
-
-    // Set to true to show some useful info on <stdout>.
-    extern bool CqlShowLex, CqlShowParse, CqlDebug;
-    CqlShowLex = false;
-    CqlShowParse = false;
-    CqlDebug = false;
-
-    // We believe it is safe to employ longjmp(), since all CQL destructors are trivial.
-    // Nonetheless, TODO: maybe should use C++ exception handling here...
-    extern std::jmp_buf jump_buffer;
-    void CqlReset();
-    if (setjmp(jump_buffer) != 0 ) {
-      CqlReset();
-      if (cqlErrMsg) Tcl_AppendResult (ti, cqlErrMsg, NULL);
-      else Tcl_AppendResult (ti, "Error reported back from CQL engine", NULL);
-      return TCL_OK;
-    }
-
-    // Parse the CQL script.
-    bool CqlParseBuffer(char*);
-    CqlParseBuffer((char *)argv[5]);
-
-    Timer timer;  // Start timing this search.
-
-    uint skipcount = 0;
-    uint updateStart, update;
-    // this is a tradeoff... some queries are EXTREMELY compute-intensive
-    updateStart = update = 1000;  // Update progress bar every 1000 games
-
-    // If filter operation is to reset the filter, reset it:
-    if (filterOp == FILTEROP_RESET) {
-        filter_reset (db, 1);
-        filterOp = FILTEROP_AND;
-    }
-    uint startFilterCount = startFilterSize (db, filterOp);
-
-    // Here is the loop that searches on each game:
-    IndexEntry * ie;
-    Game * g = scratchGame;  // TODO: how is this NOT a memory leak?
-    bool dirtyFlag = false;  // has a game been replaced?
-    bool jumpFlag = false;   // have we caught a longjump()?
-
-    for (gameNum=0; gameNum < db->numGames; gameNum++) {
-        // If we're just finishing out after a longjump(), remove all remaining
-        // games from the filter.
-        if (jumpFlag) {
-          db->dbFilter->Set (gameNum, 0); // remove the game from the filter
-          continue;
-        }
-
-        // Update the percentage done bar:
-        if (showProgress) {
-            update--;
-            if (update == 0) {
-                update = updateStart;
-                updateProgressBar (ti, gameNum, db->numGames);
-                if (interruptedProgress()) { break; }
-            }
-        }
-
-        // First, apply the filter operation:
-        if (filterOp == FILTEROP_AND) {  // Skip any games not in the filter:
-            if (db->dbFilter->Get(gameNum) == 0) {
-                skipcount++;
-                continue;
-            }
-        } else /* filterOp==FILTEROP_OR*/ { // Skip any games in the filter:
-            if (db->dbFilter->Get(gameNum) != 0) {
-                skipcount++;
-                continue;
-            } else {
-                // OK, this game is NOT in the filter.
-                // Add it so filterCounts are kept up to date:
-                db->dbFilter->Set (gameNum, 1);
-            }
-        }
-
-        // Skip games with no gamefile record:
-        // TODO: What does this mean???
-        // Thought it would be non-standard openings with no moves (just
-        // a FEN tag), but no...
-        ie = db->idx->FetchEntry (gameNum);
-        if (ie->GetLength() == 0) {
-            db->dbFilter->Set (gameNum, 0);
-            skipcount++;
-            continue;
-        }
-
-        // Load the game.
-        if (db->gfile->ReadGame (db->bbuf, ie->GetOffset(), ie->GetLength()) != OK) {
-            return errorResult (ti, "Error reading game file.");
-        }
-
-        g->Decode (db->bbuf, GAME_DECODE_ALL); // variations, comments and non-standards
-        g->LoadStandardTags (ie, db->nb); // for metadata matches
-        g->SetNumber (gameNum + 1); // for game range tests
-        g->SetAltered(false);  // the CQL engine will set this flag when adding comments
-
-        char *comment, *match;
-        int countMatch;
-
-        // Strip existing MATCH markers left by a previous query.
-        // Save the cpu cycles if we're running silent.
-        if (stripSwitch && !silentSwitch) {
-          countMatch = 0;
-          g->MoveToPly(0);
-          do {
-            if ((comment = g->GetMoveComment())) {
-              if ((match = strstr(comment, "MATCH"))) {
-                if (match == comment) g->SetMoveComment(NULL);
-                else match[0] = 0;  // truncate the mark and all that follows
-                countMatch++;
-              }
-            }
-          } while (g->MoveForward() == OK);
-          if (countMatch) g->SetAltered(true);
-        }
-
-        if (setjmp(jump_buffer) != 0 ) {
-          printf("CQL longjump() while matching gamenumber %d\n", gameNum+1);
-          //db->gameNumber = gameNum;
-          jumpFlag = true;
-          db->dbFilter->Set (gameNum, g->GetCurrentPly() + 1);
-          continue;
-        }
-
-        // See if the game matches.
-        bool CqlMatchGame(Game *);  // this is our surrogate in the cql code... see comment
-        extern uint CqlMatchPlyFirst; // set by the cql engine
-        if ( CqlMatchGame(g) ) {
-          if (CqlMatchPlyFirst > 254) { CqlMatchPlyFirst = 254; } // is 254 enough cushion?
-          db->dbFilter->Set (gameNum, CqlMatchPlyFirst + 1);
-        } else {
-          db->dbFilter->Set (gameNum, 0); // remove the game from the filter
-        }
-
-        // Do not replace the game if we are in silent mode,
-        // regardless of whether or not the game has been altered.
-        if (g->GetAltered() && !silentSwitch) {
-          if (sc_savegame (ti, g, gameNum+1, db) != OK) { return TCL_ERROR; }
-          dirtyFlag = true;
-        }
-    }
-
-    // Reset the engine.
-    CqlReset();
-
-    // If necessary, update index and name files:
-    if (dirtyFlag) {
-        db->gfile->FlushAll();
-        if (db->idx->WriteHeader() != OK) {
-            return errorResult (ti, "Error writing index file.");
-        }
-        // Not sure this is absolutely necessary, only that counts are
-        // bumped up and down when game is replaced.  But why should that
-        // matter... it's a wash.
-        if (! db->memoryOnly  &&  db->nb->WriteNameFile() != OK) {
-            return errorResult (ti, "Error writing name file.");
-        }
-    }
-
-    if (showProgress) { updateProgressBar (ti, 1, 1); }
-
-    // Now print statistics and time for the search:
-    // If the jump flag is set, we're falling out with an exception.
-    if (jumpFlag) {
-      if (cqlErrMsg) Tcl_AppendResult (ti, cqlErrMsg, NULL);
-      else Tcl_AppendResult (ti, "Error reported back from CQL engine", NULL);
-    } else {
-      char temp[200];
-      int centisecs = timer.CentiSecs();
-      if (gameNum != db->numGames) {
-          Tcl_AppendResult (ti, errMsgSearchInterrupted(ti), "  ", NULL);
-      }
-      sprintf (temp, "%d / %d  (%d%c%02d s)",
-             db->dbFilter->Count(), startFilterCount,
-             centisecs / 100, decimalPointChar, centisecs % 100);
-      Tcl_AppendResult (ti, temp, NULL);
-#ifdef SHOW_SKIPPED_STATS
-      sprintf(temp, "  Skipped %u games.", skipcount);
-      Tcl_AppendResult (ti, temp, NULL);
-#endif
-    }
-
-    return TCL_OK;
-}
-
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // addPattern():
 //    Called by the parameter parsing section of sc_search_material()
Index: tcl/file.tcl
===================================================================
--- tcl/file.tcl	(revision 2842)
+++ tcl/file.tcl	(working copy)
@@ -296,7 +296,6 @@
   updateTitle
   updateStatusBar
   refreshCustomFlags
-  checkCQLSearch
 }
 
 ### Update a few widgets with the Custom Flags
Index: tcl/help/help.tcl
===================================================================
--- tcl/help/help.tcl	(revision 2842)
+++ tcl/help/help.tcl	(working copy)
@@ -272,7 +272,6 @@
   <li><a Import CCRL>Computer Chess (CCRL) game imports</a></li>
   <li><a Author>Contact information</a></li>
   <li><a Contents>Contents</a></li>
-  <li><a CQL>CQL</a> Chess Query Language</li>
   <li><a Crosstable>Crosstable</a></li>
   </ul>
 
@@ -1036,7 +1035,6 @@
   <li><a Searches Board>Game Positions</a> - matching the Current Board</li>
   <li><a Searches Material>Material and Piece Pattern</a> searches.</li>
   <li><a Searches Move>Move Sequence</a> searches.</li>
-  <li><a CQL>Chess Query Language</a> searches.</li>
   </p>
   <p>
   Searches display their results by adjusting the <a Filter>Filter</a> with matching games.
@@ -1195,62 +1193,6 @@
   <p><footer>Updated: Scid vs. PC 4.15 June 2015</footer></p>
 }
 
-set helpTitle(CQL) "CQL"
-set helpText(CQL) {<h1>Chess Query Language</h1>
-  <p>
-  CQL is a powerful query language which allows for a huge variety of searches.
-  It differs from normal Scid searches in that it can also add detailed comments to matching games.
-  </p><p><i>
-  Because of CQL's cryptic nature, adding comments is restricted to the clipbase,
-  and must be enabled with <b>Allow Comments</b>.
-  </i></p><p>
-  When comments are enabled in the clipbase, all matching positions will be annotated with <b>MATCH</b>.
-  These comments can be removed in subsequent searches by enabling <b>Strip Match Comments</b>.
-  Additionally, some CQL filters and keywords (esp. <b>silent</b>), will over-ride these buttons.
-  Other CQL commands also allow for other comments to be added and for processing of variations.
-  These additional comments will *not* be removed with the Strip button, and neither does stripping 
-  remove any comments from variations.
-  </p>
-  <p>
-  It's worth noting that for many simple CQL searches,
-  the equivalent native Scid search (header, material, pattern, etc) will be much faster.
-  CQL is not optimized for trivial queries - though it is more powerful of course -
-  and as a result complex searches can be very slow.
-  </p>
-  <p>
-  Thanks go to Lewis Stiller and Gady Costeff for their innovative work on CQL.
-<br>
-  Fairly technical documentation for their language can be found at
-  <url http://www.gadycosteff.com/cql>their CQL site</url>
-  </p>
-
-  <h3>Examples</h3>
-  <ul>
-  <li>cql() shifthorizontal shiftvertical flipcolor {ra8 rc8 Pb7} ; Find all pawn forks both rooks.</li>
-  <li>cql() flipcolor shifthorizontal countsquares 3 P[b2-7] ; Tripled pawns
-  <li>cql() flipcolor flip { next2 5 100 ((move from Q to up 1 Q move from Q to right 1 Q)+ {move from Q to up 1 Q}? ) } ; Queen 'Staircase'
-  </ul>
-  </p>
-
-  <h3>Technical</h3>
-  <p>
-  This feature is not mature; it leaks memory, is not terribly re-entrant (some errors will make
-  future searches broken until ScidvsPC is restarted), and can choke on games with <a Variations Null>null move</a>.
-  </p>
-  <p>
-  Some error messages will be shown in the status bar, others 
-  in more detail on the command line (Linux and OS X only). For developers, more 
-  information can be had by setting the variables CqlShowLex, CqlShowParse, and CqlDebug in tkscid.cpp.
-  </p>
-  <p>
-  A few CQL keywords which are non-sensical in an Scid context, have null effect.
-  The CQL header params <b>input</b> and <b>output</b> are obvious candidates, likewise
-  the CQL header will now generally be empty  <b>cql()</b> , unlike the standalone CQL executable.
-  The <b>sort filter</b> has been disabled for the time being, though may be implemented later.
-  </p>
-
-  <p><footer>Updated: Scid vs. PC 4.19 Dec 2017</footer></p>
-}
 set helpTitle(Filter) "The Filter"
 set helpText(Filter) {<h1>The Filter</h1>
   <p>
Index: tcl/menus.tcl
===================================================================
--- tcl/menus.tcl	(revision 2842)
+++ tcl/menus.tcl	(working copy)
@@ -365,9 +365,6 @@
 $m add command -label SearchMoves -command ::search::moves
 set helpMessage($m,[incr menuindex]) SearchMoves
 
-$m add command -label CQL -command ::search::cql
-set helpMessage($m,[incr menuindex]) CQL
-
 $m  add separator
 incr menuindex
 
Index: tcl/search/board.tcl
===================================================================
--- tcl/search/board.tcl	(revision 2842)
+++ tcl/search/board.tcl	(working copy)
@@ -281,228 +281,3 @@
   wm state $w normal
   focus $w.g.moves
 }
-
-set ::search::cqlStripSwitch 0
-set ::search::cqlCommentSwitch 0
-
-proc ::search::cql {} {
-  global glstart
-
-  set w .scql
-  if {[winfo exists $w]} {
-    wm deiconify $w
-    raiseWin $w
-    return
-  }
-
-  toplevel $w
-  wm withdraw $w
-  wm title $w "CQL $::tr(Search)"
-  setWinLocation $w
-  setWinSize $w
-
-  bind $w <Escape> "$w.b.cancel invoke"
-  #bind $w <Return> "$w.b.search invoke"
-  bind $w <F1> { helpWindow CQL }
-
-  label $w.type -textvar ::tr(CQLLabel) -font font_Bold
-  pack  $w.type -side top
-
-  frame $w.s
-  label $w.s.strip -font font_Bold -textvar ::tr(CQLStrip)
-  radiobutton $w.s.stripyes -text Yes -variable ::search::cqlStripSwitch -value 1
-  radiobutton $w.s.stripno  -text No  -variable ::search::cqlStripSwitch -value 0
-
-  label $w.s.comment -font font_Bold -textvar ::tr(CQLComments)
-  radiobutton $w.s.commentyes -text Yes -variable ::search::cqlCommentSwitch -value 1 -command checkCQLSearch
-  radiobutton $w.s.commentno  -text No  -variable ::search::cqlCommentSwitch -value 0 -command checkCQLSearch
-  pack $w.s.comment $w.s.commentyes $w.s.commentno [label $w.s.space -width 5] \
-       $w.s.strip   $w.s.stripyes   $w.s.stripno   -side left -pady 1
-
-  canvas $w.progress -height 20 -width 300  -relief solid -border 1
-  $w.progress create rectangle 0 0 0 0 -fill $::progcolor -outline $::progcolor -tags bar
-  $w.progress create text 295 10 -anchor e -font font_Regular -tags time \
-      -fill black -text "0:00 / 0:00"
-
-  frame $w.b
-  dialogbutton $w.b.stop -textvar ::tr(Stop) -command sc_progressBar -state disabled
-
-  dialogbutton $w.b.search -textvar ::tr(Search) -command {
-    set confirm [::game::ConfirmDiscard]
-    if {$confirm == 2} { return }
-    if {$confirm == 0} {
-      ::game::Save
-    }
-
-    set w .scql
-
-    $w.status     configure -text {}
-
-    busyCursor .
-    $w.b.stop configure -state normal
-    grab $w.b.stop
-    sc_progressBar $w.progress bar 301 21 time
-
-    set cqlSyntax [$w.g.syntax get 0.0 end]
-
-    # Only allow CQL commenting for the clipbase
-    set allowComments [expr  {([sc_base current] == [sc_info clipbase]) && $::search::cqlCommentSwitch}]
-
-    set err [catch {
-      set str [sc_search cql $::search::filter::operation $::search::cqlStripSwitch $allowComments $cqlSyntax]
-    } result]
-
-    unbusyCursor .
-    grab release $w.b.stop
-    $w.b.stop configure -state disabled
-
-    if {$err} {
-      tk_messageBox -title Scid -type ok -icon warning \
-        -message "Fatal error returned from CQL query:\n$result"
-      return
-    }
-
-    if {[sc_filter count] > 0} {
-      ::search::loadFirstGame
-    } else {
-      # current game could be altered
-      if {$::search::cqlStripSwitch && $::search::cqlCommentSwitch} {
-        ::game::Reload
-      }
-    }
-    ::windows::stats::Refresh
-
-    set index [string first "|" $str]
-    if { $index > 5 } {
-      set str "[string range $str 0 $index-1] -- [string range $str $index+1 end]"
-    }
-
-    $w.status configure -text $str
-  }
-
-  dialogbutton $w.b.cancel -textvar ::tr(Close) -command "focus .main ; destroy $w"
-
-  packbuttons right $w.b.cancel $w.b.stop $w.b.search
-
-  dialogbutton $w.b.save -textvar ::tr(Save) -command ::search::cqlSave
-  dialogbutton $w.b.load -textvar ::tr(LoadGame) -command ::search::cqlLoad
-
-  packbuttons left  $w.b.save $w.b.load
-
-  label $w.status -text "" -font font_Small -relief sunken -anchor w
-
-  pack $w.status     -side bottom -fill x
-  pack $w.b          -side bottom -fill x
-
-  pack $w.progress   -side bottom -pady 2
-  pack [frame $w.line4 -height 2 -borderwidth 2 -relief sunken] -fill x -pady 5 -side bottom
-
-  ::search::addFilterOpFrame $w 0 bottom
-  pack [frame $w.line5 -height 2 -borderwidth 2 -relief sunken] -fill x -pady 5 -side bottom
-
-  pack $w.s          -side bottom
-  pack [frame $w.line6 -height 2 -borderwidth 2 -relief sunken] -fill x -pady 5 -side bottom
-
-  ### pack text widget last to allow for nice resizing
-
-  frame $w.g
-  pack $w.g -side top -expand 1 -fill both -padx 2 -pady 1
-
-  text $w.g.syntax -height 12 -width 64 -wrap word -yscrollcommand "$w.g.ybar set" -undo 1
-  scrollbar $w.g.ybar -command "$w.g.syntax yview" -takefocus 0
-
-  pack $w.g.ybar -side right -fill y
-  pack $w.g.syntax -side left -fill both -expand 1
-
-  bind $w.g.syntax <Control-a> {.scql.g.syntax tag add sel 0.0 end-1c ; break}
-  bind $w.g.syntax <Control-z> {catch {.scql.g.syntax edit undo} ; break}; # Control-z is default text binding anyway
-  bind $w.g.syntax <Control-y> {catch {.scql.g.syntax edit redo} ; break}; # but the others are not
-  bind $w.g.syntax <Control-r> {catch {.scql.g.syntax edit redo} ; break}
-
-
-  ::search::Config
-
-  checkCQLSearch
-
-  bind $w <Configure> "recordWinSize $w"
-  wm state $w normal
-  focus $w.g.syntax
-}
-
-proc ::search::cqlSave {} {
-  set w .scql
-
-  set ftype {
-    { "CQL file" {".cql"} }
-  }
-  set fName [tk_getSaveFile -initialdir $::initialDir(sso) -filetypes $ftype \
-             -parent $w -title {Save a CQL Query}]
-  if {$fName == ""} { return }
-  set ::initialDir(sso) [file dirname $fName]
-
-  if {[string compare [file extension $fName] ".cql"] != 0} {
-    append fName ".cql"
-  }
-
-  if {[catch {set searchF [open $fName w]}]} {
-    tk_messageBox -title Error -type ok -icon error -message "Unable to create CQL file: $fName"
-    return
-  }
-  puts $searchF [$w.g.syntax get 0.0 end]
-  close $searchF
-}
-
-proc ::search::cqlLoad {} {
-  set w .scql
-
-  set ftype {
-    {{CQL files}  {.cql} }
-    {{Text files} {.txt} }
-    {{All files}       * }
-  }
-  if {! [file isdirectory $::initialDir(sso)] } {
-    set ::initialDir(sso) $::env(HOME)
-  }
-  set fName [tk_getOpenFile -initialdir $::initialDir(sso) -filetypes $ftype -title "Select a CQL query file"]
-
-  if {$fName != ""} {
-    if {![catch {open $fName r} fd]} {
-      $w.g.syntax delete 0.0 end
-      while {[gets $fd line] >= 0 && ![eof $fd]} {
-	$w.g.syntax insert end "$line\n"
-      }
-      close $fd
-      set ::initialDir(sso) [file dirname $fName]
-    } else {
-      tk_messageBox -title Error -type ok -icon error -message "Unable to open CQL file $fName for reading."
-    }
-  }
-
-
-}
-
-proc checkCQLSearch {} {
-  set w .scql.s
-
-  if {![winfo exists $w]} {return}
-
-  if {[sc_base current] != [sc_info clipbase]} {
-    foreach i {comment commentyes commentno strip stripyes stripno} {
-      $w.$i configure -state disabled
-    }
-  } else {
-    foreach i {comment commentyes commentno} {
-      $w.$i configure -state normal
-    }
-
-    if {$::search::cqlCommentSwitch} {
-      set s normal
-    } else {
-      set s disabled
-    }
-    foreach i {strip stripyes stripno} {
-      $w.$i configure -state $s
-    }
-
-  }
-}
