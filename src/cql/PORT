#!/usr/bin/fmt

The port of the CQL source code to the Scidvspc chess database application as a fully integrated search engine was undertaken by Lionel Hampton.  This file outlines the porting process, issues encountered along the way, and guidelines for subsequent porting efforts of future releases of the CQL source base.


The original standalone CQL executable utilized a subset of a very dated revision of the Scid source tree, primarily for parsing PGN files.  Because that parser naturally filled in Scid-native data structure as the games were parsed, the CQL engine also happily utilizes those same Scid-native data structures.  That convenience, alone, renders the port nearly trivial.

The first task in the port involved transitioning the CQL source base away from that ancient Scid code base to the more current v4.18 revision of the Scidvspc source repository, in order to build a functional standalone cql executable off the same source as would eventually be utilized by the ported integrated CQL engine.  That primarily involved minor tweaks/additions to some Scid header files and the addition of a couple of accessor attributes for data elements which had been moved from private to public space by C&S.  It also required the creation and initialization of an integrated  Tcl interpreter due to the fact that the current PGN parser now pulls in the CHARSETCONV objects which in turn require a number of references out of the Tcl library.

The standalone cql executable resulting from the clean build was then tested and verified by comparing the query results from that exec -- against a 100K game PGN DB -- with the respective results produced by the original cql executable, utilizing the many CQL examples authored by Costeff & Stiller (found in the examples sub-directory).

Having a fully functional base built aganst the native headers and objects, the next step was to integrate the CQL engine into the Scid executable.  Since the CQL base already interfaced with the Scid Game:: and Position:: infrastructure, very little bridging work was required.  Rather than searching against the game stream generated by the parser, the search is conducted against the active scid database game list filter.

Following are the non-trivial aspects the integration effort:

-- Convert the CQL lexical analyzer to work off an internal buffer rather that a file.  That work can be found in lexer.cpp.

-- Create a new search menu item and search window for feeding the CQL engine the necessary CQL syntax.  The search window rendered and managed by proc ::search::cql{} is modelled after proc ::search::moves{}.

-- Create a new Tcl command serving as an interface to the CQL engine, iterating through the game filter and invoking the CQL engine on a per/game basis.  The sc_search_cql() command is modelled after the sc_search_moves() command, and interfaces with the CQL engine through a surrogate function found in parser.cpp, which simply determines whether or not a given game matches the CQL filter-set supplied by the UI.

-- Rework the native CQL exception handling scheme, since any exception occuring in processing the games would result in the standalone application simply printing an error message and bailing out.  The ported/integrated engine relays error and diagnostic messages via a couple of gloabl vars and performs a longjump() out of the nest of stack frames.  The use of the C++ std::setjmp()/std::longjmp() duo should be safe since all CQL-related destructors are trivial.

-- Replace altered games in the database.  Fortunately, this was a one-liner wrt the CQL code. Significantly more than that in sc_search_cql(). Altered games include those which have had their position match marks stripped in accordance with a user-controlled radio switch.

-- Resolve memory leaks:
  ** The CQL engine was never intended to be a long-lived entity.  Objects allocated on the heap are never deleted in the original code.  That is being corrected.
  ** The CQL code which allocates position marks (as game move comments) does so through Game::SetMoveComment(), which utilizes the StrAlloc infrastructure.  This memory is released by what passes for Game object destruction.
  ** The CqlNode class is the top dog in the abstraction hierarchy, and the destructor has been changed to virtual so that the delete operator will function correctly.
  ** More to come...

